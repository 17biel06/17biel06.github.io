<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Laberinto Pro</title> <!-- T√≠tulo actualizado -->
    <style>
        /* --- ROOT VARIABLES --- */
        :root {
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --transition-speed: 0.3s;
            --bottom-nav-height: 60px;
            --modal-max-width: 500px;
            --top-ui-height: 40px;

            /* Factors */
            --wall-thickness-factor: 0.1;
            --player-size-factor: 0.6;
            --end-marker-size-factor: 0.7;

            /* --- Light Theme Defaults --- */
            --bg-color-light: #f8f9fa; --panel-bg-light: #ffffff; --control-bg-light: #ffffff;
            --text-color-light: #212529; --text-muted-light: #6c757d; --border-color-light: #dee2e6;
            --primary-color-light: #007bff; --primary-hover-light: #0056b3; --shadow-light: rgba(0, 0, 0, 0.08);
            --input-bg-light: #ffffff; --input-border-light: #ced4da;
            /* Maze Specific - Light */
            --maze-bg-light: #e9ecef;
            --wall-color-light: #343a40; --wall-glow-light: transparent; --wall-shadow-light: rgba(0, 0, 0, 0.1);
            --player-color-light: #e63946; --player-glow-light: rgba(230, 57, 70, 0.3); --player-shadow-light: rgba(230, 57, 70, 0.4);
            --start-color-light: #a8dadc; --end-color-light: #457b9d; --path-color-light: rgba(227, 242, 253, 0.3);
            --minimap-bg-light: rgba(255, 255, 255, 0.9); --minimap-border-light: #adb5bd;
            --minimap-player-light: var(--player-color-light); --minimap-start-light: var(--start-color-light); --minimap-end-light: var(--end-color-light);

            /* --- Dark Theme Defaults --- */
            --bg-color-dark: #121212; --panel-bg-dark: #1e1e1e; --control-bg-dark: #2a2a2a;
            --text-color-dark: #e0e0e0; --text-muted-dark: #adb5bd; --border-color-dark: #333;
            --primary-color-dark: #4dabf7; --primary-hover-dark: #1e88e5; --shadow-dark: rgba(255, 255, 255, 0.06);
            --input-bg-dark: #252525; --input-border-dark: #444;
            /* Maze Specific - Dark */
            --maze-bg-dark: #212121;
            --wall-color-dark: #ced4da; --wall-glow-dark: rgba(206, 212, 218, 0.15); --wall-shadow-dark: transparent;
            --player-color-dark: #ff8a80; --player-glow-dark: rgba(255, 138, 128, 0.35); --player-shadow-dark: rgba(255, 138, 128, 0.5);
            --start-color-dark: #546e7a; --end-color-dark: #81d4fa; --path-color-dark: rgba(50, 50, 70, 0.3);
            --minimap-bg-dark: rgba(30, 30, 30, 0.92); --minimap-border-dark: #6c757d;
            --minimap-player-dark: var(--player-color-dark); --minimap-start-dark: var(--start-color-dark); --minimap-end-dark: var(--end-color-dark);

            /* --- Default assignments --- */
            --bg-color: var(--bg-color-light); --panel-bg: var(--panel-bg-light); --control-bg: var(--control-bg-light);
            --text-color: var(--text-color-light); --text-muted: var(--text-muted-light); --border-color: var(--border-color-light);
            --primary-color: var(--primary-color-light); --primary-hover: var(--primary-hover-light); --shadow: var(--shadow-light);
            --input-bg: var(--input-bg-light); --input-border: var(--input-border-light);
            --maze-bg: var(--maze-bg-light); --wall-color: var(--wall-color-light); --wall-glow: var(--wall-glow-light); --wall-shadow: var(--wall-shadow-light);
            --player-color: var(--player-color-light); --player-glow: var(--player-glow-light); --player-shadow: var(--player-shadow-light);
            --start-color: var(--start-color-light); --end-color: var(--end-color-light); --path-color: var(--path-color-light);
            --minimap-bg: var(--minimap-bg-light); --minimap-border: var(--minimap-border-light); --minimap-player: var(--minimap-player-light);
            --minimap-start: var(--minimap-start-light); --minimap-end: var(--minimap-end-light);
            --primary-color-rgb: 0, 123, 255; --panel-bg-rgb: 255, 255, 255;
        }

        /* --- Theme Application --- */
        body {
            /* Light Theme Variables */
            --bg-color: var(--bg-color-light); --panel-bg: var(--panel-bg-light); --control-bg: var(--control-bg-light);
            --text-color: var(--text-color-light); --text-muted: var(--text-muted-light); --border-color: var(--border-color-light);
            --primary-color: var(--primary-color-light); --primary-hover: var(--primary-hover-light); --shadow: var(--shadow-light);
            --input-bg: var(--input-bg-light); --input-border: var(--input-border-light);
            --primary-color-rgb: 0, 123, 255; --panel-bg-rgb: 255, 255, 255;

            /* Style defaults point to Light theme values initially */
            --maze-bg: var(--_maze-style-light, var(--maze-bg-light));
            --wall-color: var(--_wall-style-light, var(--wall-color-light));
            --wall-glow: var(--_wall-glow-style-light, var(--wall-glow-light));
            --wall-shadow: var(--_wall-shadow-style-light, var(--wall-shadow-light));
            --player-color: var(--_player-style-light, var(--player-color-light)); /* Set via JS */
            --player-glow: var(--_player-glow-style-light, var(--player-glow-light));
            --player-shadow: var(--_player-shadow-style-light, var(--player-shadow-light));
            --start-color: var(--_start-style-light, var(--start-color-light));
            --end-color: var(--_end-style-light, var(--end-color-light));
            --minimap-bg: var(--_minimap-bg-style-light, var(--minimap-bg-light));
            --minimap-border: var(--_minimap-border-style-light, var(--minimap-border-light));
            --minimap-player: var(--_minimap-player-style-light, var(--player-color)); /* Minimap uses current player color */
            --minimap-start: var(--_minimap-start-style-light, var(--start-color-light));
            --minimap-end: var(--_minimap-end-style-light, var(--end-color-light));
        }

        body.dark-mode {
            /* Dark Theme Variables */
            --bg-color: var(--bg-color-dark); --panel-bg: var(--panel-bg-dark); --control-bg: var(--control-bg-dark);
            --text-color: var(--text-color-dark); --text-muted: var(--text-muted-dark); --border-color: var(--border-color-dark);
            --primary-color: var(--primary-color-dark); --primary-hover: var(--primary-hover-dark); --shadow: var(--shadow-dark);
            --input-bg: var(--input-bg-dark); --input-border: var(--input-border-dark);
            --primary-color-rgb: 74, 171, 247; --panel-bg-rgb: 30, 30, 30;

            /* Style defaults point to Dark theme values */
            --maze-bg: var(--_maze-style-dark, var(--maze-bg-dark));
            --wall-color: var(--_wall-style-dark, var(--wall-color-dark));
            --wall-glow: var(--_wall-glow-style-dark, var(--wall-glow-dark));
            --wall-shadow: var(--_wall-shadow-style-dark, var(--wall-shadow-dark));
            --player-color: var(--_player-style-dark, var(--player-color-dark)); /* Set via JS */
            --player-glow: var(--_player-glow-style-dark, var(--player-glow-dark));
            --player-shadow: var(--_player-shadow-style-dark, var(--player-shadow-dark));
            --start-color: var(--_start-style-dark, var(--start-color-dark));
            --end-color: var(--_end-style-dark, var(--end-color-dark));
            --minimap-bg: var(--_minimap-bg-style-dark, var(--minimap-bg-dark));
            --minimap-border: var(--_minimap-border-style-dark, var(--minimap-border-dark));
            --minimap-player: var(--_minimap-player-style-dark, var(--player-color)); /* Minimap uses current player color */
            --minimap-start: var(--_minimap-start-style-dark, var(--start-color-dark));
            --minimap-end: var(--_minimap-end-style-dark, var(--end-color-dark));
        }

        /* --- Maze Style Definitions --- */
        /* Classic */
        body[data-maze-style="classic"] {
            --_maze-style-light: var(--maze-bg-light);           --_maze-style-dark: var(--maze-bg-dark);
            --_wall-style-light: var(--wall-color-light);         --_wall-style-dark: var(--wall-color-dark);
            --_wall-glow-style-light: transparent;                --_wall-glow-style-dark: rgba(206, 212, 218, 0.1);
            --_wall-shadow-style-light: rgba(0, 0, 0, 0.1);       --_wall-shadow-style-dark: transparent;
            --_player-style-light: var(--player-color-light);     --_player-style-dark: var(--player-color-dark);
            --_player-glow-style-light: var(--player-glow-light); --_player-glow-style-dark: var(--player-glow-dark);
            --_player-shadow-style-light: var(--player-shadow-light); --_player-shadow-style-dark: var(--player-shadow-dark);
            --_start-style-light: var(--start-color-light);       --_start-style-dark: var(--start-color-dark);
            --_end-style-light: var(--end-color-light);           --_end-style-dark: var(--end-color-dark);
            --_minimap-bg-style-light: var(--minimap-bg-light);   --_minimap-bg-style-dark: var(--minimap-bg-dark);
            --_minimap-border-style-light: var(--minimap-border-light); --_minimap-border-style-dark: var(--minimap-border-dark);
            --_minimap-start-style-light: var(--_start-style-light); --_minimap-start-style-dark: var(--_start-style-dark);
            --_minimap-end-style-light: var(--_end-style-light);     --_minimap-end-style-dark: var(--_end-style-dark);
            --wall-thickness-factor: 0.1; --player-size-factor: 0.6;
        }
        /* Matrix */
        body[data-maze-style="matrix"] {
            --_maze-style-light: #030303;                         --_maze-style-dark: #000000;
            --_wall-style-light: #00ff41;                         --_wall-style-dark: #00ff41;
            --_wall-glow-style-light: rgba(0, 255, 65, 0.3);      --_wall-glow-style-dark: rgba(0, 255, 65, 0.35);
            --_wall-shadow-style-light: transparent;              --_wall-shadow-style-dark: transparent;
            --_player-style-light: #ffffff;                       --_player-style-dark: #ffffff;
            --_player-glow-style-light: rgba(255, 255, 255, 0.4); --_player-glow-style-dark: rgba(255, 255, 255, 0.5);
            --_player-shadow-style-light: transparent;            --_player-shadow-style-dark: transparent;
            --_start-style-light: #00330a;                        --_start-style-dark: #004d11;
            --_end-style-light: #00801c;                          --_end-style-dark: #00cc2e;
            --_minimap-bg-style-light: rgba(0, 20, 0, 0.9);       --_minimap-bg-style-dark: rgba(0, 10, 0, 0.95);
            --_minimap-border-style-light: #00ff41;               --_minimap-border-style-dark: #00cc2e;
            --_minimap-start-style-light: var(--_start-style-light); --_minimap-start-style-dark: var(--_start-style-dark);
            --_minimap-end-style-light: var(--_end-style-light);     --_minimap-end-style-dark: var(--_end-style-dark);
            --wall-thickness-factor: 0.08; --player-size-factor: 0.55;
        }
        /* Blueprint */
        body[data-maze-style="blueprint"] {
            --_maze-style-light: #2962ff;                         --_maze-style-dark: #1a237e;
            --_wall-style-light: #ffffff;                         --_wall-style-dark: #bbdefb;
            --_wall-glow-style-light: rgba(255, 255, 255, 0.1);   --_wall-glow-style-dark: rgba(187, 222, 251, 0.15);
            --_wall-shadow-style-light: transparent;              --_wall-shadow-style-dark: transparent;
            --_player-style-light: #ffeb3b;                       --_player-style-dark: #fff59d;
            --_player-glow-style-light: rgba(255, 235, 59, 0.5);  --_player-glow-style-dark: rgba(255, 245, 157, 0.5);
            --_player-shadow-style-light: transparent;            --_player-shadow-style-dark: transparent;
            --_start-style-light: #1c50d3;                        --_start-style-dark: #101649;
            --_end-style-light: #5c87ff;                          --_end-style-dark: #3f51b5;
            --_minimap-bg-style-light: rgba(41, 98, 255, 0.85);   --_minimap-bg-style-dark: rgba(26, 35, 126, 0.9);
            --_minimap-border-style-light: #ffffff;               --_minimap-border-style-dark: #bbdefb;
            --_minimap-start-style-light: var(--_start-style-light); --_minimap-start-style-dark: var(--_start-style-dark);
            --_minimap-end-style-light: var(--_end-style-light);     --_minimap-end-style-dark: var(--_end-style-dark);
            --wall-thickness-factor: 0.04; --player-size-factor: 0.65;
        }
        /* Neon */
        body[data-maze-style="neon"] {
            --_maze-style-light: #1a1a2e;                         --_maze-style-dark: #0f0f1a;
            --_wall-style-light: #ff00ff;                         --_wall-style-dark: #ff40ff;
            --_wall-glow-style-light: rgba(255, 0, 255, 0.4);     --_wall-glow-style-dark: rgba(255, 64, 255, 0.5);
            --_wall-shadow-style-light: transparent;              --_wall-shadow-style-dark: transparent;
            --_player-style-light: #00ffff;                       --_player-style-dark: #7fffd4;
            --_player-glow-style-light: rgba(0, 255, 255, 0.5);   --_player-glow-style-dark: rgba(100, 255, 255, 0.6);
            --_player-shadow-style-light: transparent;            --_player-shadow-style-dark: transparent;
            --_start-style-light: #330033;                        --_start-style-dark: #4d004d;
            --_end-style-light: #800080;                          --_end-style-dark: #b300b3;
            --_minimap-bg-style-light: rgba(26, 26, 46, 0.9);     --_minimap-bg-style-dark: rgba(15, 15, 26, 0.95);
            --_minimap-border-style-light: #ff00ff;               --_minimap-border-style-dark: #ff40ff;
            --_minimap-start-style-light: var(--_start-style-light); --_minimap-start-style-dark: var(--_start-style-dark);
            --_minimap-end-style-light: var(--_end-style-light);     --_minimap-end-style-dark: var(--_end-style-dark);
            --wall-thickness-factor: 0.1; --player-size-factor: 0.6;
        }
        /* Cyber */
        body[data-maze-style="cyber"] {
            --_maze-style-light: #2a004f;                         --_maze-style-dark: #1a0033;
            --_wall-style-light: #00ffff;                         --_wall-style-dark: #7fffd4;
            --_wall-glow-style-light: rgba(0, 255, 255, 0.3);     --_wall-glow-style-dark: rgba(127, 255, 212, 0.35);
            --_wall-shadow-style-light: transparent;              --_wall-shadow-style-dark: transparent;
            --_player-style-light: #ff69b4;                       --_player-style-dark: #ff85c0;
            --_player-glow-style-light: rgba(255, 105, 180, 0.5); --_player-glow-style-dark: rgba(255, 155, 200, 0.6);
            --_player-shadow-style-light: transparent;            --_player-shadow-style-dark: transparent;
            --_start-style-light: #480082;                        --_start-style-dark: #300050;
            --_end-style-light: #8a2be2;                          --_end-style-dark: #9370db;
            --_minimap-bg-style-light: rgba(42, 0, 79, 0.9);      --_minimap-bg-style-dark: rgba(26, 0, 51, 0.95);
            --_minimap-border-style-light: #00ffff;               --_minimap-border-style-dark: #7fffd4;
            --_minimap-start-style-light: var(--_start-style-light); --_minimap-start-style-dark: var(--_start-style-dark);
            --_minimap-end-style-light: var(--_end-style-light);     --_minimap-end-style-dark: var(--_end-style-dark);
            --wall-thickness-factor: 0.08; --player-size-factor: 0.6;
        }

        /* --- General Layout & UI Elements --- */
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        html, body { height: 100%; width: 100%; }
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            width: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
        }
        #main-content {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #game-ui-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: var(--top-ui-height);
            display: flex; justify-content: center; align-items: center; padding: 5px 10px;
            z-index: 100; pointer-events: none;
        }
        .timer-display {
            background-color: rgba(var(--panel-bg-rgb, 255, 255, 255), 0.85);
            color: var(--primary-color);
            padding: 0.3rem 0.8rem; border-radius: 15px; font-size: 0.9rem; font-weight: bold;
            box-shadow: 0 1px 3px var(--shadow); pointer-events: auto;
            display: inline-flex; align-items: center;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
            min-width: 55px; /* Ensure space for time */
            justify-content: center;
        }
        #maze-container {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            background-color: var(--maze-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
            z-index: 1;
            transition: background-color var(--transition-speed) ease;
        }
        #mazeCanvas {
            display: block;
            position: absolute;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            transform-origin: top left;
        }
        #bottom-nav {
            flex-shrink: 0; height: var(--bottom-nav-height); background-color: var(--panel-bg);
            border-top: 1px solid var(--border-color); box-shadow: 0 -2px 5px var(--shadow);
            display: flex; justify-content: space-around; align-items: center; padding: 0 10px;
            gap: 5px;
            z-index: 1000;
            transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
        }
        #bottom-nav button {
             background: none; border: none; color: var(--text-muted);
             display: flex; flex-direction: column; align-items: center;
             padding: 4px 8px;
             font-size: 0.7rem;
             cursor: pointer; transition: color 0.2s ease, background-color 0.2s ease;
             border-radius: 4px; min-height: 50px; justify-content: center;
             flex-grow: 1; max-width: 100px;
             text-align: center;
             white-space: nowrap;
        }
        #bottom-nav button .icon { font-size: 1.4rem; margin-bottom: 1px; }
        #bottom-nav button.active { color: var(--primary-color); background-color: rgba(var(--primary-color-rgb), 0.1); }
        #bottom-nav button:hover:not(:disabled):not(.active) { background-color: rgba(var(--primary-color-rgb), 0.05); }
        #bottom-nav button:disabled { color: var(--border-color); cursor: not-allowed; opacity: 0.6; }

        /* --- Modals Common --- */
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 0.8rem 1.2rem; border-bottom: 1px solid var(--border-color); flex-shrink: 0; transition: border-color var(--transition-speed) ease; }
        .modal-header h2 { margin: 0; font-size: 1.2rem; color: var(--primary-color); transition: color var(--transition-speed) ease; }
        .modal-content { overflow-y: auto; display: flex; flex-direction: column; flex-grow: 1; }
        .modal-footer { flex-shrink: 0; padding: 0.8rem 1.2rem; border-top: 1px solid var(--border-color); text-align: right; transition: border-color var(--transition-speed) ease; }

        /* --- Settings Modal Specific --- */
        #settings-modal-backdrop { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.6); z-index: 1100; opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, visibility 0s linear var(--transition-speed); }
        #settings-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9); width: 90%; max-width: var(--modal-max-width); max-height: 85vh; background-color: var(--panel-bg); border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); z-index: 1110; opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, transform var(--transition-speed) ease, visibility 0s linear var(--transition-speed), background-color var(--transition-speed) ease; display: flex; flex-direction: column; }
        #settings-modal-backdrop.visible { opacity: 1; visibility: visible; transition-delay: 0s; }
        #settings-modal.visible { opacity: 1; visibility: visible; transform: translate(-50%, -50%) scale(1); transition-delay: 0s; }
        #closeSettingsBtn { background: none; border: none; font-size: 1.8rem; line-height: 1; color: var(--text-muted); cursor: pointer; padding: 0.2rem; transition: color var(--transition-speed) ease; }
        #settings-modal .modal-content { padding: 1rem 1.2rem; gap: 1.2rem; }
        .control-group { background-color: var(--control-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 0.8rem 1rem; box-shadow: 0 1px 3px var(--shadow); transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease; }
        .control-group h3 { margin: 0 0 0.8rem 0; font-size: 0.9rem; font-weight: 600; color: var(--primary-color); padding-bottom: 0.4rem; border-bottom: 1px solid var(--border-color); transition: color var(--transition-speed) ease, border-color var(--transition-speed) ease; }
        label, .label-like { display: block; margin-bottom: 0.3rem; font-weight: 500; font-size: 0.85rem; color: var(--text-muted); padding-top: 0.2rem; transition: color var(--transition-speed) ease; }
        input[type="number"], select { width: 100%; padding: 0.6rem 0.75rem; margin-bottom: 0.75rem; min-height: 42px; border: 1px solid var(--input-border); border-radius: 4px; background-color: var(--input-bg); color: var(--text-color); font-size: 0.9rem; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, color var(--transition-speed) ease; }
        button.modal-button { display: block; width: 100%; padding: 0.7rem 1.2rem; background-color: var(--primary-color); color: #ffffff; border: none; border-radius: 5px; cursor: pointer; font-size: 0.9rem; font-weight: 500; margin-top: 0.5rem; text-align: center; min-height: 42px; transition: background-color var(--transition-speed) ease; }
        button.modal-button:hover:not(:disabled) { background-color: var(--primary-hover); }
        .button-group { display: flex; gap: 0.75rem; }
        .button-group button { flex: 1; }
        .switch-container { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem; min-height: 40px;}
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; flex-shrink: 0; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary-color); }
        input:checked + .slider:before { transform: translateX(20px); }
        .choice-group { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.5rem; }
        .choice-group label { margin-bottom: 0; cursor: pointer; }
        .choice-group label[hidden] { display: none; }
        .choice-group input[type="radio"], .choice-group input[type="checkbox"] { display: none; }
        .choice-group span { display: inline-flex; align-items: center; justify-content: center; padding: 0.5rem 0.8rem; border: 1px solid var(--border-color); border-radius: 4px; background-color: var(--input-bg); font-size: 0.85rem; text-align: center; min-width: 36px; min-height: 36px; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, color var(--transition-speed) ease, box-shadow var(--transition-speed) ease; }
        .choice-group span.color-preview { width: 32px; height: 32px; padding: 0; border-radius: 50%; box-shadow: inset 0 0 0 1px var(--border-color); }
        .choice-group input:checked + span { background-color: var(--primary-color); color: white; border-color: var(--primary-color); box-shadow: 0 0 0 2px rgba(var(--primary-color-rgb), 0.4); }

        /* --- Scores Modal Specific --- */
         #scores-modal-backdrop { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.6); z-index: 1090; opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, visibility 0s linear var(--transition-speed); }
         #scores-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9); width: 90%; max-width: 450px; max-height: 75vh; background-color: var(--panel-bg); border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); z-index: 1095; opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, transform var(--transition-speed) ease, visibility 0s linear var(--transition-speed), background-color var(--transition-speed) ease; display: flex; flex-direction: column; }
         #scores-modal-backdrop.visible { opacity: 1; visibility: visible; transition-delay: 0s; }
         #scores-modal.visible { opacity: 1; visibility: visible; transform: translate(-50%, -50%) scale(1); transition-delay: 0s; }
         #scores-modal .modal-header h2 { color: var(--primary-color); }
         #closeScoresBtn { background: none; border: none; font-size: 1.8rem; line-height: 1; color: var(--text-muted); cursor: pointer; padding: 0.2rem; transition: color var(--transition-speed) ease; }
         #scores-list-container { padding: 0.5rem 0; }
         .score-entry { display: flex; justify-content: space-between; align-items: center; padding: 0.7rem 1.2rem; border-bottom: 1px solid var(--border-color); font-size: 0.95rem; transition: background-color 0.2s ease, border-color var(--transition-speed) ease; }
         .score-entry:last-child { border-bottom: none; }
         .score-entry:hover { background-color: rgba(var(--primary-color-rgb), 0.05); }
         .score-size { font-weight: 600; color: var(--text-color); flex-basis: 40%; transition: color var(--transition-speed) ease; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
         .score-time { font-weight: 500; color: var(--primary-color); flex-basis: 50%; text-align: right; font-family: 'Courier New', Courier, monospace; font-size: 1rem; transition: color var(--transition-speed) ease; }
         .no-scores-message { display: none; text-align: center; color: var(--text-muted); padding: 2rem 1.2rem; transition: color var(--transition-speed) ease; }
         #clearScoresBtn { background-color: transparent; color: var(--text-muted); border: 1px solid var(--border-color); padding: 0.5rem 1rem; font-size: 0.8rem; border-radius: 5px; cursor: pointer; min-height: auto; width: auto; display: inline-block; transition: background-color 0.2s ease, color 0.2s ease, border-color var(--transition-speed) ease; }
         body.dark-mode #clearScoresBtn { color: var(--text-muted-dark); }
         #clearScoresBtn:hover:not(:disabled) { background-color: rgba(220, 53, 69, 0.1); color: #dc3545; border-color: rgba(220, 53, 69, 0.3); }
         #clearScoresBtn:disabled { opacity: 0.5; cursor: not-allowed; background-color: transparent !important; color: var(--text-muted) !important; border-color: var(--border-color) !important; }
         #bottom-nav button#scoresBtn.active { color: var(--primary-color); background-color: rgba(var(--primary-color-rgb), 0.1); }

        /* --- Message Overlay, Loading, Minimap --- */
        #message-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.75); display: flex; justify-content: center; align-items: center; z-index: 1200; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s; padding: 1rem; }
        #message-overlay.visible { opacity: 1; visibility: visible; transition-delay: 0s; }
        #message-box { background-color: var(--panel-bg); color: var(--text-color); padding: 1.5rem 2rem; border-radius: 10px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.25); transform: scale(0.9); transition: transform 0.3s ease, background-color var(--transition-speed) ease, color var(--transition-speed) ease; width: 90%; max-width: 350px; }
        #message-overlay.visible #message-box { transform: scale(1); transition-delay: 0s;}
        #message-box h2 { margin: 0 0 1rem 0; font-size: 1.4rem; color: var(--primary-color); transition: color var(--transition-speed) ease; }
        #message-box p { margin-bottom: 1.5rem; font-size: 0.95rem; line-height: 1.5; }
        #message-box button { width: auto; padding: 0.7rem 1.8rem; font-size: 0.95rem; }
        #final-time-msg { font-weight: bold; margin-top:-0.5rem; margin-bottom: 1.5rem; display: none; }
        #final-best-time-msg { font-size: 0.85rem; color: var(--text-muted); margin-top:-1rem; margin-bottom: 1.5rem; display: none; transition: color var(--transition-speed) ease; }
        #loading-indicator { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 1.2rem 1.5rem; border-radius: 8px; font-size: 1rem; z-index: 1250; text-align: center; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s; pointer-events: none; }
        #loading-indicator.visible { opacity: 1; visibility: visible; transition-delay: 0s; }
        #minimapContainer { position: absolute; bottom: calc(var(--bottom-nav-height) + 15px); right: 15px; border: 2px solid var(--minimap-border); background-color: var(--minimap-bg); box-shadow: 0 0 8px rgba(0,0,0,0.25); z-index: 10; display: none; max-width: 120px; max-height: 120px; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease; border-radius: 4px; }
        #minimapCanvas { display: block; image-rendering: pixelated; image-rendering: crisp-edges; }

        /* --- Print Styles --- */
        @media print {
            body { --transition-speed: 0s !important; }
            #bottom-nav, #settings-modal-backdrop, #settings-modal, #scores-modal-backdrop, #scores-modal, #game-ui-overlay, #message-overlay, #loading-indicator, #minimapContainer { display: none !important; }
            #main-content { border: none; padding: 0; width: 100% !important; height: 100% !important; flex-grow: 1 !important; }
            #maze-container { width: 100% !important; height: auto !important; max-height: 95vh !important; padding: 0 !important; margin: 0 !important; overflow: visible !important; border: 1px solid #ccc !important; background-color: #fff !important; justify-content: flex-start !important; align-items: flex-start !important; flex-grow: 1 !important; }
            body, body.dark-mode { /* Force light theme for printing */
                background-color: #fff !important; color: #000 !important;
                --bg-color: #ffffff; --text-color: #000000;
                --maze-bg: #ffffff;
                --wall-color: #000000; --wall-glow: transparent; --wall-shadow: transparent;
                --player-color: #aaaaaa; --player-glow: transparent; --player-shadow: transparent;
                --start-color: #e0e0e0; --end-color: #c0c0c0;
                --minimap-start: var(--start-color); --minimap-end: var(--end-color);
                --wall-thickness-factor: 0.1; --player-size-factor: 0.6; --end-marker-size-factor: 0.7;
            }
            #mazeCanvas { position: static !important; max-width: 100% !important; height: auto !important; box-shadow: none !important; border: none !important; background-color: transparent !important; transform: none !important; left: 0 !important; top: 0 !important; }
            @page { size: auto; margin: 5mm; }
        }
    </style>
</head>
<body data-maze-style="classic"> <!-- Default style -->

<main id="main-content">
    <div id="game-ui-overlay"><div class="timer-display"><span id="current-time">00:00</span></div></div>
    <div id="maze-container">
        <canvas id="mazeCanvas"></canvas>
        <div id="minimapContainer"><canvas id="minimapCanvas"></canvas></div>
    </div>
    <div id="message-overlay">
        <div id="message-box">
            <h2>¬°Victoria!</h2>
            <p>¬°Has encontrado la salida!</p>
            <p id="final-time-msg"></p>
            <p id="final-best-time-msg"></p>
            <button id="playAgainBtn" class="modal-button">Jugar Otra Vez</button>
        </div>
    </div>
    <div id="loading-indicator">Generando...</div>
</main>

<nav id="bottom-nav">
    <button id="newGameBtn" title="Generar Nuevo Laberinto"><span class="icon">‚ûï</span><span>Nuevo</span></button>
    <button id="viewModeBtn" title="Cambiar Vista (Actual: General)" data-mode="overview"><span class="icon">üëÅÔ∏è</span><span>Vista</span></button>
    <button id="scoresBtn" title="Ver Mejores Tiempos"><span class="icon">üèÜ</span><span>Marcas</span></button>
    <button id="settingsBtn" title="Abrir Ajustes"><span class="icon">‚öôÔ∏è</span><span>Ajustes</span></button>
</nav>

<!-- Settings Modal -->
<div id="settings-modal-backdrop"></div>
<div id="settings-modal" role="dialog" aria-labelledby="settingsModalTitle" aria-modal="true">
    <div class="modal-header">
        <h2 id="settingsModalTitle">Ajustes</h2>
        <button id="closeSettingsBtn" aria-label="Cerrar Ajustes">√ó</button>
    </div>
    <div class="modal-content">
        <div class="control-group">
            <h3>Generaci√≥n</h3>
            <label for="modal-width">Ancho (5-500):</label>
            <input type="number" id="modal-width" value="15" min="5" max="500">
            <label for="modal-height">Alto (5-500):</label>
            <input type="number" id="modal-height" value="15" min="5" max="500">
            <p id="best-time-modal" style="font-size: 0.85rem; color: var(--text-muted); margin: 0.5rem 0;">Record (Actual): --:--</p>
            <button id="modal-generateBtn" class="modal-button">Generar Nuevo</button>
        </div>
        <div class="control-group">
            <h3>Apariencia</h3>
            <div class="switch-container">
                <label for="modal-darkModeToggle" class="label-like" style="margin-bottom: 0;">Modo Oscuro</label>
                <label class="switch">
                    <input type="checkbox" id="modal-darkModeToggle">
                    <span class="slider round"></span>
                </label>
            </div>
            <label for="modal-mazeStyle" class="label-like">Estilo Visual:</label>
            <div class="choice-group" id="modal-mazeStyle">
                <label><input type="radio" name="modal-style" value="classic" checked> <span>Cl√°sico</span></label>
                <label><input type="radio" name="modal-style" value="matrix"> <span>Matrix</span></label>
                <label><input type="radio" name="modal-style" value="blueprint"> <span>Plano</span></label>
                <label><input type="radio" name="modal-style" value="neon"> <span>Ne√≥n</span></label>
                <label><input type="radio" name="modal-style" value="cyber"> <span>Cyber</span></label>
            </div>
            <label class="label-like">Personaje:</label>
             <div class="choice-group" id="modal-playerChoice">
                 <!-- Generic Choices -->
                 <label title="Rojo"><input type="radio" name="modal-player" value="#e63946" data-light="#e63946" data-dark="#ff8a80" checked> <span class="color-preview" style="background-color: #e63946;"></span></label>
                 <label title="Azul"><input type="radio" name="modal-player" value="#1d3557" data-light="#1d3557" data-dark="#a1c4fd"> <span class="color-preview" style="background-color: #1d3557;"></span></label>
                 <label title="Verde"><input type="radio" name="modal-player" value="#588157" data-light="#588157" data-dark="#a5d6a7"> <span class="color-preview" style="background-color: #588157;"></span></label>
                 <label title="Amarillo"><input type="radio" name="modal-player" value="#ffb703" data-light="#ffb703" data-dark="#fff176"> <span class="color-preview" style="background-color: #ffb703;"></span></label>
                 <label title="P√∫rpura"><input type="radio" name="modal-player" value="#6a0dad" data-light="#6a0dad" data-dark="#ce93d8"> <span class="color-preview" style="background-color: #6a0dad;"></span></label>
                 <!-- Style-Specific Choices (Hidden by default, shown by JS) -->
                 <label title="Matrix Player" data-style-specific="matrix" hidden><input type="radio" name="modal-player" value="#ffffff" data-light="#ffffff" data-dark="#ffffff"> <span class="color-preview" style="background-color: #ffffff;"></span></label>
                 <label title="Blueprint Player" data-style-specific="blueprint" hidden><input type="radio" name="modal-player" value="#ffeb3b" data-light="#ffeb3b" data-dark="#fff59d"> <span class="color-preview" style="background-color: #ffeb3b;"></span></label>
                 <label title="Neon Player" data-style-specific="neon" hidden><input type="radio" name="modal-player" value="#00ffff" data-light="#00ffff" data-dark="#7fffd4"> <span class="color-preview" style="background-color: #00ffff;"></span></label>
                 <label title="Cyber Player" data-style-specific="cyber" hidden><input type="radio" name="modal-player" value="#ff69b4" data-light="#ff69b4" data-dark="#ff85c0"> <span class="color-preview" style="background-color: #ff69b4;"></span></label>
             </div>
            <label class="label-like">Indicador Salida:</label>
            <div class="choice-group" id="modal-exitChoice">
                <label><input type="radio" name="modal-exit" value="üèÅ" checked> <span>üèÅ</span></label>
                <label><input type="radio" name="modal-exit" value="‚òÖ"> <span>‚òÖ</span></label>
                <label><input type="radio" name="modal-exit" value="‚óé"> <span>‚óé</span></label>
                <label><input type="radio" name="modal-exit" value="üéØ"> <span>üéØ</span></label>
                <label><input type="radio" name="modal-exit" value="‚úÖ"> <span>‚úÖ</span></label>
            </div>
            <div class="button-group" style="margin-top: 1rem;">
                <button id="modal-printBtn" class="modal-button" title="Imprimir Laberinto Actual">Imprimir</button>
            </div>
        </div>
    </div>
</div>

<!-- Scores Modal -->
<div id="scores-modal-backdrop"></div>
<div id="scores-modal" role="dialog" aria-labelledby="scoresModalTitle" aria-modal="true">
    <div class="modal-header">
        <h2 id="scoresModalTitle">Mejores Tiempos</h2>
        <button id="closeScoresBtn" aria-label="Cerrar Mejores Tiempos">√ó</button>
    </div>
    <div class="modal-content" id="scores-list-container">
        <div class="no-scores-message" style="display: none;">
            A√∫n no has completado ning√∫n laberinto. ¬°Juega para registrar tus marcas!
        </div>
    </div>
    <div class="modal-footer">
         <button id="clearScoresBtn" class="modal-button secondary-button" title="Borrar todos los r√©cords guardados">Borrar Todo</button>
    </div>
</div>


<script>
    // --- Constants & Settings ---
    const MAX_MAZE_DIMENSION = 500;
    const MOBILE_BREAKPOINT_WIDTH = 768;
    const MOBILE_MAX_INPUT_DIMENSION = 70;
    const MIN_MAZE_DIMENSION = 5;
    const CAMERA_SMOOTHING = 0.08;
    const PLAYER_SMOOTHING = 0.2;
    const GENERATION_YIELD_INTERVAL = 5000;
    const MINIMAP_MAX_SIZE = 120;
    const MINIMAP_PLAYER_DOT_SIZE = 3;
    const MINIMAP_CELL_MARKER_SCALE = 0.7;
    const BASE_CELL_SIZE_PLAYER_VIEW = 45;
    const SWIPE_THRESHOLD = 25;
    const EFFECTS_MIN_CELL_SIZE = 12;

    // --- Polyfills ---
    if (!Element.prototype.requestFullscreen) Element.prototype.requestFullscreen = Element.prototype.mozRequestFullScreen || Element.prototype.webkitRequestFullscreen || Element.prototype.msRequestFullscreen;
    if (!document.exitFullscreen) document.exitFullscreen = document.mozCancelFullScreen || document.webkitExitFullscreen || document.msExitFullscreen;
    Object.defineProperty(document, 'fullscreenElement', { get: () => document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document._fullscreenElement });

    // --- Helper Functions ---
    const lerp = (a, b, t) => a + (b - a) * t;
    const clamp = (val, min, max) => Math.min(Math.max(val, min), max);
    const getCssVariable = (varName) => getComputedStyle(document.body).getPropertyValue(varName).trim();

    // --- GA Event Tracking Helper ---
    /**
     * Sends an event to Google Analytics (if gtag is available).
     * @param {string} eventName The name of the event.
     * @param {object} [params={}] Optional parameters for the event.
     */
    function trackEvent(eventName, params = {}) {
        if (typeof gtag === 'function') {
            // Clean parameters: remove undefined or null values
            const cleanParams = {};
            for (const key in params) {
                if (params[key] !== undefined && params[key] !== null) {
                    // Convert boolean to string for GA consistency if desired
                    // if (typeof params[key] === 'boolean') {
                    //     cleanParams[key] = String(params[key]);
                    // } else {
                         cleanParams[key] = params[key];
                    // }
                }
            }
            // Log for debugging (can be removed in production)
            console.log(`%c[TrackEvent]%c ${eventName}`, 'color: #f0a; font-weight: bold;', 'color: inherit;', cleanParams);
            try {
                gtag('event', eventName, cleanParams);
            } catch (e) {
                console.error(`Error sending gtag event '${eventName}':`, e);
                // Optionally send another GA event about the tracking failure itself
                // gtag('event', 'exception', { 'description': `Gtag call failed for ${eventName}: ${e.message}`, 'fatal': false });
            }
        } else {
            console.warn(`gtag not available, event not tracked: ${eventName}`, params);
        }
    }

    // --- Classes (Cell, MazeGenerator, Player) ---
    class Cell { constructor(x, y) { this.x = x; this.y = y; this.visited = false; this.walls = { top: true, right: true, bottom: true, left: true }; } }
    class MazeGenerator {
        constructor() { this.grid = []; this.width = 0; this.height = 0; this.start = { x: 0, y: 0 }; this.end = { x: 0, y: 0 }; this.generationComplete = false; }
        async generate(width, height, yieldCallback) {
            this.width = clamp(width, MIN_MAZE_DIMENSION, MAX_MAZE_DIMENSION); this.height = clamp(height, MIN_MAZE_DIMENSION, MAX_MAZE_DIMENSION);
            this.generationComplete = false; const startTime = performance.now(); console.log(`Starting generation for ${this.width}x${this.height}...`);
            this.grid = Array.from({ length: this.height }, (_, y) => Array.from({ length: this.width }, (_, x) => new Cell(x, y)));
            this.start = { x: 0, y: 0 }; this.end = { x: Math.max(0,this.width - 1), y: Math.max(0, this.height - 1) };
            const stack = []; let cellsProcessedSinceYield = 0; const totalCells = this.width * this.height; let visitedCells = 0;
            const startCell = this.grid[this.start.y][this.start.x]; startCell.visited = true; visitedCells++; stack.push(startCell);
            while (stack.length > 0) {
                const current = stack[stack.length - 1]; const neighbors = this.getUnvisitedNeighbors(current);
                if (neighbors.length > 0) { const next = neighbors[Math.floor(Math.random() * neighbors.length)]; this.removeWall(current, next); next.visited = true; visitedCells++; stack.push(next); }
                else { stack.pop(); }
                cellsProcessedSinceYield++;
                if (yieldCallback && cellsProcessedSinceYield >= GENERATION_YIELD_INTERVAL) {
                    const progress = visitedCells / totalCells; yieldCallback(progress);
                    await new Promise(resolve => setTimeout(resolve, 0)); cellsProcessedSinceYield = 0;
                }
            }
            if (yieldCallback) yieldCallback(1); this.generationComplete = true; const endTime = performance.now(); console.log(`Generation finished in ${(endTime - startTime).toFixed(2)} ms`); return this;
        }
        getUnvisitedNeighbors(cell) { const neighbors = []; const { x, y } = cell; const check = (nx, ny) => { if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height && !this.grid[ny][nx].visited) { neighbors.push(this.grid[ny][nx]); } }; check(x, y - 1); check(x + 1, y); check(x, y + 1); check(x - 1, y); return neighbors; }
        removeWall(a, b) { const dx = a.x - b.x; const dy = a.y - b.y; if (dx === 1) { a.walls.left = false; b.walls.right = false; } else if (dx === -1) { a.walls.right = false; b.walls.left = false; } if (dy === 1) { a.walls.top = false; b.walls.bottom = false; } else if (dy === -1) { a.walls.bottom = false; b.walls.top = false; } }
    }
    class Player { constructor(x, y, color) { this.x = x; this.y = y; this.targetX = x; this.targetY = y; this.pixelX = x; this.pixelY = y; this.color = color; this.isMoving = false; } moveTo(newX, newY) { this.targetX = newX; this.targetY = newY; if (Math.abs(this.targetX - this.pixelX) > 0.01 || Math.abs(this.targetY - this.pixelY) > 0.01) { this.isMoving = true; } } update(deltaTime) { if (!this.isMoving) return; this.pixelX = lerp(this.pixelX, this.targetX, PLAYER_SMOOTHING); this.pixelY = lerp(this.pixelY, this.targetY, PLAYER_SMOOTHING); if (Math.abs(this.pixelX - this.targetX) < 0.01 && Math.abs(this.pixelY - this.targetY) < 0.01) { this.pixelX = this.targetX; this.pixelY = this.targetY; this.x = Math.round(this.targetX); /* Snap logical position */ this.y = Math.round(this.targetY); this.isMoving = false; } } canMove(dx, dy, maze) { if (this.isMoving) return false; const currentX = this.x; const currentY = this.y; const nextX = currentX + dx; const nextY = currentY + dy; if (nextX < 0 || nextX >= maze.width || nextY < 0 || nextY >= maze.height) return false; const currentCell = maze.grid[currentY]?.[currentX]; if (!currentCell) return false; if (dx === 1 && currentCell.walls.right) return false; if (dx === -1 && currentCell.walls.left) return false; if (dy === 1 && currentCell.walls.bottom) return false; if (dy === -1 && currentCell.walls.top) return false; return { newX: nextX, newY: nextY }; } setColor(color) { this.color = color; } }

    // --- Minimap Class ---
    class Minimap {
        constructor(canvasId, containerId) {
            this.container = document.getElementById(containerId);
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d', { alpha: false });
            this.maze = null; this.player = null; this.size = MINIMAP_MAX_SIZE;
            this.cellWidth = 1; this.cellHeight = 1;
            this.wallColor = '#000'; this.playerColor = '#f00'; this.bgColor = 'rgba(255, 255, 255, 0.7)';
            this.borderColor = '#888'; this.startColor = '#afa'; this.endColor = '#aaf';
            this.visible = false;
            this.offscreenCanvas = document.createElement('canvas');
            this.offscreenCtx = this.offscreenCanvas.getContext('2d', { alpha: false });
            this.needsRedraw = true;
        }
        updateSource(maze, player) {
            const mazeChanged = this.maze !== maze;
            this.maze = maze; this.player = player;
            if (mazeChanged) this.needsRedraw = true;
            this.updateColors();
            if (this.maze && this.maze.generationComplete) this.calculateDimensions();
        }
        updateColors() {
            const newWallColor = getCssVariable('--wall-color'); const newPlayerColor = getCssVariable('--minimap-player');
            const newBgColor = getCssVariable('--minimap-bg'); const newBorderColor = getCssVariable('--minimap-border');
            const newStartColor = getCssVariable('--minimap-start'); const newEndColor = getCssVariable('--minimap-end');
            let colorsChanged = false;
            if (this.wallColor !== newWallColor) { this.wallColor = newWallColor; colorsChanged = true; }
            if (this.playerColor !== newPlayerColor) { this.playerColor = newPlayerColor; }
            if (this.bgColor !== newBgColor) { this.bgColor = newBgColor; this.container.style.backgroundColor = this.bgColor; colorsChanged = true; }
            if (this.borderColor !== newBorderColor) { this.borderColor = newBorderColor; this.container.style.borderColor = this.borderColor; }
            if (this.startColor !== newStartColor) { this.startColor = newStartColor; colorsChanged = true; }
            if (this.endColor !== newEndColor) { this.endColor = newEndColor; colorsChanged = true; }
            if (colorsChanged) this.needsRedraw = true;
        }
        calculateDimensions() {
            if (!this.maze || !this.container) return;
            const aspect = this.maze.width / this.maze.height;
            let mapW, mapH; const maxSize = parseInt(getComputedStyle(this.container).maxWidth) || MINIMAP_MAX_SIZE;
            if (aspect >= 1) { mapW = maxSize; mapH = Math.max(1, Math.floor(maxSize / aspect)); } else { mapH = maxSize; mapW = Math.max(1, Math.floor(maxSize * aspect)); }
            if (this.canvas.width !== mapW || this.canvas.height !== mapH) {
                this.canvas.width = mapW; this.canvas.height = mapH; this.offscreenCanvas.width = mapW; this.offscreenCanvas.height = mapH;
                this.cellWidth = mapW / this.maze.width; this.cellHeight = mapH / this.maze.height; this.needsRedraw = true;
            }
            this.container.style.width = `${mapW}px`; this.container.style.height = `${mapH}px`;
        }
        show() { if (!this.visible) { this.container.style.display = 'block'; this.visible = true; if (this.maze && this.maze.generationComplete) { this.calculateDimensions(); this.needsRedraw = true; this.draw(); } } }
        hide() { if (this.visible) { this.container.style.display = 'none'; this.visible = false; } }
        draw() {
            if (!this.visible || !this.maze || !this.player || !this.maze.generationComplete) return;
            const newPlayerColor = getCssVariable('--minimap-player'); if (this.playerColor !== newPlayerColor) this.playerColor = newPlayerColor;
            if (this.needsRedraw) { this.drawMazeToOffscreen(); this.needsRedraw = false; }
            this.ctx.drawImage(this.offscreenCanvas, 0, 0);
            this.ctx.fillStyle = this.playerColor; const playerX = this.player.pixelX * this.cellWidth; const playerY = this.player.pixelY * this.cellHeight;
            const playerDrawSize = Math.max(1.5, MINIMAP_PLAYER_DOT_SIZE); const centerX = playerX + this.cellWidth / 2; const centerY = playerY + this.cellHeight / 2;
            this.ctx.beginPath(); this.ctx.arc(centerX, centerY, playerDrawSize / 2, 0, Math.PI * 2); this.ctx.fill();
        }
        drawMazeToOffscreen() {
            if (!this.maze) return; const ctx = this.offscreenCtx; const width = this.offscreenCanvas.width; const height = this.offscreenCanvas.height;
            ctx.fillStyle = this.bgColor; ctx.fillRect(0, 0, width, height);
            const markerSizeW = Math.max(1, this.cellWidth * MINIMAP_CELL_MARKER_SCALE); const markerSizeH = Math.max(1, this.cellHeight * MINIMAP_CELL_MARKER_SCALE);
            const markerOffsetX = (this.cellWidth - markerSizeW) / 2; const markerOffsetY = (this.cellHeight - markerSizeH) / 2;
            ctx.fillStyle = this.startColor; ctx.fillRect(this.maze.start.x * this.cellWidth + markerOffsetX, this.maze.start.y * this.cellHeight + markerOffsetY, markerSizeW, markerSizeH);
            ctx.fillStyle = this.endColor; ctx.fillRect(this.maze.end.x * this.cellWidth + markerOffsetX, this.maze.end.y * this.cellHeight + markerOffsetY, markerSizeW, markerSizeH);
            ctx.strokeStyle = this.wallColor; ctx.lineWidth = Math.max(1, Math.min(this.cellWidth, this.cellHeight) * 0.1);
            ctx.beginPath();
            for (let y = 0; y < this.maze.height; y++) {
                for (let x = 0; x < this.maze.width; x++) {
                    const cell = this.maze.grid[y]?.[x]; if (!cell) continue;
                    const cx = x * this.cellWidth; const cy = y * this.cellHeight; const cew = cx + this.cellWidth; const ceh = cy + this.cellHeight;
                    if (cell.walls.right) { ctx.moveTo(cew, cy); ctx.lineTo(cew, ceh); } if (cell.walls.bottom) { ctx.moveTo(cx, ceh); ctx.lineTo(cew, ceh); }
                }
            }
            ctx.moveTo(0, 0); ctx.lineTo(width, 0); ctx.moveTo(0, 0); ctx.lineTo(0, height); ctx.stroke();
        }
    }

    // --- Renderer Class ---
    class Renderer {
         constructor(canvasId, mazeContainerId) {
            this.canvas = document.getElementById(canvasId); this.container = document.getElementById(mazeContainerId);
            if (!this.canvas || !this.container) { throw new Error("Canvas or container element not found!"); }
            this.ctx = this.canvas.getContext('2d', { alpha: false });
            this.maze = null; this.player = null; this.minimap = null;
            this.cellSize = 20; this.viewMode = 'overview'; this.isPrinting = false; this.lastDrawTime = 0;
            this.cameraX = 0; this.cameraY = 0; this.targetCameraX = 0; this.targetCameraY = 0;
            this.wallCanvas = document.createElement('canvas'); this.wallCtx = this.wallCanvas.getContext('2d', { alpha: true });
            this.needsWallRedraw = true;
            this.wallColor = '#000'; this.bgColor = '#fff'; this.startColor = '#afa'; this.endColor = '#aaf';
            this.wallGlow = 'transparent'; this.wallShadow = 'transparent'; this.playerGlow = 'transparent'; this.playerShadow = 'transparent';
            this.exitMarker = 'üèÅ'; this.wallThicknessFactor = 0.1; this.playerSizeFactor = 0.6; this.endMarkerSizeFactor = 0.7;
            this.resizeTimeout = null;
            window.addEventListener('resize', () => { clearTimeout(this.resizeTimeout); this.resizeTimeout = setTimeout(() => this.handleResize(), 150); });
            this.updateStyleSettings(true);
         }
         setMaze(maze) { this.maze = maze; this.needsWallRedraw = true; this.handleResize(); this.resetCamera(); if (this.minimap) this.minimap.updateSource(maze, this.player); console.log(`Renderer: Maze set (${maze.width}x${maze.height})`); }
         setPlayer(player) { this.player = player; this.resetCamera(); if (this.minimap) this.minimap.updateSource(this.maze, player); console.log("Renderer: Player set"); }
         setMinimap(minimap) { this.minimap = minimap; }
         updateStyleSettings(forceUpdate = false) {
             const newWallColor = getCssVariable('--wall-color'); const newBgColor = getCssVariable('--maze-bg');
             const newStartColor = getCssVariable('--start-color'); const newEndColor = getCssVariable('--end-color');
             const newWallGlow = getCssVariable('--wall-glow'); const newWallShadow = getCssVariable('--wall-shadow');
             const newPlayerGlow = getCssVariable('--player-glow'); const newPlayerShadow = getCssVariable('--player-shadow');
             const newWallThickness = parseFloat(getCssVariable('--wall-thickness-factor'));
             const newPlayerSize = parseFloat(getCssVariable('--player-size-factor'));
             const newEndMarkerSize = parseFloat(getCssVariable('--end-marker-size-factor'));
             let changed = forceUpdate;
             if (this.wallColor !== newWallColor) { this.wallColor = newWallColor; changed = true; } if (this.bgColor !== newBgColor) { this.bgColor = newBgColor; changed = true; }
             if (this.startColor !== newStartColor) { this.startColor = newStartColor; changed = true; } if (this.endColor !== newEndColor) { this.endColor = newEndColor; changed = true; }
             if (this.wallGlow !== newWallGlow) { this.wallGlow = newWallGlow; changed = true; } if (this.wallShadow !== newWallShadow) { this.wallShadow = newWallShadow; changed = true; }
             if (this.playerGlow !== newPlayerGlow) { this.playerGlow = newPlayerGlow; changed = true; } if (this.playerShadow !== newPlayerShadow) { this.playerShadow = newPlayerShadow; changed = true; }
             if (this.wallThicknessFactor !== newWallThickness) { this.wallThicknessFactor = newWallThickness; changed = true; } if (this.playerSizeFactor !== newPlayerSize) { this.playerSizeFactor = newPlayerSize; changed = true; }
             if (this.endMarkerSizeFactor !== newEndMarkerSize) { this.endMarkerSizeFactor = newEndMarkerSize; changed = true; }
             if (changed) { console.log("Renderer: Styles updated."); this.needsWallRedraw = true; if (this.minimap) this.minimap.updateColors(); return true; } return false;
         }
         setExitMarker(marker) { if (this.exitMarker !== marker) { this.exitMarker = marker; this.needsWallRedraw = true; console.log(`Renderer: Exit marker set to ${marker}`); } }
         setViewMode(mode) {
             if (this.viewMode !== mode) {
                 console.log(`Renderer: Switching view mode to: ${mode}`); this.viewMode = mode; this.handleResize();
                 if (this.minimap) { if (mode === 'playerCamera') this.minimap.show(); else this.minimap.hide(); }
                 const viewBtn = document.getElementById('viewModeBtn');
                 if (viewBtn) { viewBtn.title = mode === 'overview' ? 'Cambiar Vista (Actual: General)' : 'Cambiar Vista (Actual: Jugador)'; viewBtn.dataset.mode = mode; viewBtn.classList.toggle('active', mode === 'playerCamera'); }
                 this.needsWallRedraw = true; this.drawFrame();
             }
         }
         resetCamera() {
             if (!this.maze || !this.player) return; const currentCellSize = this.viewMode === 'playerCamera' ? BASE_CELL_SIZE_PLAYER_VIEW : this.cellSize;
             this.targetCameraX = (this.player.x + 0.5) * currentCellSize; this.targetCameraY = (this.player.y + 0.5) * currentCellSize;
             this.cameraX = this.targetCameraX; this.cameraY = this.targetCameraY; console.log(`Renderer: Camera reset to world (${this.cameraX.toFixed(1)}, ${this.cameraY.toFixed(1)})`);
         }
         handleResize() {
             if (!this.container) return; const containerWidth = this.container.clientWidth; const containerHeight = this.container.clientHeight;
             if (containerWidth <= 0 || containerHeight <= 0) return; console.log(`Renderer: Resize. Mode: ${this.viewMode}, Container: ${containerWidth}x${containerHeight}`);
             if (this.viewMode === 'overview') {
                 if (!this.maze) return; const cellW = containerWidth / this.maze.width; const cellH = containerHeight / this.maze.height; this.cellSize = Math.max(1, Math.floor(Math.min(cellW, cellH)));
                 const totalMazeWidth = this.maze.width * this.cellSize; const totalMazeHeight = this.maze.height * this.cellSize;
                 this.canvas.width = totalMazeWidth; this.canvas.height = totalMazeHeight; this.canvas.style.width = `${totalMazeWidth}px`; this.canvas.style.height = `${totalMazeHeight}px`;
                 this.canvas.style.left = `${Math.round((containerWidth - totalMazeWidth) / 2)}px`; this.canvas.style.top = `${Math.round((containerHeight - totalMazeHeight) / 2)}px`;
                 this.canvas.style.position = 'absolute'; console.log(`Renderer: Overview resize - cellSize=${this.cellSize.toFixed(2)}, canvas=${this.canvas.width}x${this.canvas.height}`); this.needsWallRedraw = true;
             } else { /* playerCamera */
                 this.cellSize = BASE_CELL_SIZE_PLAYER_VIEW; this.canvas.width = containerWidth; this.canvas.height = containerHeight;
                 this.canvas.style.width = `${containerWidth}px`; this.canvas.style.height = `${containerHeight}px`; this.canvas.style.left = '0px'; this.canvas.style.top = '0px'; this.canvas.style.position = 'absolute';
                 console.log(`Renderer: PlayerCamera resize - cellSize=${this.cellSize}, canvas=${this.canvas.width}x${this.canvas.height}`); this.resetCamera();
             }
             if(this.minimap) { this.minimap.calculateDimensions(); this.minimap.needsRedraw = true; } this.drawFrame();
         }
         updateCamera(deltaTime) {
            if (this.viewMode !== 'playerCamera' || !this.player || !this.maze) return;
            this.targetCameraX = (this.player.pixelX + 0.5) * this.cellSize; this.targetCameraY = (this.player.pixelY + 0.5) * this.cellSize;
            const smoothingFactor = clamp(CAMERA_SMOOTHING * (deltaTime / (1000/60)), 0.01, 0.9);
            this.cameraX = lerp(this.cameraX, this.targetCameraX, smoothingFactor); this.cameraY = lerp(this.cameraY, this.targetCameraY, smoothingFactor);
         }
         drawFrame(timestamp = 0) {
            if (!this.maze || !this.player || !this.maze.generationComplete || this.isPrinting) return;
            const stylesPossiblyChanged = this.updateStyleSettings();
            const deltaTime = timestamp > 0 && this.lastDrawTime > 0 ? timestamp - this.lastDrawTime : 16.67;
            if (this.player.isMoving) this.player.update(deltaTime);
            if (this.viewMode === 'playerCamera') this.updateCamera(deltaTime);
            this.lastDrawTime = timestamp; const ctx = this.ctx; const canvasW = this.canvas.width; const canvasH = this.canvas.height;
            ctx.fillStyle = this.bgColor; ctx.fillRect(0, 0, canvasW, canvasH);
            if (this.viewMode === 'overview') {
                if (this.needsWallRedraw || stylesPossiblyChanged) { this.drawMazeStaticToOffscreen(); this.needsWallRedraw = false; console.log("Renderer: Redrawing overview offscreen"); }
                if (this.wallCanvas.width > 0 && this.wallCanvas.height > 0) ctx.drawImage(this.wallCanvas, 0, 0);
                if (this.cellSize >= 1) this.drawPlayer(ctx, this.player.pixelX * this.cellSize, this.player.pixelY * this.cellSize, 0, 0);
            } else { /* playerCamera */
                const camX = this.cameraX; const camY = this.cameraY; const halfW = canvasW / 2; const halfH = canvasH / 2;
                const currentCellSize = this.cellSize; const offsetX = -camX + halfW; const offsetY = -camY + halfH;
                const minVisibleX = Math.max(0, Math.floor((camX - halfW) / currentCellSize) - 1); const maxVisibleX = Math.min(this.maze.width, Math.ceil((camX + halfW) / currentCellSize) + 1);
                const minVisibleY = Math.max(0, Math.floor((camY - halfH) / currentCellSize) - 1); const maxVisibleY = Math.min(this.maze.height, Math.ceil((camY + halfH) / currentCellSize) + 1);
                ctx.fillStyle = this.startColor; const startDrawX = this.maze.start.x * currentCellSize + offsetX; const startDrawY = this.maze.start.y * currentCellSize + offsetY;
                if (this.maze.start.x >= minVisibleX && this.maze.start.x < maxVisibleX && this.maze.start.y >= minVisibleY && this.maze.start.y < maxVisibleY) ctx.fillRect(startDrawX, startDrawY, currentCellSize, currentCellSize);
                ctx.fillStyle = this.endColor; const endDrawX = this.maze.end.x * currentCellSize + offsetX; const endDrawY = this.maze.end.y * currentCellSize + offsetY;
                if (this.maze.end.x >= minVisibleX && this.maze.end.x < maxVisibleX && this.maze.end.y >= minVisibleY && this.maze.end.y < maxVisibleY) ctx.fillRect(endDrawX, endDrawY, currentCellSize, currentCellSize);
                ctx.strokeStyle = this.wallColor; ctx.lineWidth = Math.max(1, currentCellSize * this.wallThicknessFactor); ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                const canShowEffects = currentCellSize > EFFECTS_MIN_CELL_SIZE; let shadowApplied = false;
                if (canShowEffects) {
                    if (this.wallGlow && this.wallGlow !== 'transparent' && this.wallGlow !== 'none') { ctx.shadowColor = this.wallGlow; ctx.shadowBlur = Math.max(3, currentCellSize * 0.15); ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; shadowApplied = true; }
                    else if (this.wallShadow && this.wallShadow !== 'transparent' && this.wallShadow !== 'none') { ctx.shadowColor = this.wallShadow; ctx.shadowBlur = Math.max(2, currentCellSize * 0.05); ctx.shadowOffsetX = Math.max(1, currentCellSize * 0.02); ctx.shadowOffsetY = Math.max(1, currentCellSize * 0.02); shadowApplied = true; }
                }
                ctx.beginPath();
                for (let y = minVisibleY; y < maxVisibleY; y++) {
                    for (let x = minVisibleX; x < maxVisibleX; x++) {
                        const cell = this.maze.grid[y]?.[x]; if (!cell) continue;
                        const drawX = Math.round(x * currentCellSize + offsetX); const drawY = Math.round(y * currentCellSize + offsetY);
                        if (drawX + currentCellSize < -ctx.lineWidth || drawX > canvasW + ctx.lineWidth || drawY + currentCellSize < -ctx.lineWidth || drawY > canvasH + ctx.lineWidth) continue;
                        const drawX_right = Math.round(drawX + currentCellSize); const drawY_bottom = Math.round(drawY + currentCellSize);
                        if (cell.walls.top) { ctx.moveTo(drawX, drawY); ctx.lineTo(drawX_right, drawY); } if (cell.walls.right) { ctx.moveTo(drawX_right, drawY); ctx.lineTo(drawX_right, drawY_bottom); }
                        if (cell.walls.bottom) { ctx.moveTo(drawX_right, drawY_bottom); ctx.lineTo(drawX, drawY_bottom); } if (cell.walls.left) { ctx.moveTo(drawX, drawY_bottom); ctx.lineTo(drawX, drawY); }
                    }
                }
                ctx.stroke(); if (shadowApplied) { ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; }
                if (this.exitMarker && currentCellSize > 10 && this.maze.end.x >= minVisibleX && this.maze.end.x < maxVisibleX && this.maze.end.y >= minVisibleY && this.maze.end.y < maxVisibleY) {
                    const markerSize = currentCellSize * this.endMarkerSizeFactor; const markerX = endDrawX + currentCellSize / 2; const markerY = endDrawY + currentCellSize / 2 + markerSize * 0.1;
                    ctx.font = `${markerSize * 0.8}px ${getCssVariable('--font-family')}`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = this.wallColor; ctx.fillText(this.exitMarker, markerX, markerY);
                }
                const playerWorldX = this.player.pixelX * currentCellSize; const playerWorldY = this.player.pixelY * currentCellSize;
                this.drawPlayer(ctx, playerWorldX, playerWorldY, offsetX, offsetY);
                if (this.minimap) this.minimap.draw();
            }
         }
         drawPlayer(ctx, worldX, worldY, offsetX, offsetY) {
             const currentCellSize = this.cellSize; const centerX = worldX + offsetX + currentCellSize / 2; const centerY = worldY + offsetY + currentCellSize / 2;
             const playerRadius = Math.max(1, (currentCellSize * this.playerSizeFactor) / 2);
             if (!this.player || !this.player.color) return; ctx.fillStyle = this.player.color;
             const canShowEffects = currentCellSize > EFFECTS_MIN_CELL_SIZE; let shadowApplied = false;
             if (canShowEffects && this.playerGlow && this.playerGlow !== 'transparent' && this.playerGlow !== 'none') { ctx.shadowColor = this.playerGlow; ctx.shadowBlur = Math.max(5, currentCellSize * 0.25); ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; ctx.beginPath(); ctx.arc(centerX, centerY, playerRadius, 0, Math.PI * 2); ctx.fill(); shadowApplied = true; }
             if (shadowApplied) { ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; shadowApplied = false; }
             ctx.beginPath(); ctx.arc(centerX, centerY, playerRadius, 0, Math.PI * 2); ctx.fill();
             if (canShowEffects && this.playerShadow && this.playerShadow !== 'transparent' && this.playerShadow !== 'none') { ctx.shadowColor = this.playerShadow; ctx.shadowBlur = Math.max(3, currentCellSize * 0.1); ctx.shadowOffsetX = Math.max(1, currentCellSize * 0.03); ctx.shadowOffsetY = Math.max(1, currentCellSize * 0.03); ctx.fill(); shadowApplied = true; }
             if (shadowApplied) { ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; }
         }
         drawMazeStaticToOffscreen() {
            if (this.viewMode === 'playerCamera' && !this.isPrinting) { console.warn("drawMazeStaticToOffscreen called unexpectedly in playerCamera mode (non-print)"); return; }
            if (!this.maze || this.maze.width <= 0 || this.maze.height <= 0) { console.warn("drawMazeStaticToOffscreen skipped: no valid maze."); if (this.wallCanvas.width > 0) this.wallCtx.clearRect(0, 0, this.wallCanvas.width, this.wallCanvas.height); return; }
            const currentCellSize = this.cellSize; if (currentCellSize <= 0) { console.warn(`drawMazeStaticToOffscreen skipped: invalid cellSize ${currentCellSize}`); return; }
            const canvasW = Math.ceil(this.maze.width * currentCellSize); const canvasH = Math.ceil(this.maze.height * currentCellSize);
            if (canvasW <= 0 || canvasH <= 0) { console.warn(`drawMazeStaticToOffscreen skipped: invalid calculated canvas size ${canvasW}x${canvasH}`); return; }
            if (this.wallCanvas.width !== canvasW || this.wallCanvas.height !== canvasH) { this.wallCanvas.width = canvasW; this.wallCanvas.height = canvasH; console.log(`Renderer: Resized offscreen wallCanvas to ${canvasW}x${canvasH}`); }
            const ctx = this.wallCtx; ctx.clearRect(0, 0, this.wallCanvas.width, this.wallCanvas.height);
            ctx.fillStyle = this.startColor; ctx.fillRect(this.maze.start.x * currentCellSize, this.maze.start.y * currentCellSize, currentCellSize, currentCellSize);
            ctx.fillStyle = this.endColor; ctx.fillRect(this.maze.end.x * currentCellSize, this.maze.end.y * currentCellSize, currentCellSize, currentCellSize);
            ctx.strokeStyle = this.wallColor; ctx.lineWidth = Math.max(1, currentCellSize * this.wallThicknessFactor); ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            const canShowEffects = currentCellSize > EFFECTS_MIN_CELL_SIZE; let shadowApplied = false;
            if (canShowEffects) {
                if (this.wallGlow && this.wallGlow !== 'transparent' && this.wallGlow !== 'none') { ctx.shadowColor = this.wallGlow; ctx.shadowBlur = Math.max(3, currentCellSize * 0.15); ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; shadowApplied = true; }
                else if (this.wallShadow && this.wallShadow !== 'transparent' && this.wallShadow !== 'none') { ctx.shadowColor = this.wallShadow; ctx.shadowBlur = Math.max(2, currentCellSize * 0.05); ctx.shadowOffsetX = Math.max(1, currentCellSize * 0.02); ctx.shadowOffsetY = Math.max(1, currentCellSize * 0.02); shadowApplied = true; }
            }
            ctx.beginPath();
            for (let y = 0; y < this.maze.height; y++) {
                for (let x = 0; x < this.maze.width; x++) {
                    const cell = this.maze.grid[y]?.[x]; if (!cell) continue;
                    const cx = x * currentCellSize; const cy = y * currentCellSize; const cew = cx + currentCellSize; const ceh = cy + currentCellSize;
                    if (cell.walls.top) { ctx.moveTo(cx, cy); ctx.lineTo(cew, cy); } if (cell.walls.right) { ctx.moveTo(cew, cy); ctx.lineTo(cew, ceh); }
                    if (cell.walls.bottom) { ctx.moveTo(cew, ceh); ctx.lineTo(cx, ceh); } if (cell.walls.left) { ctx.moveTo(cx, ceh); ctx.lineTo(cx, cy); }
                }
            }
            ctx.stroke(); if (shadowApplied) { ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; }
            if (this.exitMarker && currentCellSize > 10) {
                const markerSize = currentCellSize * this.endMarkerSizeFactor; const markerX = this.maze.end.x * currentCellSize + currentCellSize / 2; const markerY = this.maze.end.y * currentCellSize + currentCellSize / 2 + markerSize * 0.1;
                ctx.font = `${markerSize * 0.8}px ${getCssVariable('--font-family')}`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = this.wallColor; ctx.fillText(this.exitMarker, markerX, markerY);
            }
         }
         prepareForPrint() {
            if (!this.maze || !this.player || !this.maze.generationComplete) return null;
            console.log("Renderer: Preparing for print..."); this.isPrinting = true;
            const savedState = { currentViewMode: this.viewMode, currentDarkMode: document.body.classList.contains('dark-mode'), oldCanvasWidth: this.canvas.width, oldCanvasHeight: this.canvas.height, oldElementWidth: this.canvas.style.width, oldElementHeight: this.canvas.style.height, oldElementLeft: this.canvas.style.left, oldElementTop: this.canvas.style.top, oldCellSize: this.cellSize, originalWallColor: this.wallColor, originalBgColor: this.bgColor, originalStartColor: this.startColor, originalEndColor: this.endColor, originalPlayerColor: this.player.color, originalWallGlow: this.wallGlow, originalWallShadow: this.wallShadow, originalPlayerGlow: this.playerGlow, originalPlayerShadow: this.playerShadow, originalWallThickness: this.wallThicknessFactor, originalPlayerSize: this.playerSizeFactor, originalEndMarkerSize: this.endMarkerSizeFactor, originalExitMarker: this.exitMarker };
            if (savedState.currentDarkMode) document.body.classList.remove('dark-mode'); this.viewMode = 'overview';
            const PRINT_RESOLUTION_BASE = 2400; const aspect = this.maze.width / this.maze.height; let printCellSize; if (aspect >= 1) { printCellSize = Math.max(1, Math.floor(PRINT_RESOLUTION_BASE / this.maze.width)); } else { printCellSize = Math.max(1, Math.floor(PRINT_RESOLUTION_BASE / this.maze.height)); }
            printCellSize = Math.max(printCellSize, 1); const printCanvasWidth = this.maze.width * printCellSize; const printCanvasHeight = this.maze.height * printCellSize;
            this.cellSize = printCellSize; this.wallColor = '#000000'; this.bgColor = '#ffffff'; this.startColor = '#e0e0e0'; this.endColor = '#cccccc';
            this.wallGlow = 'transparent'; this.wallShadow = 'transparent'; this.playerGlow = 'transparent'; this.playerShadow = 'transparent'; const printPlayerColor = '#aaaaaa';
            this.wallThicknessFactor = 0.1; this.playerSizeFactor = 0.6; this.endMarkerSizeFactor = 0.7; this.exitMarker = savedState.originalExitMarker;
            this.canvas.style.width = `${printCanvasWidth}px`; this.canvas.style.height = `${printCanvasHeight}px`; this.canvas.style.left = '0px'; this.canvas.style.top = '0px'; this.canvas.width = printCanvasWidth; this.canvas.height = printCanvasHeight;
            this.needsWallRedraw = true; this.drawMazeStaticToOffscreen();
            const ctx = this.ctx; ctx.fillStyle = this.bgColor; ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); ctx.drawImage(this.wallCanvas, 0, 0);
            if (this.cellSize >= 1) { const playerDrawX = this.player.x * this.cellSize; const playerDrawY = this.player.y * this.cellSize; const originalDrawColor = this.player.color; this.player.color = printPlayerColor; this.drawPlayer(ctx, playerDrawX, playerDrawY, 0, 0); this.player.color = originalDrawColor; }
            console.log(`Renderer: Prepared print canvas ${printCanvasWidth}x${printCanvasHeight}, cellSize=${printCellSize}`); return savedState;
         }
         restoreAfterPrint(savedState) {
             if (!savedState) return; console.log("Renderer: Restoring after print...");
             this.wallColor = savedState.originalWallColor; this.bgColor = savedState.originalBgColor; this.startColor = savedState.originalStartColor; this.endColor = savedState.originalEndColor;
             this.wallGlow = savedState.originalWallGlow; this.wallShadow = savedState.originalWallShadow; this.playerGlow = savedState.originalPlayerGlow; this.playerShadow = savedState.originalPlayerShadow;
             this.wallThicknessFactor = savedState.originalWallThickness; this.playerSizeFactor = savedState.originalPlayerSize; this.endMarkerSizeFactor = savedState.originalEndMarkerSize; this.exitMarker = savedState.originalExitMarker;
             if (this.player) this.player.color = savedState.originalPlayerColor;
             this.canvas.width = savedState.oldCanvasWidth; this.canvas.height = savedState.oldCanvasHeight; this.canvas.style.width = savedState.oldElementWidth; this.canvas.style.height = savedState.oldElementHeight;
             this.canvas.style.left = savedState.oldElementLeft; this.canvas.style.top = savedState.oldElementTop; this.cellSize = savedState.oldCellSize;
             if (savedState.currentDarkMode) document.body.classList.add('dark-mode');
             if (this.minimap) this.minimap.updateColors(); this.isPrinting = false; this.setViewMode(savedState.currentViewMode); this.needsWallRedraw = true;
             requestAnimationFrame(() => this.drawFrame()); console.log("Renderer: Restored state after printing.");
         }
    }

    // --- Game Controller Logic ---
    class Game {
        constructor() {
             this.mazeGenerator = new MazeGenerator();
             this.renderer = new Renderer('mazeCanvas', 'maze-container');
             this.minimap = new Minimap('minimapCanvas', 'minimapContainer');
             this.renderer.setMinimap(this.minimap);
             this.player = null;
             this.gameActive = false;
             this.lastTimestamp = 0;
             this.animationFrameId = null;
             this.isLoading = false;
             // Timer state
             this.gameStartTime = 0; this.gameTimer = null; this.currentTime = 0; this.timerStarted = false;
             // Best times storage
             this.bestTimes = JSON.parse(localStorage.getItem('mazeBestTimes') || '{}');
             // Touch state
             this.touchStartX = 0; this.touchStartY = 0; this.touchEndX = 0; this.touchEndY = 0;
             // UI Element Refs
             this.widthInput = document.getElementById('modal-width');
             this.heightInput = document.getElementById('modal-height');
             this.darkModeToggle = document.getElementById('modal-darkModeToggle');
             this.mazeStyleGroup = document.getElementById('modal-mazeStyle');
             this.playerChoiceGroup = document.getElementById('modal-playerChoice');
             this.exitChoiceGroup = document.getElementById('modal-exitChoice');
             this.viewModeBtn = document.getElementById('viewModeBtn');
             // Scores Modal Refs
             this.scoresModal = document.getElementById('scores-modal');
             this.scoresModalBackdrop = document.getElementById('scores-modal-backdrop');
             this.scoresListContainer = document.getElementById('scores-list-container');
             this.noScoresMessage = this.scoresModal.querySelector('.no-scores-message');
             this.clearScoresBtn = document.getElementById('clearScoresBtn');

             // --- NUEVO: Estad√≠sticas Persistentes ---
             this.statsKey = 'mazeGameStats_v1'; // Cambiar versi√≥n si la estructura cambia
             this.gameStats = {}; // Se inicializar√° en loadStats
             // --------------------------------------

             // Initial setup
             this.loadStats(); // Cargar estad√≠sticas ANTES de bindUI o applyInitialSettings
             this.bindUI();
             this.applyInitialSettings();
             // Delay first game start slightly
             requestAnimationFrame(() => {
                 this.startNewGame('initial_load');
             });
        }

        // --- NUEVO: M√©todos para Estad√≠sticas ---
        loadStats() {
            try {
                const storedStats = localStorage.getItem(this.statsKey);
                if (storedStats) {
                    this.gameStats = JSON.parse(storedStats);
                    // Asegurar que todas las claves esperadas existan (compatibilidad)
                    this.gameStats.total_played = this.gameStats.total_played || 0;
                    this.gameStats.total_completed = this.gameStats.total_completed || 0;
                    this.gameStats.completions_by_resolution = this.gameStats.completions_by_resolution || {};
                    this.gameStats.completions_by_style = this.gameStats.completions_by_style || {};
                    this.gameStats.completions_by_player_color = this.gameStats.completions_by_player_color || {};
                    this.gameStats.completions_by_exit_marker = this.gameStats.completions_by_exit_marker || {};
                    this.gameStats.view_mode_switches = this.gameStats.view_mode_switches || 0;
                    console.log("Game stats loaded:", this.gameStats);
                } else {
                    this.resetStatsObject(); // Inicializar si no hay nada guardado
                    console.log("No game stats found, initialized new object.");
                }
            } catch (e) {
                console.error("Error loading game stats from localStorage:", e);
                 trackEvent('exception', {
                      'description': `Error loading localStorage stats: ${e.message}`,
                      'fatal': false // No es fatal para el juego en s√≠
                    });
                this.resetStatsObject(); // Resetear en caso de error
            }
        }

        saveStats() {
            try {
                localStorage.setItem(this.statsKey, JSON.stringify(this.gameStats));
                // console.log("Game stats saved."); // Descomentar para depuraci√≥n
            } catch (e) {
                console.error("Error saving game stats to localStorage:", e);
                 trackEvent('exception', {
                      'description': `Error saving localStorage stats: ${e.message}`,
                      'fatal': false
                    });
            }
        }

        resetStatsObject() {
             this.gameStats = {
                total_played: 0,
                total_completed: 0,
                completions_by_resolution: {}, // key: "WxH", value: count
                completions_by_style: {},      // key: "styleName", value: count
                completions_by_player_color: {},// key: "baseColorHex", value: count
                completions_by_exit_marker: {}, // key: "markerChar", value: count
                view_mode_switches: 0
            };
        }

        /** Incrementa un contador de nivel superior en gameStats */
        incrementStat(statName) {
            if (typeof this.gameStats[statName] === 'number') {
                this.gameStats[statName]++;
            } else {
                this.gameStats[statName] = 1; // Inicializa si no existe
                console.warn(`Stat '${statName}' was not a number, initialized to 1.`);
            }
            // Nota: saveStats() se llama despu√©s de un grupo de incrementos
        }

        /** Incrementa un contador dentro de un objeto anidado en gameStats */
        incrementNestedStat(parentStatName, key) {
            if (!this.gameStats[parentStatName]) {
                this.gameStats[parentStatName] = {}; // Inicializa el objeto padre si no existe
            }
            const parentObj = this.gameStats[parentStatName];
            if (typeof parentObj[key] === 'number') {
                parentObj[key]++;
            } else {
                parentObj[key] = 1; // Inicializa la clave espec√≠fica si no existe
            }
            // Nota: saveStats() se llama despu√©s de un grupo de incrementos
        }
        // --- Fin M√©todos Estad√≠sticas ---

         bindUI() {
             // Bottom Nav
             document.getElementById('newGameBtn').addEventListener('click', () => this.startNewGame('new_game_button'));
             this.viewModeBtn.addEventListener('click', () => this.toggleViewMode());
             document.getElementById('scoresBtn').addEventListener('click', () => this.openScoresModal());
             document.getElementById('settingsBtn').addEventListener('click', () => this.openSettingsModal());

             // Settings Modal
             document.getElementById('closeSettingsBtn').addEventListener('click', () => this.closeSettingsModal());
             document.getElementById('settings-modal-backdrop').addEventListener('click', () => this.closeSettingsModal());
             this.widthInput.addEventListener('input', () => this.validateDimensionsAndUpdateBestTime());
             this.widthInput.addEventListener('change', (e) => { // Track final value on change
                const input = e.target;
                const newValue = clamp(parseInt(input.value || MIN_MAZE_DIMENSION, 10), MIN_MAZE_DIMENSION, parseInt(input.max));
                input.value = newValue; // Ensure value is clamped in UI
                trackEvent('change_setting', { 'setting_name': 'width', 'setting_value': newValue });
             });
             this.heightInput.addEventListener('input', () => this.validateDimensionsAndUpdateBestTime());
             this.heightInput.addEventListener('change', (e) => { // Track final value on change
                const input = e.target;
                const newValue = clamp(parseInt(input.value || MIN_MAZE_DIMENSION, 10), MIN_MAZE_DIMENSION, parseInt(input.max));
                input.value = newValue; // Ensure value is clamped in UI
                trackEvent('change_setting', { 'setting_name': 'height', 'setting_value': newValue });
             });
             document.getElementById('modal-generateBtn').addEventListener('click', () => {
                 this.closeSettingsModal();
                 setTimeout(() => this.startNewGame('settings_modal'), 50); // Small delay after closing modal
             });
             this.darkModeToggle.addEventListener('change', (e) => {
                 const isDark = e.target.checked;
                 trackEvent('change_setting', { 'setting_name': 'darkMode', 'setting_value': isDark }); // Send boolean directly
                 this.setDarkMode(isDark);
             });
             this.mazeStyleGroup.addEventListener('change', (e) => {
                 if (e.target.checked) {
                     const newStyle = e.target.value;
                     trackEvent('change_setting', { 'setting_name': 'mazeStyle', 'setting_value': newStyle });
                     this.setMazeStyle(newStyle);
                 }
             });
             this.playerChoiceGroup.addEventListener('change', (e) => {
                 if (e.target.checked) {
                     const colorBase = e.target.value; // Track the base color value
                     const actualColor = this.calculatePlayerColor(e.target);
                     trackEvent('change_setting', { 'setting_name': 'playerColor', 'setting_value': colorBase, 'actual_rendered_color': actualColor });
                     this.updatePlayerColor(e.target);
                 }
             });
             this.exitChoiceGroup.addEventListener('change', (e) => {
                 if (e.target.checked) {
                     const newMarker = e.target.value;
                     trackEvent('change_setting', { 'setting_name': 'exitMarker', 'setting_value': newMarker });
                     this.renderer.setExitMarker(newMarker);
                     if (this.gameActive || this.renderer.maze) this.renderer.drawFrame();
                 }
             });
             document.getElementById('modal-printBtn').addEventListener('click', () => this.handlePrint());

             // Scores Modal
             document.getElementById('closeScoresBtn').addEventListener('click', () => this.closeScoresModal());
             this.scoresModalBackdrop.addEventListener('click', () => this.closeScoresModal());
             this.clearScoresBtn.addEventListener('click', () => this.confirmClearScores());

             // Message Overlay
             document.getElementById('playAgainBtn').addEventListener('click', () => {
                 this.hideMessage();
                 this.startNewGame('play_again_button');
             });

             // Input Handlers
             document.addEventListener('keydown', (e) => this.handleKeyDown(e));
             const mazeContainer = document.getElementById('maze-container');
             mazeContainer.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
             mazeContainer.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
             mazeContainer.addEventListener('touchend', (e) => this.handleTouchEnd(e));
             mazeContainer.addEventListener('touchcancel', (e) => this.handleTouchEnd(e)); // Handle cancellation too
        }

         toggleViewMode() {
             const currentMode = this.renderer.viewMode;
             const nextMode = currentMode === 'overview' ? 'playerCamera' : 'overview';

             // --- Actualizar Stat Local y Guardar ---
             this.incrementStat('view_mode_switches');
             this.saveStats(); // Guardar despu√©s de actualizar la estad√≠stica
             // -----------------------------------

             // --- Track Event en GA ---
             trackEvent('change_view_mode', {
                 'previous_view_mode': currentMode, // Podr√≠a ser √∫til saber desde d√≥nde cambi√≥
                 'new_view_mode': nextMode,
                 'switch_count': this.gameStats.view_mode_switches // Enviar el conteo actualizado
             });
             // --------------------
             this.renderer.setViewMode(nextMode);
         }

         openSettingsModal() {
             trackEvent('modal_interaction', {'modal_type': 'settings', 'interaction': 'open'});
             this.syncModalControls(); // Asegura que el modal muestre los valores actuales
             document.getElementById('settings-modal-backdrop').classList.add('visible');
             document.getElementById('settings-modal').classList.add('visible');
             document.getElementById('settingsBtn').classList.add('active'); // Marcar bot√≥n activo
             document.getElementById('scoresBtn').classList.remove('active'); // Desmarcar otros
             if (this.scoresModal.classList.contains('visible')) this.closeScoresModal(); // Cerrar scores si estaba abierto
         }

         closeSettingsModal() {
             // Solo trackear si estaba visible para evitar eventos dobles si se cierra program√°ticamente
             if (document.getElementById('settings-modal').classList.contains('visible')) {
                 trackEvent('modal_interaction', {'modal_type': 'settings', 'interaction': 'close'});
             }
             document.getElementById('settings-modal-backdrop').classList.remove('visible');
             document.getElementById('settings-modal').classList.remove('visible');
             document.getElementById('settingsBtn').classList.remove('active');
         }

         openScoresModal() {
             trackEvent('modal_interaction', {'modal_type': 'scores', 'interaction': 'open'});
             this.populateScoresModalContent(); // Cargar contenido actualizado
             this.scoresModalBackdrop.classList.add('visible');
             this.scoresModal.classList.add('visible');
             document.getElementById('scoresBtn').classList.add('active'); // Marcar bot√≥n activo
             document.getElementById('settingsBtn').classList.remove('active'); // Desmarcar otros
             if (document.getElementById('settings-modal').classList.contains('visible')) this.closeSettingsModal(); // Cerrar settings si estaba abierto
         }

         closeScoresModal() {
             if (this.scoresModal.classList.contains('visible')) {
                 trackEvent('modal_interaction', {'modal_type': 'scores', 'interaction': 'close'});
             }
             this.scoresModalBackdrop.classList.remove('visible');
             this.scoresModal.classList.remove('visible');
             document.getElementById('scoresBtn').classList.remove('active');
         }

         sortMazeSizes(sizeA, sizeB) {
             const [wA, hA] = sizeA.split('x').map(Number); const [wB, hB] = sizeB.split('x').map(Number);
             const areaA = wA * hA; const areaB = wB * hB;
             if (areaA !== areaB) return areaA - areaB; // Sort by area first
             if (wA !== wB) return wA - wB; // Then by width
             return hA - hB; // Then by height
         }

         populateScoresModalContent() {
             this.scoresListContainer.innerHTML = ''; // Clear previous entries
             const scoreKeys = Object.keys(this.bestTimes);
             if (scoreKeys.length === 0) {
                 if (!this.noScoresMessage) { // Create message if it doesn't exist
                     this.noScoresMessage = document.createElement('div');
                     this.noScoresMessage.className = 'no-scores-message';
                     this.noScoresMessage.textContent = 'A√∫n no has completado ning√∫n laberinto. ¬°Juega para registrar tus marcas!';
                 }
                 this.noScoresMessage.style.display = 'block'; // Show message
                 this.scoresListContainer.appendChild(this.noScoresMessage);
                 this.clearScoresBtn.disabled = true; // Disable clear button
             } else {
                 if (this.noScoresMessage) this.noScoresMessage.style.display = 'none'; // Hide message
                 this.clearScoresBtn.disabled = false; // Enable clear button
                 // Sort keys for consistent display
                 scoreKeys.sort(this.sortMazeSizes);
                 // Create and append entries
                 scoreKeys.forEach(size => {
                     const time = this.bestTimes[size];
                     if (time === undefined || time === null) return; // Skip if time is invalid
                     const formattedTime = this.formatTime(time);
                     const entryDiv = document.createElement('div'); entryDiv.className = 'score-entry';
                     const sizeSpan = document.createElement('span'); sizeSpan.className = 'score-size'; sizeSpan.textContent = size; sizeSpan.title = size; // Tooltip for small screens
                     const timeSpan = document.createElement('span'); timeSpan.className = 'score-time'; timeSpan.textContent = formattedTime;
                     entryDiv.appendChild(sizeSpan); entryDiv.appendChild(timeSpan);
                     this.scoresListContainer.appendChild(entryDiv);
                 });
             }
         }

         confirmClearScores() {
             if (confirm('¬øEst√°s seguro de que quieres borrar todos tus r√©cords guardados? Esta acci√≥n no se puede deshacer.')) {
                 // --- Track Event ANTES de borrar ---
                 const scoreCount = Object.keys(this.bestTimes).length;
                 trackEvent('clear_all_scores', {
                     'score_count_cleared': scoreCount
                 });
                 // ------------------------------------
                 this.clearAllScores();
             } else {
                  trackEvent('clear_all_scores_cancelled'); // Opcional: trackear si cancela
             }
         }

         clearAllScores() {
             this.bestTimes = {};
             localStorage.removeItem('mazeBestTimes');
             console.log("All best times cleared.");
             this.populateScoresModalContent(); // Actualizar la vista del modal de scores
             // Actualizar el display de 'mejor tiempo' en el modal de ajustes si est√° visible
             const modalWidth = this.widthInput?.value || 0;
             const modalHeight = this.heightInput?.value || 0;
             this.updateBestTimeDisplay(`${modalWidth}x${modalHeight}`, true);
             // Opcional: this.saveStats(); // Si quisieras registrar el acto de borrar en gameStats
         }

         syncModalControls() {
            // Sincroniza dimensiones con el estado actual del generador o el valor del input
            const maxInputDim = parseInt(this.widthInput.max); // Usar el max actual del input
            this.widthInput.value = clamp(this.mazeGenerator?.width || parseInt(this.widthInput.value), MIN_MAZE_DIMENSION, maxInputDim);
            this.heightInput.value = clamp(this.mazeGenerator?.height || parseInt(this.heightInput.value), MIN_MAZE_DIMENSION, maxInputDim);
            // Sincroniza modo oscuro
            this.darkModeToggle.checked = document.body.classList.contains('dark-mode');
            // Sincroniza estilo visual
            const currentStyle = document.body.dataset.mazeStyle || 'classic';
            const styleRadio = document.querySelector(`#modal-mazeStyle input[value="${currentStyle}"]`);
            if (styleRadio) styleRadio.checked = true;
            else document.querySelector('#modal-mazeStyle input[value="classic"]').checked = true; // Fallback
            // Filtra y selecciona color de jugador
            this.filterPlayerChoicesByStyle(currentStyle);
            const currentPlayerBaseColor = this.getCurrentPlayerColor(true); // Obtener color base actual
            const playerRadio = document.querySelector(`#modal-playerChoice input[value="${currentPlayerBaseColor}"]`);
             // Selecciona el radio correcto, asegur√°ndose de que no est√© oculto por el filtro de estilo
            if (playerRadio && !playerRadio.parentElement.hidden) {
                playerRadio.checked = true;
            } else {
                // Fallback: selecciona el primer radio visible gen√©rico o el primero visible espec√≠fico del estilo actual
                const firstVisibleChoice = document.querySelector(`#modal-playerChoice label:not([hidden]) input`);
                if (firstVisibleChoice) firstVisibleChoice.checked = true;
                else { // Absoluto fallback si todo falla
                   const absoluteFallback = document.querySelector('#modal-playerChoice input[name="modal-player"]');
                   if (absoluteFallback) absoluteFallback.checked = true;
                }
            }
            this.updatePlayerColorVisuals(this.darkModeToggle.checked); // Actualizar previews de color
            // Sincroniza marcador de salida
            const currentExit = this.renderer.exitMarker || 'üèÅ';
            const exitRadio = document.querySelector(`#modal-exitChoice input[value="${currentExit}"]`);
            if (exitRadio) exitRadio.checked = true;
            else document.querySelector('#modal-exitChoice input[value="üèÅ"]').checked = true; // Fallback
            // Actualiza display de mejor tiempo para las dimensiones actuales
            this.updateBestTimeDisplay(`${this.widthInput.value}x${this.heightInput.value}`, true);
         }

         applyInitialSettings() {
            // Ajustar max dimension basado en si es m√≥vil (m√°s peque√±o por defecto)
            const isLikelyMobile = window.innerWidth < MOBILE_BREAKPOINT_WIDTH;
            const maxInputDim = isLikelyMobile ? MOBILE_MAX_INPUT_DIMENSION : MAX_MAZE_DIMENSION;
            this.widthInput.max = maxInputDim; this.heightInput.max = maxInputDim;
             // Actualizar etiquetas si existen
             if (this.widthInput.previousElementSibling?.tagName === 'LABEL') { this.widthInput.previousElementSibling.textContent = `Ancho (${MIN_MAZE_DIMENSION}-${maxInputDim}):`; }
             if (this.heightInput.previousElementSibling?.tagName === 'LABEL') { this.heightInput.previousElementSibling.textContent = `Alto (${MIN_MAZE_DIMENSION}-${maxInputDim}):`; }
            // Setear valores iniciales clampados
            this.widthInput.value = clamp(parseInt(this.widthInput.value || 15), MIN_MAZE_DIMENSION, maxInputDim);
            this.heightInput.value = clamp(parseInt(this.heightInput.value || 15), MIN_MAZE_DIMENSION, maxInputDim);
            // Setear modo oscuro basado en preferencia del sistema
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            this.setDarkMode(prefersDark); this.darkModeToggle.checked = prefersDark;
             // Aplicar estilo inicial
            const initialStyle = document.querySelector('#modal-mazeStyle input:checked')?.value || 'classic';
            this.setMazeStyle(initialStyle);
            // Asegurar que un color de jugador est√© seleccionado y visible
             if (!document.querySelector('#modal-playerChoice input:checked') || document.querySelector('#modal-playerChoice input:checked').parentElement.hidden) {
                 const firstVisibleChoice = document.querySelector(`#modal-playerChoice label:not([hidden]) input`);
                 if (firstVisibleChoice) firstVisibleChoice.checked = true;
             }
            this.updatePlayerColor(document.querySelector('#modal-playerChoice input:checked'));
            // Aplicar marcador de salida inicial
            this.renderer.setExitMarker(document.querySelector('#modal-exitChoice input:checked')?.value || 'üèÅ');
             // Actualizar t√≠tulo del bot√≥n de vista
             this.viewModeBtn.title = this.renderer.viewMode === 'overview' ? 'Cambiar Vista (Actual: General)' : 'Cambiar Vista (Actual: Jugador)';
         }

         validateDimensions() {
             const maxDim = parseInt(this.widthInput.max); // Usar el max actual del input
             this.widthInput.value = clamp(parseInt(this.widthInput.value || MIN_MAZE_DIMENSION, 10), MIN_MAZE_DIMENSION, maxDim);
             this.heightInput.value = clamp(parseInt(this.heightInput.value || MIN_MAZE_DIMENSION, 10), MIN_MAZE_DIMENSION, maxDim);
         }

         validateDimensionsAndUpdateBestTime() {
             this.validateDimensions(); // Primero valida y clampa los valores
             // Luego actualiza el display de mejor tiempo con los valores validados
             this.updateBestTimeDisplay(`${this.widthInput.value}x${this.heightInput.value}`, true);
         }

         startTimer() {
             if (this.timerStarted) return;
             this.timerStarted = true; this.gameStartTime = Date.now(); this.currentTime = 0;
             this.updateTimerDisplay(); // Mostrar 00:00 inmediatamente
             clearInterval(this.gameTimer); // Limpiar timer anterior por si acaso
             this.gameTimer = setInterval(() => {
                 this.currentTime = Math.floor((Date.now() - this.gameStartTime) / 1000);
                 this.updateTimerDisplay();
             }, 1000);
             console.log("Timer started");
         }

         resetTimer() {
             clearInterval(this.gameTimer); this.gameTimer = null; this.timerStarted = false; this.currentTime = 0;
             this.updateTimerDisplay(); // Poner a 00:00
             console.log("Timer reset");
         }

         stopTimer() {
             clearInterval(this.gameTimer);
             const finalTime = this.currentTime; // Captura el tiempo antes de resetear
             const mazeSize = `${this.mazeGenerator.width}x${this.mazeGenerator.height}`;
             let isNewBest = false;

             if (!this.bestTimes[mazeSize] || finalTime < this.bestTimes[mazeSize]) {
                 this.bestTimes[mazeSize] = finalTime;
                 localStorage.setItem('mazeBestTimes', JSON.stringify(this.bestTimes));
                 isNewBest = true;

                 // --- Track Nuevo Mejor Tiempo ---
                 trackEvent('new_best_time_set', {
                     'level_name': mazeSize, // e.g., "15x15"
                     'maze_width': this.mazeGenerator.width,
                     'maze_height': this.mazeGenerator.height,
                     'maze_style': document.body.dataset.mazeStyle || 'classic',
                     'time_seconds': finalTime,
                     'value': finalTime // GA standard parameter for value/time
                 });
                 // --------------------------

                 console.log(`New best time for ${mazeSize}: ${finalTime}s`);
                 this.updateBestTimeDisplay(mazeSize, true); // Actualizar display en modal de ajustes
                 if (this.scoresModal.classList.contains('visible')) {
                     this.populateScoresModalContent(); // Actualizar modal de scores si est√° abierto
                 }
             }
             console.log(`Timer stopped. Final time: ${finalTime}s`);
             return { time: finalTime, isNewBest: isNewBest };
         }

         formatTime(totalSeconds) {
             if (totalSeconds === undefined || totalSeconds === null || totalSeconds < 0) return '--:--'; // Manejo de inv√°lidos
             const hours = Math.floor(totalSeconds / 3600);
             const minutes = Math.floor((totalSeconds % 3600) / 60);
             const seconds = totalSeconds % 60;
             // Mostrar horas solo si es necesario
             if (hours > 0) {
                 return `${hours.toString()}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
             } else {
                 return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
             }
         }

         updateTimerDisplay() {
             // Simplificar a MM:SS si es menos de una hora
             const displayTime = this.currentTime >= 3600
                 ? this.formatTime(this.currentTime)
                 : this.formatTime(this.currentTime).split(':').slice(-2).join(':'); // Toma los √∫ltimos dos segmentos (MM:SS)
             document.getElementById('current-time').textContent = displayTime || '00:00';
         }

         updateBestTimeDisplay(mazeSize, targetModal = false) {
             const bestTime = this.bestTimes[mazeSize];
             let timeStr = '--:--';
             if (bestTime !== undefined && bestTime !== null) {
                 timeStr = this.formatTime(bestTime);
             }
             const label = `Record (${mazeSize === '0x0' || !mazeSize ? 'N/A' : mazeSize}): ${timeStr}`;
             // Actualiza el texto en el modal de ajustes
             if (targetModal) {
                 const bestTimeEl = document.getElementById('best-time-modal');
                 if (bestTimeEl) bestTimeEl.textContent = label;
             }
             // Podr√≠as tener otro display si quisieras
         }

        async startNewGame(method = 'unknown') {
            // Cierra modales si est√°n abiertos
            if (document.getElementById('settings-modal').classList.contains('visible')) { this.closeSettingsModal(); await new Promise(resolve => setTimeout(resolve, 50)); }
            if (document.getElementById('scores-modal').classList.contains('visible')) { this.closeScoresModal(); await new Promise(resolve => setTimeout(resolve, 50)); }
            if (this.isLoading) { console.warn("Attempted to start new game while already loading."); return; }

            this.isLoading = true; this.gameActive = false;
            this.stopGameLoop(); this.showLoading(true, 'Generando...');
            this.hideMessage(); this.resetTimer();
            // Deshabilitar controles durante la carga
            document.getElementById('newGameBtn').disabled = true; this.viewModeBtn.disabled = true;
            document.getElementById('settingsBtn').disabled = true; document.getElementById('scoresBtn').disabled = true;

            // --- Incrementar Stat Local y Guardar ---
            this.incrementStat('total_played');
            this.saveStats();
            // ---------------------------------------

            try {
                this.validateDimensions(); // Asegurar que las dimensiones son v√°lidas
                const width = parseInt(this.widthInput.value);
                const height = parseInt(this.heightInput.value);
                const isDark = this.darkModeToggle.checked;
                const currentStyle = document.querySelector('#modal-mazeStyle input:checked')?.value || 'classic';
                const playerColorBase = this.getCurrentPlayerColor(true); // Obtener valor base para tracking
                const initialExitMarker = document.querySelector('#modal-exitChoice input:checked')?.value || 'üèÅ';
                const genStartTime = performance.now();

                // Aplicar apariencia seleccionada
                this.setDarkMode(isDark); // Asegurar consistencia
                this.setMazeStyle(currentStyle, true); // Forzar actualizaci√≥n de estilo
                this.renderer.setExitMarker(initialExitMarker); // Setear marcador

                // Generar el laberinto (as√≠ncrono)
                const maze = await this.mazeGenerator.generate(width, height, (progress) => {
                    this.showLoading(true, `Generando... ${Math.round(progress * 100)}%`); // Actualizar progreso
                });
                const genEndTime = performance.now();
                const genDuration = Math.round(genEndTime - genStartTime); // Duraci√≥n en ms

                if (!maze || !maze.grid) throw new Error("Maze generation failed unexpectedly.");

                // --- Track Event de Generaci√≥n (despu√©s de √©xito) ---
                trackEvent('generate_maze', {
                    'maze_width': width,
                    'maze_height': height,
                    'maze_style': currentStyle,
                    'player_color': playerColorBase, // Enviar el color base seleccionado
                    'exit_marker': initialExitMarker,
                    'dark_mode': isDark,
                    'generation_method': method, // C√≥mo se inici√≥ la generaci√≥n
                    'generation_time_ms': genDuration,
                    'total_played_count': this.gameStats.total_played // Enviar contador local
                });
                // ---------------------------------------------------

                // Configurar Jugador y Renderer
                this.player = new Player(maze.start.x, maze.start.y, this.getCurrentPlayerColor()); // Usa el color calculado actual
                this.renderer.setMaze(maze);
                this.renderer.setPlayer(this.player);
                this.renderer.setViewMode(this.viewModeBtn.dataset.mode || 'overview'); // Restaurar modo de vista

                // Actualizar display de mejor tiempo para el nuevo tama√±o
                const currentMazeSize = `${maze.width}x${maze.height}`;
                this.updateBestTimeDisplay(currentMazeSize, true); // Actualiza en modal de ajustes

                this.gameActive = true;
                this.lastTimestamp = performance.now();
                this.startGameLoop(); // Iniciar bucle de renderizado/actualizaci√≥n
                console.log("New game started successfully.");

            } catch (error) {
                 // --- Track Error de Generaci√≥n ---
                trackEvent('exception', {
                    'description': `Maze generation failed: ${error.message}`,
                    'fatal': false // No es fatal para la app, pero s√≠ para esta partida
                 });
                 // -------------------------------
                console.error("Error starting new game:", error);
                this.showMessage("Error", `No se pudo generar el laberinto.\nIntenta con dimensiones m√°s peque√±as o recarga.\n(${error.message})`);
                this.gameActive = false; // Asegurar que el juego no est√© activo
            } finally {
                this.showLoading(false); // Ocultar indicador de carga
                this.isLoading = false;
                // Rehabilitar controles
                document.getElementById('newGameBtn').disabled = false; this.viewModeBtn.disabled = false;
                document.getElementById('settingsBtn').disabled = false; document.getElementById('scoresBtn').disabled = false;
            }
        }

         startGameLoop() {
             if (this.animationFrameId) return; // Evitar m√∫ltiples bucles
             console.log("Starting game loop...");
             let lastLoopTime = performance.now();
             const loop = (timestamp) => {
                 // Condici√≥n de parada: si el juego no est√° activo Y el jugador no se mueve Y no estamos en vista de c√°mara
                 if (!this.gameActive && !this.player?.isMoving && this.renderer.viewMode !== 'playerCamera') {
                     console.log("Game loop stopping (inactive).");
                     this.animationFrameId = null; // Marcar como detenido
                     return;
                 }
                 const deltaTime = timestamp - lastLoopTime;
                 lastLoopTime = timestamp;
                 // Actualizar estado (movimiento jugador, c√°mara)
                 if (this.player?.isMoving) this.player.update(deltaTime);
                 if (this.renderer.viewMode === 'playerCamera') this.renderer.updateCamera(deltaTime);
                 // Dibujar frame
                 this.renderer.drawFrame(timestamp);
                 // Solicitar siguiente frame
                 this.animationFrameId = requestAnimationFrame(loop);
             };
             this.animationFrameId = requestAnimationFrame(loop); // Iniciar el primer frame
         }

         stopGameLoop() {
             if (this.animationFrameId) {
                 cancelAnimationFrame(this.animationFrameId);
                 this.animationFrameId = null;
                 console.log("Game loop stopped.");
             }
         }

         handleMoveAttempt(dx, dy, inputMethod = 'unknown') {
             if (!this.gameActive || !this.player || this.isLoading || this.player.isMoving) return; // Chequeos de estado

             const moveResult = this.player.canMove(dx, dy, this.mazeGenerator);
             if (moveResult) {
                 // --- Track primer movimiento (inicio de gameplay) ---
                 if (!this.timerStarted) { // Solo si el timer no ha iniciado a√∫n
                     this.startTimer();
                     trackEvent('start_gameplay', {
                         'maze_width': this.mazeGenerator.width,
                         'maze_height': this.mazeGenerator.height,
                         'maze_style': document.body.dataset.mazeStyle || 'classic',
                         'input_method': inputMethod, // 'keyboard' o 'touch_swipe'
                     });
                 }
                 // ---------------------------------------------------

                 this.player.moveTo(moveResult.newX, moveResult.newY);
                 if (!this.animationFrameId) this.startGameLoop(); // Asegurar que el bucle corra si hay movimiento

                 // --- Chequeo de Victoria ---
                 if (moveResult.newX === this.mazeGenerator.end.x && moveResult.newY === this.mazeGenerator.end.y) {
                     this.gameActive = false; // Marcar juego como inactivo
                     const finalTimeResult = this.stopTimer(); // Detiene timer, calcula y guarda r√©cord si aplica

                     // --- Actualizar Estad√≠sticas Locales de Completado ---
                     const mazeW = this.mazeGenerator.width;
                     const mazeH = this.mazeGenerator.height;
                     const mazeSizeKey = `${mazeW}x${mazeH}`;
                     const currentStyle = document.body.dataset.mazeStyle || 'classic';
                     const playerColorBase = this.getCurrentPlayerColor(true); // Color base
                     const currentExitMarker = this.renderer.exitMarker || 'üèÅ';
                     const viewModeOnCompletion = this.renderer.viewMode;

                     this.incrementStat('total_completed');
                     this.incrementNestedStat('completions_by_resolution', mazeSizeKey);
                     this.incrementNestedStat('completions_by_style', currentStyle);
                     this.incrementNestedStat('completions_by_player_color', playerColorBase);
                     this.incrementNestedStat('completions_by_exit_marker', currentExitMarker);
                     this.saveStats(); // Guardar todas las stats actualizadas
                     // ------------------------------------------------------

                     // --- Track Event de Victoria (Level End) ---
                     trackEvent('level_end', {
                         'level_name': mazeSizeKey,
                         'maze_width': mazeW,
                         'maze_height': mazeH,
                         'maze_style': currentStyle,
                         'player_color': playerColorBase,
                         'exit_marker': currentExitMarker,
                         'time_seconds': finalTimeResult.time,
                         'value': finalTimeResult.time, // Usar 'value' para m√©tricas est√°ndar de GA
                         'is_new_record': finalTimeResult.isNewBest,
                         'success': true, // Indicar que fue una victoria
                         'view_mode_at_completion': viewModeOnCompletion,
                         'total_completed_count': this.gameStats.total_completed // Enviar contador local
                     });
                     // ------------------------------------------

                     // Mostrar mensaje de victoria con un peque√±o retraso para que la animaci√≥n termine
                     setTimeout(() => {
                         // Doble chequeo por si el usuario hizo algo raro mientras esperaba
                         if (this.player && Math.round(this.player.pixelX) === this.mazeGenerator.end.x && Math.round(this.player.pixelY) === this.mazeGenerator.end.y) {
                             const finalTimeStr = this.formatTime(finalTimeResult.time);
                             const mazeSize = `${this.mazeGenerator.width}x${this.mazeGenerator.height}`;
                             if (finalTimeResult.isNewBest) {
                                 this.showMessage("¬°Nuevo R√©cord! üèÜ", "¬°Incre√≠ble! Has establecido un nuevo r√©cord.", finalTimeStr, `R√©cord (${mazeSize}): ${finalTimeStr}`);
                             } else {
                                 const bestTime = this.bestTimes[mazeSize];
                                 const bestTimeStr = bestTime !== undefined ? this.formatTime(bestTime) : '--:--';
                                 this.showMessage("¬°Completado! üéâ", "Has encontrado la salida del laberinto.", finalTimeStr, `Mejor tiempo (${mazeSize}): ${bestTimeStr}`);
                             }
                         } else {
                             // Fallback si el estado cambi√≥ inesperadamente
                             console.warn("Win condition met, but player not at end coords after delay. Showing generic win message.");
                             this.showMessage("¬°Completado! üéâ", "Has encontrado la salida del laberinto.");
                         }
                     }, PLAYER_SMOOTHING * 800); // Espera basada en el smoothing del jugador
                 }
             } else {
                 // Opcional: Trackear intentos de movimiento fallidos (si es mucho ruido, no hacerlo)
                 // trackEvent('player_move_fail', { 'direction_dx': dx, 'direction_dy': dy, /*...*/ });
             }
         }

         handleKeyDown(e) {
             // Ignorar si un modal est√° abierto, no est√° activo el juego, o est√° cargando
             if (document.getElementById('settings-modal').classList.contains('visible') ||
                 document.getElementById('scores-modal').classList.contains('visible') ||
                 !this.gameActive || this.isLoading) return;

             let dx = 0; let dy = 0;
             switch (e.key) {
                 case 'ArrowUp': case 'w': case 'W': dy = -1; break;
                 case 'ArrowDown': case 's': case 'S': dy = 1; break;
                 case 'ArrowLeft': case 'a': case 'A': dx = -1; break;
                 case 'ArrowRight': case 'd': case 'D': dx = 1; break;
                 default: return; // Ignorar otras teclas
             }
             e.preventDefault(); // Prevenir scroll de p√°gina con flechas
             this.handleMoveAttempt(dx, dy, 'keyboard'); // Pasar m√©todo de entrada
         }

         handleTouchStart(e) {
             if (document.getElementById('settings-modal').classList.contains('visible') || document.getElementById('scores-modal').classList.contains('visible') || !this.gameActive || this.isLoading || e.touches.length !== 1) return; // Solo un dedo
             this.touchStartX = e.touches[0].clientX;
             this.touchStartY = e.touches[0].clientY;
             this.touchEndX = this.touchStartX; // Reset end coords
             this.touchEndY = this.touchStartY;
         }

         handleTouchMove(e) {
             if (document.getElementById('settings-modal').classList.contains('visible') || document.getElementById('scores-modal').classList.contains('visible') || !this.gameActive || this.isLoading || e.touches.length !== 1) return;
             this.touchEndX = e.touches[0].clientX;
             this.touchEndY = e.touches[0].clientY;
             e.preventDefault(); // Prevenir scroll durante swipe
         }

         handleTouchEnd(e) {
            if (document.getElementById('settings-modal').classList.contains('visible') || document.getElementById('scores-modal').classList.contains('visible') || !this.gameActive || this.isLoading) return;
             // Asegurar que hubo un start v√°lido
             if (this.touchStartX === 0 && this.touchStartY === 0) return;

             const deltaX = this.touchEndX - this.touchStartX;
             const deltaY = this.touchEndY - this.touchStartY;
             const absDeltaX = Math.abs(deltaX);
             const absDeltaY = Math.abs(deltaY);
             let dx = 0; let dy = 0;

             // Determinar direcci√≥n del swipe si supera el umbral
             if (Math.max(absDeltaX, absDeltaY) > SWIPE_THRESHOLD) {
                 if (absDeltaX > absDeltaY) { // Swipe horizontal
                     dx = deltaX > 0 ? 1 : -1;
                 } else { // Swipe vertical
                     dy = deltaY > 0 ? 1 : -1;
                 }
                 this.handleMoveAttempt(dx, dy, 'touch_swipe'); // Pasar m√©todo de entrada
             }
             // Resetear coordenadas de toque
             this.touchStartX = 0; this.touchStartY = 0; this.touchEndX = 0; this.touchEndY = 0;
         }

         setDarkMode(isDark) {
             document.body.classList.toggle('dark-mode', isDark);
             // Actualizar previews de color en el modal de ajustes
             this.updatePlayerColorVisuals(isDark);
             // Recalcular y aplicar el color actual del jugador
             this.updatePlayerColor(document.querySelector('#modal-playerChoice input:checked'));
             // Forzar al renderer a actualizar sus colores y redibujar
             if (this.renderer) {
                 this.renderer.updateStyleSettings(true); // true para forzar rec√°lculo
                 if (this.gameActive || this.renderer.maze) this.renderer.drawFrame();
             }
             console.log(`Dark mode ${isDark ? 'enabled' : 'disabled'}`);
         }

         setMazeStyle(styleName, forceUpdate = false) {
             const currentStyle = document.body.dataset.mazeStyle;
             if (!forceUpdate && currentStyle === styleName) return; // No hacer nada si ya es el estilo actual

             document.body.dataset.mazeStyle = styleName;
             console.log(`Maze style set to: ${styleName}`);

             // Filtrar opciones de color de jugador para el nuevo estilo
             this.filterPlayerChoicesByStyle(styleName);

             // Re-seleccionar color de jugador si el actual qued√≥ oculto
             const currentSelectedPlayerRadio = document.querySelector('#modal-playerChoice input:checked');
             if (!currentSelectedPlayerRadio || currentSelectedPlayerRadio.parentElement.hidden) {
                 const firstVisibleChoice = document.querySelector(`#modal-playerChoice label:not([hidden]) input`);
                 if (firstVisibleChoice) firstVisibleChoice.checked = true;
                 else { // Fallback absoluto
                     const fallback = document.querySelector('#modal-playerChoice input[name="modal-player"]');
                     if(fallback) fallback.checked = true;
                 }
             }
             // Aplicar el color de jugador (puede que haya cambiado por el fallback)
             this.updatePlayerColor(document.querySelector('#modal-playerChoice input:checked'));

             // Forzar al renderer a actualizar TODO (colores, grosores, etc.) y redibujar
             if (this.renderer) {
                 this.renderer.updateStyleSettings(true);
                 this.renderer.setExitMarker(document.querySelector('#modal-exitChoice input:checked')?.value || 'üèÅ'); // Reaplicar marcador
                 if (this.gameActive || this.renderer.maze) this.renderer.drawFrame();
             }
         }

         filterPlayerChoicesByStyle(styleName) {
             const playerLabels = document.querySelectorAll('#modal-playerChoice label');
             playerLabels.forEach(label => {
                 const input = label.querySelector('input');
                 const specificStyle = input.dataset.styleSpecific;
                 // Ocultar si es espec√≠fico de OTRO estilo
                 label.hidden = specificStyle && specificStyle !== styleName;
             });
             // Actualizar los colores de los previews visibles
              this.updatePlayerColorVisuals(document.body.classList.contains('dark-mode'));
         }

         updatePlayerColor(radioElement) {
             // Asegurarse de tener un elemento v√°lido
             if (!radioElement || !radioElement.checked) {
                 radioElement = document.querySelector('#modal-playerChoice input:checked');
                 if (!radioElement) return; // Salir si no hay nada seleccionado
             }
             // Calcular el color correcto (depende de light/dark mode)
             const newColor = this.calculatePlayerColor(radioElement);
             // Aplicar al jugador si existe
             if (this.player) {
                 this.player.setColor(newColor);
                 console.log(`Player color updated to: ${newColor}`);
                 // Redibujar si el juego est√° activo o hay un laberinto visible
                 if(this.renderer && (this.gameActive || this.renderer.maze)) {
                     this.renderer.drawFrame();
                 }
             }
             // Actualizar colores del minimapa (especialmente el del jugador)
             if (this.minimap) this.minimap.updateColors();
         }

         updatePlayerColorVisuals(isDark) {
             const playerRadios = document.querySelectorAll('#modal-playerChoice input[type="radio"]');
             playerRadios.forEach(radio => {
                 const colorToShow = this.calculatePlayerColor(radio, isDark); // Calcular color para el modo actual
                 const previewSpan = radio.nextElementSibling;
                 // Asegurarse de que es el span de preview correcto
                 if (previewSpan && previewSpan.classList.contains('color-preview')) {
                     previewSpan.style.backgroundColor = colorToShow; // Aplicar al fondo del span
                 }
             });
         }

         calculatePlayerColor(radioElement, isDark = document.body.classList.contains('dark-mode')) {
              if (!radioElement) return getCssVariable('--player-color'); // Fallback
              // Priorizar data attributes si existen
              const lightColor = radioElement.dataset.light;
              const darkColor = radioElement.dataset.dark;
              const baseColor = radioElement.value; // El valor del input (hex)
              // Devolver color correspondiente al modo
              return isDark ? (darkColor || baseColor) : (lightColor || baseColor);
         }

         getCurrentPlayerColor(getBaseValue = false) {
             const selectedRadio = document.querySelector('#modal-playerChoice input:checked');
             if (!selectedRadio) return getCssVariable('--player-color'); // Fallback al color CSS actual

             if (getBaseValue) {
                 // Devolver el valor base (value attribute), √∫til para tracking consistente
                 return selectedRadio.value;
             } else {
                 // Devolver el color calculado para el modo actual (light/dark)
                 return this.calculatePlayerColor(selectedRadio);
             }
         }

         showMessage(title, text, finalTimeStr = '', bestTimeMsg = '') {
            // Solo trackear si el modal no estaba ya visible
            const overlay = document.getElementById('message-overlay');
            if (!overlay.classList.contains('visible')) {
                trackEvent('modal_interaction', {'modal_type': 'win_message', 'interaction': 'open'});
            }
            overlay.querySelector('h2').textContent = title;
            const textParagraph = overlay.querySelector('p:not([id])'); // El p√°rrafo principal de texto
            if (textParagraph) textParagraph.innerHTML = text.replace(/\n/g, '<br>'); // Permitir saltos de l√≠nea
            const finalTimeEl = document.getElementById('final-time-msg');
            const bestTimeEl = document.getElementById('final-best-time-msg');
            // Mostrar u ocultar textos de tiempo seg√∫n si se proporcionan
            finalTimeEl.textContent = finalTimeStr ? `Tu Tiempo: ${finalTimeStr}` : '';
            bestTimeEl.textContent = bestTimeMsg;
            finalTimeEl.style.display = finalTimeStr ? 'block' : 'none';
            bestTimeEl.style.display = bestTimeMsg ? 'block' : 'none';
            // Hacer visible el overlay
            overlay.classList.add('visible');
            this.gameActive = false; // Asegurar que el juego se detenga
            this.stopGameLoop(); // Detener el bucle de renderizado
            console.log(`Message shown: ${title}`);
         }

         hideMessage() {
             const overlay = document.getElementById('message-overlay');
             if (overlay.classList.contains('visible')) { // Evitar eventos dobles si ya est√° oculto
                trackEvent('modal_interaction', {'modal_type': 'win_message', 'interaction': 'close'});
             }
             overlay.classList.remove('visible');
         }

         showLoading(show, text = 'Generando...') {
            const indicator = document.getElementById('loading-indicator');
            const newGameBtn = document.getElementById('newGameBtn');
            const viewModeBtn = this.viewModeBtn;
            const settingsBtn = document.getElementById('settingsBtn');
            const scoresBtn = document.getElementById('scoresBtn');

            if (show) {
                indicator.textContent = text;
                indicator.classList.add('visible');
                // Deshabilitar botones interactivos principales
                if(newGameBtn) newGameBtn.disabled = true;
                if(viewModeBtn) viewModeBtn.disabled = true;
                if(settingsBtn) settingsBtn.disabled = true;
                if(scoresBtn) scoresBtn.disabled = true;
            } else {
                indicator.classList.remove('visible');
                 // Solo rehabilitar si NO estamos en medio de otra carga (this.isLoading debe ser false)
                if (!this.isLoading) {
                     if(newGameBtn) newGameBtn.disabled = false;
                     if(viewModeBtn) viewModeBtn.disabled = false;
                     if(settingsBtn) settingsBtn.disabled = false;
                     if(scoresBtn) scoresBtn.disabled = false;
                }
            }
         }

         handlePrint() {
             if (!this.mazeGenerator?.generationComplete || !this.renderer || !this.player) {
                 alert('Genera un laberinto completo antes de imprimir.');
                 trackEvent('print_attempt_failed', { 'reason': 'maze_not_ready' });
                 return;
             }
             if (this.isLoading || this.renderer.isPrinting) {
                 alert('Espera a que termine la acci√≥n actual antes de imprimir.');
                 trackEvent('print_attempt_failed', { 'reason': 'busy' });
                 return;
             }
             console.log("Initiating print...");

             // --- Track Event de Impresi√≥n ---
             trackEvent('print_maze', {
                 'maze_width': this.mazeGenerator.width,
                 'maze_height': this.mazeGenerator.height,
                 'maze_style': document.body.dataset.mazeStyle || 'classic',
                 'player_color': this.getCurrentPlayerColor(true), // Color base
                 'exit_marker': this.renderer.exitMarker || 'üèÅ'
             });
             // ---------------------------------

             const savedState = this.renderer.prepareForPrint(); // Prepara el canvas para alta resoluci√≥n
             if (!savedState) {
                 console.error("Failed to prepare renderer for printing.");
                 alert("Error al preparar la impresi√≥n.");
                 trackEvent('exception', { 'description': 'Renderer prepareForPrint failed', 'fatal': false });
                 this.renderer.isPrinting = false; // Asegurar que no quede bloqueado
                 return;
             }

             // Peque√±o delay para asegurar que el DOM se actualice antes de llamar a print()
             setTimeout(() => {
                 try {
                     window.print(); // Abre el di√°logo de impresi√≥n del navegador
                     console.log("Print dialog should be open.");
                      // Restaurar estado despu√©s de un tiempo (print es bloqueante, pero esto se ejecuta despu√©s)
                      // Es un intento, puede que el usuario cancele o tarde mucho.
                      setTimeout(() => {
                          this.renderer.restoreAfterPrint(savedState);
                       }, 200); // Un tiempo razonable para que el di√°logo aparezca/desaparezca
                 } catch (e) {
                     console.error("Error during window.print():", e);
                     alert("Ocurri√≥ un error al intentar imprimir.");
                     trackEvent('exception', { 'description': `Print execution error: ${e.message}`, 'fatal': false });
                     this.renderer.restoreAfterPrint(savedState); // Intentar restaurar igualmente
                 }
             }, 100); // Delay antes de llamar a print()
         }
    } // End of Game class

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        // Usar requestAnimationFrame para asegurar que el layout inicial est√© calculado
        requestAnimationFrame(() => {
            try {
                 window.mazeGame = new Game(); // Crear instancia global para f√°cil acceso (o usar otro m√©todo)
                 console.log("Maze Game Initialized Successfully.");
                 trackEvent('app_load_success'); // Rastrear carga exitosa
            } catch (error) {
                 console.error("CRITICAL: Failed to initialize Maze Game:", error);
                  // --- Track Error Cr√≠tico de Inicializaci√≥n ---
                  trackEvent('exception', {
                      'description': `Critical init error: ${error.message}`,
                      'fatal': true // Este error impide que la app funcione
                    });
                 // Mostrar mensaje de error al usuario si la inicializaci√≥n falla
                 document.body.innerHTML = `<div style="padding: 20px; text-align: center; color: red; font-family: sans-serif;">
                    <h2>Error Cr√≠tico</h2>
                    <p>No se pudo iniciar la aplicaci√≥n:</p>
                    <pre style="background: #fee; border: 1px solid red; padding: 10px; text-align: left; display: inline-block;">${error.message}\n${error.stack || ''}</pre>
                    <p>Por favor, recarga la p√°gina o intenta m√°s tarde.</p>
                 </div>`;
            }
        });
    });

</script>
<!-- Google tag (gtag.js) -->
<!-- !! IMPORTANTE !! Reemplaza G-XXXXXXXXXX con tu ID de medici√≥n de Google Analytics 4 -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8RTR00RC0J"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  // !! IMPORTANTE !! Reemplaza G-XXXXXXXXXX con tu ID de medici√≥n de Google Analytics 4
  gtag('config', 'G-8RTR00RC0J');

  // Opcional: Enviar un evento page_view inicial (GA4 lo hace autom√°ticamente con 'config', pero puedes ser expl√≠cito)
  // gtag('event', 'page_view', { page_title: document.title, page_location: location.href });

  console.log("Google Analytics configured with ID: G-8RTR00RC0J");
</script>
</body>
</html>
