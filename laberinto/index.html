<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Laberinto App V3</title>
    <style>
        /* --- ROOT VARIABLES (Ajustadas) --- */
        :root {
            /* ... (Variables de tema claro/oscuro como antes) ... */
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* Light Theme */
            --bg-color-light: #f8f9fa; /* Slightly off-white */
            --panel-bg-light: #ffffff; /* White panels */
            --control-bg-light: #ffffff;
            --text-color-light: #212529;
            --text-muted-light: #6c757d;
            --border-color-light: #dee2e6;
            --primary-color-light: #007bff;
            --primary-hover-light: #0056b3;
            --shadow-light: rgba(0, 0, 0, 0.08); /* Lighter shadow */
            --input-bg-light: #ffffff;
            --input-border-light: #ced4da;
            --maze-bg-light: #e9ecef; /* Light grey maze bg */
            --wall-color-light: #343a40;
            --wall-glow-light: rgba(52, 58, 64, 0.2);
            --wall-shadow-light: rgba(0, 0, 0, 0.15);
            --player-color-light: #e63946;
            --player-glow-light: rgba(230, 57, 70, 0.3);
            --player-shadow-light: rgba(230, 57, 70, 0.5);
            --start-color-light: #a8dadc;
            --end-color-light: #457b9d;
            --path-color-light: rgba(227, 242, 253, 0.3);
            --minimap-bg-light: rgba(255, 255, 255, 0.88); /* More opaque */
            --minimap-border-light: #adb5bd;
            --minimap-player-light: var(--player-color-light);

            /* Dark Theme */
            --bg-color-dark: #121212;
            --panel-bg-dark: #1e1e1e;
            --control-bg-dark: #2a2a2a;
            --text-color-dark: #e0e0e0;
            --text-muted-dark: #adb5bd;
            --border-color-dark: #333; /* Slightly lighter border */
            --primary-color-dark: #4dabf7;
            --primary-hover-dark: #1e88e5;
            --shadow-dark: rgba(255, 255, 255, 0.06);
            --input-bg-dark: #252525; /* Darker input */
            --input-border-dark: #444;
            --maze-bg-dark: #212121; /* Darker maze bg */
            --wall-color-dark: #ced4da;
            --wall-glow-dark: rgba(206, 212, 218, 0.25);
            --wall-shadow-dark: rgba(255, 255, 255, 0.1);
            --player-color-dark: #ff8a80;
            --player-glow-dark: rgba(255, 138, 128, 0.35);
            --player-shadow-dark: rgba(255, 138, 128, 0.5);
            --start-color-dark: #546e7a;
            --end-color-dark: #81d4fa;
            --path-color-dark: rgba(50, 50, 70, 0.3);
            --minimap-bg-dark: rgba(30, 30, 30, 0.9); /* More opaque */
            --minimap-border-dark: #6c757d;
            --minimap-player-dark: var(--player-color-dark);

            /* Default assignments (Light initially) */
            --bg-color: var(--bg-color-light);
            --panel-bg: var(--panel-bg-light);
            --control-bg: var(--control-bg-light);
            --text-color: var(--text-color-light);
            --text-muted: var(--text-muted-light);
            --border-color: var(--border-color-light);
            --primary-color: var(--primary-color-light);
            --primary-hover: var(--primary-hover-light);
            --shadow: var(--shadow-light);
            --input-bg: var(--input-bg-light);
            --input-border: var(--input-border-light);
            --maze-bg: var(--maze-bg-light);
            --wall-color: var(--wall-color-light);
            --wall-glow: var(--wall-glow-light);
            --wall-shadow: var(--wall-shadow-light);
            --player-color: var(--player-color-light);
            --player-glow: var(--player-glow-light);
            --player-shadow: var(--player-shadow-light);
            --start-color: var(--start-color-light);
            --end-color: var(--end-color-light);
            --path-color: var(--path-color-light);
            --minimap-bg: var(--minimap-bg-light);
            --minimap-border: var(--minimap-border-light);
            --minimap-player: var(--minimap-player-light);

            /* Factors */
            --wall-thickness-factor: 0.1;
            --player-size-factor: 0.6;
            --end-marker-size-factor: 0.7;
            --transition-speed: 0.3s;

            /* UI Dimensions */
            --bottom-nav-height: 60px;
            --modal-max-width: 500px;
            --top-ui-height: 40px;
        }

        /* --- Theme Application --- */
        /* These rules now apply the theme variables correctly */
        body {
             --bg-color: var(--bg-color-light); --panel-bg: var(--panel-bg-light); --control-bg: var(--control-bg-light);
             --text-color: var(--text-color-light); --text-muted: var(--text-muted-light); --border-color: var(--border-color-light);
             --primary-color: var(--primary-color-light); --primary-hover: var(--primary-hover-light); --shadow: var(--shadow-light);
             --input-bg: var(--input-bg-light); --input-border: var(--input-border-light);
             /* Style-dependent variables default to classic light */
             --maze-bg: var(--_maze-classic-light, var(--maze-bg-light));
             --wall-color: var(--_wall-classic-light, var(--wall-color-light));
             --wall-glow: var(--_wall-glow-classic-light, var(--wall-glow-light));
             --wall-shadow: var(--_wall-shadow-classic-light, var(--wall-shadow-light));
             --player-color: var(--_player-classic-light, var(--player-color-light));
             --player-glow: var(--_player-glow-classic-light, var(--player-glow-light));
             --player-shadow: var(--_player-shadow-classic-light, var(--player-shadow-light));
             --start-color: var(--_start-classic-light, var(--start-color-light));
             --end-color: var(--_end-classic-light, var(--end-color-light));
             --minimap-bg: var(--_minimap-bg-classic-light, var(--minimap-bg-light));
             --minimap-border: var(--_minimap-border-classic-light, var(--minimap-border-light));
             --minimap-player: var(--_minimap-player-classic-light, var(--minimap-player-light));
        }
        body.dark-mode {
             --bg-color: var(--bg-color-dark); --panel-bg: var(--panel-bg-dark); --control-bg: var(--control-bg-dark);
             --text-color: var(--text-color-dark); --text-muted: var(--text-muted-dark); --border-color: var(--border-color-dark);
             --primary-color: var(--primary-color-dark); --primary-hover: var(--primary-hover-dark); --shadow: var(--shadow-dark);
             --input-bg: var(--input-bg-dark); --input-border: var(--input-border-dark);
              /* Style-dependent variables default to classic dark */
             --maze-bg: var(--_maze-classic-dark, var(--maze-bg-dark));
             --wall-color: var(--_wall-classic-dark, var(--wall-color-dark));
             --wall-glow: var(--_wall-glow-classic-dark, var(--wall-glow-dark));
             --wall-shadow: var(--_wall-shadow-classic-dark, var(--wall-shadow-dark));
             --player-color: var(--_player-classic-dark, var(--player-color-dark));
             --player-glow: var(--_player-glow-classic-dark, var(--player-glow-dark));
             --player-shadow: var(--_player-shadow-classic-dark, var(--player-shadow-dark));
             --start-color: var(--_start-classic-dark, var(--start-color-dark));
             --end-color: var(--_end-classic-dark, var(--end-color-dark));
             --minimap-bg: var(--_minimap-bg-classic-dark, var(--minimap-bg-dark));
             --minimap-border: var(--_minimap-border-classic-dark, var(--minimap-border-dark));
             --minimap-player: var(--_minimap-player-classic-dark, var(--minimap-player-dark));
        }

        /* --- Maze Style Overrides --- */
        /* Define style-specific base variables first using underscore convention */
        body[data-maze-style="classic"] {
            --_maze-classic-light: var(--maze-bg-light); --_maze-classic-dark: var(--maze-bg-dark);
            --_wall-classic-light: var(--wall-color-light); --_wall-classic-dark: var(--wall-color-dark);
            --_wall-glow-classic-light: var(--wall-glow-light); --_wall-glow-classic-dark: var(--wall-glow-dark);
            --_wall-shadow-classic-light: var(--wall-shadow-light); --_wall-shadow-classic-dark: var(--wall-shadow-dark);
            --_player-classic-light: var(--player-color-light); --_player-classic-dark: var(--player-color-dark);
            --_player-glow-classic-light: var(--player-glow-light); --_player-glow-classic-dark: var(--player-glow-dark);
            --_player-shadow-classic-light: var(--player-shadow-light); --_player-shadow-classic-dark: var(--player-shadow-dark);
            --_start-classic-light: var(--start-color-light); --_start-classic-dark: var(--start-color-dark);
            --_end-classic-light: var(--end-color-light); --_end-classic-dark: var(--end-color-dark);
            --_minimap-bg-classic-light: var(--minimap-bg-light); --_minimap-bg-classic-dark: var(--minimap-bg-dark);
            --_minimap-border-classic-light: var(--minimap-border-light); --_minimap-border-classic-dark: var(--minimap-border-dark);
            --_minimap-player-classic-light: var(--minimap-player-light); --_minimap-player-classic-dark: var(--minimap-player-dark);
            --wall-thickness-factor: 0.1;
        }
        body[data-maze-style="matrix"] {
            --_maze-classic-light: #050505; --_maze-classic-dark: #000000;
            --_wall-classic-light: #00ff41; --_wall-classic-dark: #39ff14;
            --_wall-glow-classic-light: rgba(0, 255, 65, 0.3); --_wall-glow-classic-dark: rgba(57, 255, 20, 0.3);
            --_wall-shadow-classic-light: rgba(0,0,0,0.1); --_wall-shadow-classic-dark: rgba(0,0,0,0.2);
            --_player-classic-light: #ffdf00; --_player-classic-dark: #ffee58;
            --_player-glow-classic-light: rgba(255, 223, 0, 0.4); --_player-glow-classic-dark: rgba(255, 238, 88, 0.4);
            --_player-shadow-classic-light: rgba(255, 223, 0, 0.6); --_player-shadow-classic-dark: rgba(255, 238, 88, 0.6);
            --_start-classic-light: #333; --_start-classic-dark: #222;
            --_end-classic-light: #ccc; --_end-classic-dark: #eee;
            --_minimap-bg-classic-light: rgba(0, 10, 0, 0.8); --_minimap-bg-classic-dark: rgba(0, 0, 0, 0.85);
            --_minimap-border-classic-light: var(--_wall-classic-light); --_minimap-border-classic-dark: var(--_wall-classic-dark);
            --_minimap-player-classic-light: var(--_player-classic-light); --_minimap-player-classic-dark: var(--_player-classic-dark);
            --wall-thickness-factor: 0.1;
        }
         body[data-maze-style="blueprint"] {
             --_maze-classic-light: #2962ff; --_maze-classic-dark: #1e88e5;
             --_wall-classic-light: #ffffff; --_wall-classic-dark: #ffffff;
             --_wall-glow-classic-light: rgba(255, 255, 255, 0.2); --_wall-glow-classic-dark: rgba(255, 255, 255, 0.15);
             --_wall-shadow-classic-light: rgba(0,0,0,0.1); --_wall-shadow-classic-dark: rgba(0,0,0,0.2);
             --_player-classic-light: #ffeb3b; --_player-classic-dark: #fff59d;
             --_player-glow-classic-light: rgba(255, 235, 59, 0.4); --_player-glow-classic-dark: rgba(255, 245, 157, 0.4);
             --_player-shadow-classic-light: rgba(255, 235, 59, 0.6); --_player-shadow-classic-dark: rgba(255, 245, 157, 0.6);
             --_start-classic-light: rgba(255,255,255,0.2); --_start-classic-dark: rgba(255,255,255,0.15);
             --_end-classic-light: #ffffff; --_end-classic-dark: #ffffff;
             --_minimap-bg-classic-light: rgba(0, 50, 150, 0.85); --_minimap-bg-classic-dark: rgba(30, 136, 229, 0.85);
             --_minimap-border-classic-light: #bbdefb; --_minimap-border-classic-dark: #90caf9;
             --_minimap-player-classic-light: var(--_player-classic-light); --_minimap-player-classic-dark: var(--_player-classic-dark);
             --wall-thickness-factor: 0.05;
         }
         body[data-maze-style="neon"] {
             --_maze-classic-light: #1a1a2e; --_maze-classic-dark: #121212;
             --_wall-classic-light: #ff00ff; --_wall-classic-dark: #f06292;
             --_wall-glow-classic-light: rgba(255, 0, 255, 0.4); --_wall-glow-classic-dark: rgba(240, 98, 146, 0.4);
             --_wall-shadow-classic-light: rgba(255, 0, 255, 0.2); --_wall-shadow-classic-dark: rgba(240, 98, 146, 0.2);
             --_player-classic-light: #00ffff; --_player-classic-dark: #4dd0e1;
             --_player-glow-classic-light: rgba(0, 255, 255, 0.5); --_player-glow-classic-dark: rgba(77, 208, 225, 0.5);
             --_player-shadow-classic-light: rgba(0, 255, 255, 0.7); --_player-shadow-classic-dark: rgba(77, 208, 225, 0.7);
             --_start-classic-light: rgba(50, 0, 50, 0.5); --_start-classic-dark: rgba(30, 0, 30, 0.5);
             --_end-classic-light: #ffff00; --_end-classic-dark: #fff176;
             --_minimap-bg-classic-light: rgba(26, 26, 46, 0.9); --_minimap-bg-classic-dark: rgba(18, 18, 18, 0.9);
             --_minimap-border-classic-light: var(--_wall-classic-light); --_minimap-border-classic-dark: var(--_wall-classic-dark);
             --_minimap-player-classic-light: var(--_player-classic-light); --_minimap-player-classic-dark: var(--_player-classic-dark);
             --wall-thickness-factor: 0.1;
         }
         body[data-maze-style="cyber"] {
             --_maze-classic-light: #2a004f; --_maze-classic-dark: #1a0033;
             --_wall-classic-light: #00ffff; --_wall-classic-dark: #7fffd4;
             --_wall-glow-classic-light: rgba(0, 255, 255, 0.4); --_wall-glow-classic-dark: rgba(127, 255, 212, 0.4);
             --_wall-shadow-classic-light: rgba(0, 255, 255, 0.2); --_wall-shadow-classic-dark: rgba(127, 255, 212, 0.2);
             --_player-classic-light: #ff0066; --_player-classic-dark: #ff4081;
             --_player-glow-classic-light: rgba(255, 0, 102, 0.5); --_player-glow-classic-dark: rgba(255, 64, 129, 0.5);
             --_player-shadow-classic-light: rgba(255, 0, 102, 0.7); --_player-shadow-classic-dark: rgba(255, 64, 129, 0.7);
             --_start-classic-light: rgba(0, 255, 255, 0.1); --_start-classic-dark: rgba(127, 255, 212, 0.1);
             --_end-classic-light: #ffab00; --_end-classic-dark: #ffd180;
             --_minimap-bg-classic-light: rgba(42, 0, 79, 0.9); --_minimap-bg-classic-dark: rgba(26, 0, 51, 0.9);
             --_minimap-border-classic-light: var(--_wall-classic-light); --_minimap-border-classic-dark: var(--_wall-classic-dark);
             --_minimap-player-classic-light: var(--_player-classic-light); --_minimap-player-classic-dark: var(--_player-classic-dark);
             --wall-thickness-factor: 0.08;
         }
        /* Now apply the selected style's variables */
         body[data-maze-style="matrix"] { --maze-bg: var(--_maze-classic-light); --wall-color: var(--_wall-classic-light); --wall-glow: var(--_wall-glow-classic-light); --wall-shadow: var(--_wall-shadow-classic-light); --player-color: var(--_player-classic-light); --player-glow: var(--_player-glow-classic-light); --player-shadow: var(--_player-shadow-classic-light); --start-color: var(--_start-classic-light); --end-color: var(--_end-classic-light); --minimap-bg: var(--_minimap-bg-classic-light); --minimap-border: var(--_minimap-border-classic-light); --minimap-player: var(--_minimap-player-classic-light); }
         body[data-maze-style="matrix"].dark-mode { --maze-bg: var(--_maze-classic-dark); --wall-color: var(--_wall-classic-dark); --wall-glow: var(--_wall-glow-classic-dark); --wall-shadow: var(--_wall-shadow-classic-dark); --player-color: var(--_player-classic-dark); --player-glow: var(--_player-glow-classic-dark); --player-shadow: var(--_player-shadow-classic-dark); --start-color: var(--_start-classic-dark); --end-color: var(--_end-classic-dark); --minimap-bg: var(--_minimap-bg-classic-dark); --minimap-border: var(--_minimap-border-classic-dark); --minimap-player: var(--_minimap-player-classic-dark); }
         /* Repeat similar blocks for blueprint, neon, cyber */
        body[data-maze-style="blueprint"] { --maze-bg: var(--_maze-classic-light); --wall-color: var(--_wall-classic-light); /* ... etc */ }
        body[data-maze-style="blueprint"].dark-mode { --maze-bg: var(--_maze-classic-dark); --wall-color: var(--_wall-classic-dark); /* ... etc */ }
        body[data-maze-style="neon"] { --maze-bg: var(--_maze-classic-light); --wall-color: var(--_wall-classic-light); /* ... etc */ }
        body[data-maze-style="neon"].dark-mode { --maze-bg: var(--_maze-classic-dark); --wall-color: var(--_wall-classic-dark); /* ... etc */ }
        body[data-maze-style="cyber"] { --maze-bg: var(--_maze-classic-light); --wall-color: var(--_wall-classic-light); /* ... etc */ }
        body[data-maze-style="cyber"].dark-mode { --maze-bg: var(--_maze-classic-dark); --wall-color: var(--_wall-classic-dark); /* ... etc */ }


        /* --- General Layout (Mobile App First) --- */
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        /* Use 100% height for robustness on mobile */
        html, body { height: 100%; }
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            width: 100%; /* Use width 100% */
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
        }

        /* --- Main Content Area --- */
        #main-content {
            flex-grow: 1;
            position: relative; /* Crucial for absolute children like overlays */
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- Top UI Overlay (Timer) --- */
        #game-ui-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%;
            height: var(--top-ui-height);
            display: flex; justify-content: center; align-items: center;
            padding: 5px 10px;
            z-index: 100; /* Increased z-index */
            pointer-events: none;
        }
        .timer-display {
            background-color: rgba(var(--panel-bg-rgb, 255, 255, 255), 0.85); /* Use RGB for opacity */
            color: var(--primary-color); padding: 0.3rem 0.8rem; border-radius: 15px;
            font-size: 0.9rem; font-weight: bold; box-shadow: 0 1px 3px var(--shadow);
            pointer-events: auto; display: inline-flex; align-items: center;
        }
        body { --panel-bg-rgb: 255, 255, 255; } /* Light theme fallback */
        body.dark-mode { --panel-bg-rgb: 30, 30, 30; }
        .timer-display .best-time { display: none; }

        /* --- Maze Container --- */
        #maze-container {
            flex-grow: 1;
            position: relative; /* Stacking context */
            overflow: hidden;
            background-color: var(--maze-bg);
            display: flex; justify-content: center; align-items: center;
            touch-action: none;
            /* Ensure it doesn't get a higher z-index unintentionally */
            z-index: 1;
        }
        #mazeCanvas {
            display: block; position: absolute;
            image-rendering: pixelated; image-rendering: crisp-edges;
            transform-origin: top left;
            /* Give canvas explicit lower z-index if needed, but usually not required */
             /* z-index: 0; */
        }

        /* --- Bottom Navigation Bar --- */
        #bottom-nav {
            flex-shrink: 0; height: var(--bottom-nav-height);
            background-color: var(--panel-bg); border-top: 1px solid var(--border-color);
            box-shadow: 0 -2px 5px var(--shadow); display: flex;
            justify-content: space-around; align-items: center;
            padding: 0 10px;
            z-index: 1000; /* High z-index */
        }
        #bottom-nav button { /* Styles unchanged, should be fine */
            background: none; border: none; color: var(--text-muted); display: flex;
            flex-direction: column; align-items: center; padding: 5px 10px;
            font-size: 0.75rem; cursor: pointer; transition: color 0.2s ease;
            border-radius: 4px; min-height: 50px; justify-content: center;
            flex-grow: 1; max-width: 150px; text-align: center;
        }
        #bottom-nav button .icon { font-size: 1.5rem; margin-bottom: 2px; }
        #bottom-nav button.active, #bottom-nav button:active { color: var(--primary-color); }
        #bottom-nav button:disabled { color: var(--border-color); cursor: not-allowed; opacity: 0.6; }

        /* --- Settings Modal (Z-indices checked) --- */
        #settings-modal-backdrop { /* z-index: 1100 */
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.6); z-index: 1100;
            opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, visibility 0s linear var(--transition-speed);
        }
        #settings-modal { /* z-index: 1110 */
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.9); width: 90%;
            max-width: var(--modal-max-width); max-height: 85vh;
            background-color: var(--panel-bg); border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2); z-index: 1110;
            opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, transform var(--transition-speed) ease, visibility 0s linear var(--transition-speed);
            display: flex; flex-direction: column;
        }
        #settings-modal-backdrop.visible { opacity: 1; visibility: visible; transition-delay: 0s; }
        #settings-modal.visible { opacity: 1; visibility: visible; transform: translate(-50%, -50%) scale(1); transition-delay: 0s; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 0.8rem 1.2rem; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .modal-header h2 { margin: 0; font-size: 1.2rem; color: var(--primary-color); }
        #closeSettingsBtn { background: none; border: none; font-size: 1.8rem; line-height: 1; color: var(--text-muted); cursor: pointer; padding: 0.2rem; }
        .modal-content { padding: 1rem 1.2rem; overflow-y: auto; display: flex; flex-direction: column; gap: 1.2rem; }
        /* ... (Inner modal control styles unchanged) ... */
        .control-group { background-color: var(--control-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 0.8rem 1rem; box-shadow: 0 1px 3px var(--shadow); }
        .control-group h3 { margin: 0 0 0.8rem 0; font-size: 0.9rem; font-weight: 600; color: var(--primary-color); padding-bottom: 0.4rem; border-bottom: 1px solid var(--border-color); }
        label, .label-like { display: block; margin-bottom: 0.3rem; font-weight: 500; font-size: 0.85rem; color: var(--text-muted); padding-top: 0.2rem; }
        input[type="number"], select { width: 100%; padding: 0.6rem 0.75rem; margin-bottom: 0.75rem; min-height: 42px; border: 1px solid var(--input-border); border-radius: 4px; background-color: var(--input-bg); color: var(--text-color); font-size: 0.9rem; }
        button.modal-button { display: block; width: 100%; padding: 0.7rem 1.2rem; background-color: var(--primary-color); color: #ffffff; border: none; border-radius: 5px; cursor: pointer; font-size: 0.9rem; font-weight: 500; margin-top: 0.5rem; text-align: center; min-height: 42px; }
        button.modal-button:hover:not(:disabled) { background-color: var(--primary-hover); }
        .button-group { display: flex; gap: 0.75rem; }
        .button-group button { flex: 1; }
        .switch-container { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem; min-height: 40px;}
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; flex-shrink: 0; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary-color); }
        input:checked + .slider:before { transform: translateX(20px); }
        .choice-group { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.5rem; }
        .choice-group label { margin-bottom: 0; cursor: pointer; }
        .choice-group input[type="radio"], .choice-group input[type="checkbox"] { display: none; }
        .choice-group span { display: inline-flex; align-items: center; justify-content: center; padding: 0.5rem 0.8rem; border: 1px solid var(--border-color); border-radius: 4px; background-color: var(--input-bg); font-size: 0.85rem; text-align: center; min-width: 36px; min-height: 36px; }
        .choice-group span.color-preview { width: 32px; height: 32px; padding: 0; border-radius: 50%; box-shadow: inset 0 0 0 1px var(--border-color); }
        .choice-group input:checked + span { background-color: var(--primary-color); color: white; border-color: var(--primary-color); box-shadow: 0 0 0 2px var(--primary-color-light); }
        body.dark-mode .choice-group input:checked + span { box-shadow: 0 0 0 2px var(--primary-color-dark); }


        /* --- Overlays & Indicators (Z-indices checked) --- */
        #message-overlay { /* z-index: 1200 */
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.75); display: flex; justify-content: center; align-items: center;
            z-index: 1200; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s; padding: 1rem;
        }
        #message-overlay.visible { opacity: 1; visibility: visible; transition-delay: 0s; }
        #message-box { background-color: var(--panel-bg); color: var(--text-color); padding: 1.5rem 2rem; border-radius: 10px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.25); transform: scale(0.9); transition: transform 0.3s ease; width: 90%; max-width: 350px; }
        #message-overlay.visible #message-box { transform: scale(1); transition-delay: 0s;}
        #message-box h2 { margin: 0 0 1rem 0; font-size: 1.4rem; color: var(--primary-color); }
        #message-box p { margin-bottom: 1.5rem; font-size: 0.95rem; line-height: 1.5; }
        #message-box button { width: auto; padding: 0.7rem 1.8rem; font-size: 0.95rem; }
        #final-time-msg { font-weight: bold; margin-top:-0.5rem; margin-bottom: 1.5rem; display: none; }
        #final-best-time-msg { font-size: 0.85rem; color: var(--text-muted); margin-top:-1rem; margin-bottom: 1.5rem; display: none; }


        #loading-indicator { /* z-index: 1250 */
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8); color: white; padding: 1.2rem 1.5rem;
            border-radius: 8px; font-size: 1rem; z-index: 1250; text-align: center;
            opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s; pointer-events: none;
        }
        #loading-indicator.visible { opacity: 1; visibility: visible; transition-delay: 0s; }

        /* --- Minimap (Z-index checked) --- */
        #minimapContainer { /* z-index: 10 */
            position: absolute; bottom: 10px; right: 10px;
            border: 2px solid var(--minimap-border); background-color: var(--minimap-bg);
            box-shadow: 0 0 8px rgba(0,0,0,0.25); z-index: 10; display: none;
            max-width: 100px; max-height: 100px;
            transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }
        #minimapCanvas { display: block; image-rendering: pixelated; image-rendering: crisp-edges; }

        /* --- Print Styles (Unchanged) --- */
        /* ... (Print styles as before) ... */
         @media print {
             body { --transition-speed: 0s !important; }
            #bottom-nav, #settings-modal-backdrop, #settings-modal, #game-ui-overlay, #message-overlay, #loading-indicator, #minimapContainer, #fullscreenBtn { display: none !important; }
            #main-content { border: none; padding: 0; width: 100% !important; height: 100% !important; }
            #maze-container { width: 100% !important; height: auto !important; max-height: 95vh !important; padding: 0 !important; margin: 0 !important; overflow: visible !important; border: 1px solid #ccc !important; background-color: #fff !important; justify-content: flex-start !important; align-items: flex-start !important; }
             body { background-color: #fff !important; color: #000 !important; /* Force light theme vars */ --bg-color: var(--bg-color-light); --text-color: #000000; --maze-bg: #ffffff; --wall-color: #000000; --player-color: #aaaaaa; --start-color: #dddddd; --end-color: #cccccc; --wall-glow: transparent; --wall-shadow: transparent; --player-glow: transparent; --player-shadow: transparent; --wall-thickness-factor: 0.1; --player-size-factor: 0.6; --end-marker-size-factor: 0.7; }
             #mazeCanvas { position: static !important; max-width: 100% !important; height: auto !important; box-shadow: none !important; border: none !important; background-color: transparent !important; transform: none !important; left: 0 !important; top: 0 !important; }
        }

    </style>
</head>
<body data-maze-style="classic"> <!-- Initial style -->

<main id="main-content">
    <!-- In-Game UI Overlay (Timer) -->
    <div id="game-ui-overlay">
         <div class="timer-display">
            <span id="current-time">00:00</span>
        </div>
    </div>

    <!-- Maze Area -->
    <div id="maze-container">
        <canvas id="mazeCanvas"></canvas>
        <div id="minimapContainer">
            <canvas id="minimapCanvas"></canvas>
        </div>
    </div>

     <!-- Overlays for Messages and Loading -->
    <div id="message-overlay">
        <div id="message-box">
            <h2>¡Victoria!</h2>
            <p>¡Has encontrado la salida!</p>
             <p id="final-time-msg"></p>
             <p id="final-best-time-msg"></p>
            <button id="playAgainBtn">Jugar Otra Vez</button>
        </div>
    </div>
    <div id="loading-indicator">Generando...</div>

</main>

<!-- Bottom Navigation Bar -->
<nav id="bottom-nav">
    <button id="newGameBtn" title="Generar Nuevo Laberinto">
        <!-- Replace with actual SVG or font icons if desired -->
        <span class="icon">➕</span>
        <span>Nuevo</span>
    </button>
    <button id="settingsBtn" title="Abrir Ajustes">
        <span class="icon">⚙️</span>
        <span>Ajustes</span>
    </button>
</nav>

<!-- Settings Modal -->
<div id="settings-modal-backdrop"></div>
<div id="settings-modal" role="dialog" aria-labelledby="settingsModalTitle" aria-modal="true">
    <div class="modal-header">
        <h2 id="settingsModalTitle">Ajustes</h2>
        <button id="closeSettingsBtn" aria-label="Cerrar Ajustes">×</button>
    </div>
    <div class="modal-content">
        <!-- Generation Settings -->
        <div class="control-group">
            <h3>Generación</h3>
            <label for="modal-width">Ancho:</label>
            <input type="number" id="modal-width" value="15" min="5"> <!-- Max set by JS -->
            <label for="modal-height">Alto:</label>
            <input type="number" id="modal-height" value="15" min="5"> <!-- Max set by JS -->
             <p id="best-time-modal" style="font-size: 0.85rem; color: var(--text-muted); margin-top: 0.5rem; text-align: center;">Record (Actual): --:--</p>
        </div>

        <!-- Appearance Settings -->
        <div class="control-group">
            <h3>Apariencia</h3>
            <div class="switch-container">
                <label for="modal-darkModeToggle" class="label-like" style="margin-bottom: 0;">Modo Oscuro</label>
                <label class="switch">
                    <input type="checkbox" id="modal-darkModeToggle">
                    <span class="slider round"></span>
                </label>
            </div>
            <label for="modal-mazeStyle" class="label-like">Estilo Visual:</label>
            <div class="choice-group" id="modal-mazeStyle">
                 <!-- JS will sync checked state -->
                <label><input type="radio" name="modal-style" value="classic"> <span>Clásico</span></label>
                <label><input type="radio" name="modal-style" value="matrix"> <span>Matrix</span></label>
                <label><input type="radio" name="modal-style" value="blueprint"> <span>Plano</span></label>
                <label><input type="radio" name="modal-style" value="neon"> <span>Neón</span></label>
                <label><input type="radio" name="modal-style" value="cyber"> <span>Cyber</span></label>
            </div>
            <label class="label-like">Personaje:</label>
            <div class="choice-group" id="modal-playerChoice">
                 <!-- JS will sync checked state -->
                 <label title="Rojo"><input type="radio" name="modal-player" value="#e63946" data-light="#e63946" data-dark="#ff8a80"> <span class="color-preview" style="background-color: #e63946;"></span></label>
                 <label title="Azul"><input type="radio" name="modal-player" value="#1d3557" data-light="#1d3557" data-dark="#a1c4fd"> <span class="color-preview" style="background-color: #1d3557;"></span></label>
                 <label title="Verde"><input type="radio" name="modal-player" value="#588157" data-light="#588157" data-dark="#a5d6a7"> <span class="color-preview" style="background-color: #588157;"></span></label>
                 <label title="Amarillo"><input type="radio" name="modal-player" value="#ffb703" data-light="#ffb703" data-dark="#fff176"> <span class="color-preview" style="background-color: #ffb703;"></span></label>
                 <label title="Púrpura"><input type="radio" name="modal-player" value="#6a0dad" data-light="#6a0dad" data-dark="#ce93d8"> <span class="color-preview" style="background-color: #6a0dad;"></span></label>
            </div>
            <label class="label-like">Indicador Salida:</label>
            <div class="choice-group" id="modal-exitChoice">
                 <!-- JS will sync checked state -->
                <label><input type="radio" name="modal-exit" value="🏁"> <span>🏁</span></label>
                <label><input type="radio" name="modal-exit" value="★"> <span>★</span></label>
                <label><input type="radio" name="modal-exit" value="🚪"> <span>🚪</span></label>
                <label><input type="radio" name="modal-exit" value="🎯"> <span>🎯</span></label>
                <label><input type="radio" name="modal-exit" value="✅"> <span>✅</span></label>
            </div>
        </div>

        <!-- View Settings -->
         <div class="control-group">
             <h3>Vista y Otros</h3>
             <label for="modal-viewMode" class="label-like">Modo de Vista:</label>
             <div class="choice-group" id="modal-viewMode">
                  <!-- JS will sync checked state -->
                 <label><input type="radio" name="modal-view" value="overview"> <span>General</span></label>
                 <label><input type="radio" name="modal-view" value="playerCamera"> <span>Seguir</span></label>
             </div>
             <div class="button-group" style="margin-top: 1rem;">
                 <button id="modal-fullscreenBtn" class="modal-button" title="Pantalla Completa">P. Completa</button>
                 <button id="modal-printBtn" class="modal-button" title="Imprimir">Imprimir</button>
             </div>
        </div>
    </div>
</div>


<script>
    // --- Constants & Settings ---
    const MAX_MAZE_DIMENSION = 500;
    const MOBILE_MAX_MAZE_DIMENSION = 70; // Slightly larger max mobile maybe ok
    const MIN_MAZE_DIMENSION = 5;
    const CAMERA_SMOOTHING = 0.08;
    const PLAYER_SMOOTHING = 0.2;
    const GENERATION_YIELD_INTERVAL = 2500;
    const MINIMAP_MAX_SIZE = 100;
    const MINIMAP_PLAYER_DOT_SIZE = 2.5;
    const BASE_CELL_SIZE_PLAYER_VIEW = 40;
    const SWIPE_THRESHOLD = 25;

    // --- Polyfills ---
    // ... (Unchanged) ...
    if (!Element.prototype.requestFullscreen) Element.prototype.requestFullscreen = Element.prototype.mozRequestFullScreen || Element.prototype.webkitRequestFullscreen || Element.prototype.msRequestFullscreen;
    if (!document.exitFullscreen) document.exitFullscreen = document.mozCancelFullScreen || document.webkitExitFullscreen || document.msExitFullscreen;
    Object.defineProperty(document, 'fullscreenElement', { get: () => document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document._fullscreenElement });


    // --- Helper Functions ---
    // ... (Unchanged) ...
    const lerp = (a, b, t) => a + (b - a) * t;
    const clamp = (val, min, max) => Math.min(Math.max(val, min), max);
    const getCssVariable = (varName) => getComputedStyle(document.body).getPropertyValue(varName).trim();


    // --- Classes (Cell, MazeGenerator, Player, Minimap, Renderer) ---
    // PASTE THE UNMODIFIED CLASSES HERE from the previous version
    // (No changes needed in the core classes themselves)
    class Cell { constructor(x, y) { this.x = x; this.y = y; this.visited = false; this.walls = { top: true, right: true, bottom: true, left: true }; } }
    class MazeGenerator {
        constructor() { this.grid = []; this.width = 0; this.height = 0; this.start = { x: 0, y: 0 }; this.end = { x: 0, y: 0 }; this.generationComplete = false; }
        async generate(width, height, yieldCallback) {
            this.width = clamp(width, MIN_MAZE_DIMENSION, MAX_MAZE_DIMENSION); this.height = clamp(height, MIN_MAZE_DIMENSION, MAX_MAZE_DIMENSION);
            this.generationComplete = false; /* console.time(`Generation ${this.width}x${this.height}`); */
            this.grid = Array.from({ length: this.height }, (_, y) => Array.from({ length: this.width }, (_, x) => new Cell(x, y)));
            this.start = { x: 0, y: 0 }; this.end = { x: Math.max(0,this.width - 1), y: Math.max(0, this.height - 1) };
            const stack = []; let cellsProcessedSinceYield = 0; const totalCells = this.width * this.height; let visitedCells = 0;
            const startCell = this.grid[this.start.y][this.start.x]; startCell.visited = true; visitedCells++; stack.push(startCell);
            while (stack.length > 0) {
                const current = stack[stack.length - 1]; const neighbors = this.getUnvisitedNeighbors(current);
                if (neighbors.length > 0) { const next = neighbors[Math.floor(Math.random() * neighbors.length)]; this.removeWall(current, next); next.visited = true; visitedCells++; stack.push(next); } else { stack.pop(); }
                cellsProcessedSinceYield++;
                if (yieldCallback && cellsProcessedSinceYield >= GENERATION_YIELD_INTERVAL) {
                    await new Promise(resolve => setTimeout(resolve, 0)); const progress = visitedCells / totalCells; yieldCallback(progress); cellsProcessedSinceYield = 0;
                }
            }
            if (yieldCallback) yieldCallback(1); this.generationComplete = true; /* console.timeEnd(`Generation ${this.width}x${this.height}`); */ return this;
        }
        getUnvisitedNeighbors(cell) { const neighbors = []; const { x, y } = cell; const check = (nx, ny) => { if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height && !this.grid[ny][nx].visited) { neighbors.push(this.grid[ny][nx]); } }; check(x, y - 1); check(x + 1, y); check(x, y + 1); check(x - 1, y); return neighbors; }
        removeWall(a, b) { const dx = a.x - b.x; const dy = a.y - b.y; if (dx === 1) { a.walls.left = false; b.walls.right = false; } else if (dx === -1) { a.walls.right = false; b.walls.left = false; } if (dy === 1) { a.walls.top = false; b.walls.bottom = false; } else if (dy === -1) { a.walls.bottom = false; b.walls.top = false; } }
    }
    class Player {
        constructor(x, y, color) { this.x = x; this.y = y; this.targetX = x; this.targetY = y; this.pixelX = x; this.pixelY = y; this.color = color; this.isMoving = false; }
        moveTo(newX, newY) { this.targetX = newX; this.targetY = newY; if (Math.abs(this.targetX - this.pixelX) > 0.01 || Math.abs(this.targetY - this.pixelY) > 0.01) { this.isMoving = true; } }
        update(deltaTime) { if (!this.isMoving) return; this.pixelX = lerp(this.pixelX, this.targetX, PLAYER_SMOOTHING); this.pixelY = lerp(this.pixelY, this.targetY, PLAYER_SMOOTHING); if (Math.abs(this.pixelX - this.targetX) < 0.01 && Math.abs(this.pixelY - this.targetY) < 0.01) { this.pixelX = this.targetX; this.pixelY = this.targetY; this.x = this.targetX; this.y = this.targetY; this.isMoving = false; } }
        canMove(dx, dy, maze) { if (this.isMoving) return false; const currentX = this.x; const currentY = this.y; const nextX = currentX + dx; const nextY = currentY + dy; if (nextX < 0 || nextX >= maze.width || nextY < 0 || nextY >= maze.height) return false; const currentCell = maze.grid[currentY]?.[currentX]; if (!currentCell) return false; if (dx === 1 && currentCell.walls.right) return false; if (dx === -1 && currentCell.walls.left) return false; if (dy === 1 && currentCell.walls.bottom) return false; if (dy === -1 && currentCell.walls.top) return false; return { newX: nextX, newY: nextY }; }
        setColor(color) { this.color = color; }
    }
    class Minimap {
         constructor(canvasId, containerId) { this.container = document.getElementById(containerId); this.canvas = document.getElementById(canvasId); this.ctx = this.canvas.getContext('2d', { alpha: false }); this.maze = null; this.player = null; this.size = MINIMAP_MAX_SIZE; this.cellWidth = 1; this.cellHeight = 1; this.wallColor = '#000'; this.playerColor = '#f00'; this.bgColor = 'rgba(255, 255, 255, 0.7)'; this.borderColor = '#888'; this.visible = false; this.offscreenCanvas = document.createElement('canvas'); this.offscreenCtx = this.offscreenCanvas.getContext('2d', { alpha: false }); this.needsRedraw = true; }
         updateSource(maze, player) { this.maze = maze; this.player = player; this.needsRedraw = true; this.updateColors(); if (this.maze && this.maze.generationComplete) { this.calculateDimensions(); } }
         updateColors() { this.wallColor = getCssVariable('--wall-color'); this.playerColor = getCssVariable('--minimap-player'); this.bgColor = getCssVariable('--minimap-bg'); this.borderColor = getCssVariable('--minimap-border'); this.container.style.backgroundColor = this.bgColor; this.container.style.borderColor = this.borderColor; this.needsRedraw = true; }
         calculateDimensions() { if (!this.maze || !this.container) return; const aspect = this.maze.width / this.maze.height; let mapW, mapH; const maxSize = parseInt(getComputedStyle(this.container).maxWidth) || MINIMAP_MAX_SIZE; if (aspect > 1) { mapW = maxSize; mapH = Math.max(1, Math.floor(maxSize / aspect)); } else { mapH = maxSize; mapW = Math.max(1, Math.floor(maxSize * aspect)); } if (this.canvas.width !== mapW || this.canvas.height !== mapH) { this.canvas.width = mapW; this.canvas.height = mapH; this.offscreenCanvas.width = mapW; this.offscreenCanvas.height = mapH; this.cellWidth = mapW / this.maze.width; this.cellHeight = mapH / this.maze.height; this.needsRedraw = true; } this.container.style.width = `${mapW}px`; this.container.style.height = `${mapH}px`; }
         show() { if (!this.visible) { this.container.style.display = 'block'; this.visible = true; if (this.maze && this.maze.generationComplete) { this.calculateDimensions(); this.draw(); } } }
         hide() { if (this.visible) { this.container.style.display = 'none'; this.visible = false; } }
         draw() { if (!this.visible || !this.maze || !this.player || !this.maze.generationComplete) { this.hide(); return; } if (this.needsRedraw) { this.drawMazeToOffscreen(); this.needsRedraw = false; } this.ctx.drawImage(this.offscreenCanvas, 0, 0); this.ctx.fillStyle = this.playerColor; const playerX = this.player.pixelX * this.cellWidth; const playerY = this.player.pixelY * this.cellHeight; this.ctx.beginPath(); this.ctx.arc(playerX + this.cellWidth / 2, playerY + this.cellHeight / 2, MINIMAP_PLAYER_DOT_SIZE, 0, Math.PI * 2); this.ctx.fill(); }
         drawMazeToOffscreen() { if (!this.maze) return; const ctx = this.offscreenCtx; const width = this.offscreenCanvas.width; const height = this.offscreenCanvas.height; ctx.fillStyle = this.bgColor; ctx.fillRect(0, 0, width, height); ctx.strokeStyle = this.wallColor; ctx.lineWidth = Math.max(1, Math.min(this.cellWidth, this.cellHeight) * 0.1); ctx.beginPath(); for (let y = 0; y < this.maze.height; y++) { for (let x = 0; x < this.maze.width; x++) { const cell = this.maze.grid[y]?.[x]; if (!cell) continue; const cx = x * this.cellWidth; const cy = y * this.cellHeight; const cew = cx + this.cellWidth; const ceh = cy + this.cellHeight; if (cell.walls.bottom) { ctx.moveTo(cx, ceh); ctx.lineTo(cew, ceh); } if (cell.walls.right) { ctx.moveTo(cew, cy); ctx.lineTo(cew, ceh); } } } ctx.moveTo(0, 0); ctx.lineTo(width, 0); ctx.moveTo(0, 0); ctx.lineTo(0, height); ctx.stroke(); }
    }
    class Renderer {
         constructor(canvasId, mazeContainerId) { this.canvas = document.getElementById(canvasId); this.container = document.getElementById(mazeContainerId); this.ctx = this.canvas.getContext('2d', { alpha: false }); this.maze = null; this.player = null; this.minimap = null; this.cellSize = 20; this.viewMode = 'overview'; this.isPrinting = false; this.cameraX = 0; this.cameraY = 0; this.targetCameraX = 0; this.targetCameraY = 0; this.wallCanvas = document.createElement('canvas'); this.wallCtx = this.wallCanvas.getContext('2d', { alpha: true }); this.needsWallRedraw = true; this.wallColor = '#000'; this.bgColor = '#fff'; this.startColor = '#afa'; this.endColor = '#aaf'; this.exitMarker = '🏁'; this.wallThicknessFactor = 0.1; this.playerSizeFactor = 0.6; this.endMarkerSizeFactor = 0.7; this.resizeTimeout = null; window.addEventListener('resize', () => { clearTimeout(this.resizeTimeout); this.resizeTimeout = setTimeout(() => this.handleResize(), 150); }); }
         setMaze(maze) { this.maze = maze; this.needsWallRedraw = true; this.resetCamera(); this.handleResize(); }
         setPlayer(player) { this.player = player; this.resetCamera(); }
         setMinimap(minimap) { this.minimap = minimap; }
         // Added forceRedraw parameter
         updateStyleSettings(forceRedraw = false) {
             const newWallColor = getCssVariable('--wall-color'); const newBgColor = getCssVariable('--maze-bg'); const newStartColor = getCssVariable('--start-color'); const newEndColor = getCssVariable('--end-color'); const newWallThickness = parseFloat(getCssVariable('--wall-thickness-factor')); const newPlayerSize = parseFloat(getCssVariable('--player-size-factor')); const newEndMarkerSize = parseFloat(getCssVariable('--end-marker-size-factor'));
             // Check if any relevant visual property changed OR if forced
             if (forceRedraw || newWallColor !== this.wallColor || newBgColor !== this.bgColor || newStartColor !== this.startColor || newEndColor !== this.endColor || newWallThickness !== this.wallThicknessFactor || newPlayerSize !== this.playerSizeFactor || newEndMarkerSize !== this.endMarkerSizeFactor) {
                 this.wallColor = newWallColor; this.bgColor = newBgColor; this.startColor = newStartColor; this.endColor = newEndColor; this.wallThicknessFactor = newWallThickness; this.playerSizeFactor = newPlayerSize; this.endMarkerSizeFactor = newEndMarkerSize;
                 this.canvas.style.backgroundColor = this.bgColor; // Might not be needed if canvas draws bg
                 this.needsWallRedraw = true; // Force static redraw
                 if (this.minimap) this.minimap.updateColors(); // Update minimap colors too
             }
         }
         setExitMarker(marker) { if (this.exitMarker !== marker) { this.exitMarker = marker; this.needsWallRedraw = true; } }
         setViewMode(mode) {
             if (this.viewMode !== mode) {
                 this.viewMode = mode;
                 this.handleResize();
                 // Mostrar/ocultar minimapa solo en modo cámara del jugador
                 if (this.minimap) {
                     if (mode === 'playerCamera') {
                         this.minimap.show();
                         this.minimap.needsRedraw = true;
                         this.minimap.draw();
                     } else {
                         this.minimap.hide();
                     }
                 }
             }
         }
         resetCamera() { if (!this.maze || !this.player) return; const initialCamX = (this.player.x + 0.5) * this.cellSize; const initialCamY = (this.player.y + 0.5) * this.cellSize; this.cameraX = this.targetCameraX = initialCamX; this.cameraY = this.targetCameraY = initialCamY; if (this.viewMode === 'playerCamera') { this.applyCameraTransform(); } }
         handleResize() { if (!this.maze || !this.container) return; const containerWidth = this.container.clientWidth; const containerHeight = this.container.clientHeight; if (containerWidth === 0 || containerHeight === 0) return; if (this.viewMode === 'overview') { const cellW = containerWidth / this.maze.width; const cellH = containerHeight / this.maze.height; this.cellSize = Math.max(1, Math.floor(Math.min(cellW, cellH))); const totalMazeWidth = this.maze.width * this.cellSize; const totalMazeHeight = this.maze.height * this.cellSize; this.canvas.width = totalMazeWidth; this.canvas.height = totalMazeHeight; this.canvas.style.width = `${totalMazeWidth}px`; this.canvas.style.height = `${totalMazeHeight}px`; this.canvas.style.left = `${(containerWidth - totalMazeWidth) / 2}px`; this.canvas.style.top = `${(containerHeight - totalMazeHeight) / 2}px`; this.canvas.style.transform = ''; } else { this.cellSize = Math.max(15, Math.min(60, BASE_CELL_SIZE_PLAYER_VIEW)); const totalMazeWidth = this.maze.width * this.cellSize; const totalMazeHeight = this.maze.height * this.cellSize; this.canvas.width = totalMazeWidth; this.canvas.height = totalMazeHeight; this.canvas.style.width = `${totalMazeWidth}px`; this.canvas.style.height = `${totalMazeHeight}px`; this.canvas.style.left = '0px'; this.canvas.style.top = '0px'; this.resetCamera(); this.applyCameraTransform(); } this.needsWallRedraw = true; if(this.minimap) { this.minimap.calculateDimensions(); this.minimap.needsRedraw = true; } this.drawFrame(); }
         updateCamera(deltaTime) { if (this.viewMode !== 'playerCamera' || !this.player || !this.maze) return; this.targetCameraX = (this.player.pixelX + 0.5) * this.cellSize; this.targetCameraY = (this.player.pixelY + 0.5) * this.cellSize; this.cameraX = lerp(this.cameraX, this.targetCameraX, CAMERA_SMOOTHING); this.cameraY = lerp(this.cameraY, this.targetCameraY, CAMERA_SMOOTHING); }
         applyCameraTransform() { if (this.viewMode !== 'playerCamera' || !this.container) return; const containerWidth = this.container.clientWidth; const containerHeight = this.container.clientHeight; const viewOffsetX = containerWidth / 2 - this.cameraX; const viewOffsetY = containerHeight / 2 - this.cameraY; this.canvas.style.transform = `translate(${viewOffsetX}px, ${viewOffsetY}px)`; }
         drawFrame() { if (!this.maze || !this.player || !this.maze.generationComplete || this.isPrinting) return; this.updateStyleSettings(); if (this.viewMode === 'playerCamera') { this.updateCamera(); this.applyCameraTransform(); } if (this.needsWallRedraw) { this.drawWallsToOffscreen(); this.needsWallRedraw = false; } this.ctx.fillStyle = this.bgColor; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.drawImage(this.wallCanvas, 0, 0); const ctx = this.ctx; ctx.fillStyle = this.player.color; const playerSize = this.cellSize * this.playerSizeFactor; const playerRenderX = this.player.pixelX * this.cellSize; const playerRenderY = this.player.pixelY * this.cellSize; const playerCenterX = playerRenderX + this.cellSize / 2; const playerCenterY = playerRenderY + this.cellSize / 2; const playerRadius = playerSize / 2; const playerGlow = getCssVariable('--player-glow'); const playerShadow = getCssVariable('--player-shadow'); if (playerGlow && playerGlow !== 'none' && playerGlow !== 'transparent') { ctx.shadowColor = playerGlow; ctx.shadowBlur = Math.max(5, this.cellSize * 0.2); ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; ctx.beginPath(); ctx.arc(playerCenterX, playerCenterY, playerRadius, 0, Math.PI * 2); ctx.fill(); } ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.beginPath(); ctx.arc(playerCenterX, playerCenterY, playerRadius, 0, Math.PI * 2); ctx.fill(); if (playerShadow && playerShadow !== 'none' && playerShadow !== 'transparent') { ctx.shadowColor = playerShadow; ctx.shadowBlur = Math.max(3, this.cellSize * 0.1); ctx.shadowOffsetX = -1; ctx.shadowOffsetY = -1; ctx.fill(); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; } if (this.viewMode === 'playerCamera' && this.minimap) { this.minimap.draw(); } }
         drawWallsToOffscreen() { if (!this.maze || !this.canvas.width || !this.canvas.height) return; this.wallCanvas.width = this.canvas.width; this.wallCanvas.height = this.canvas.height; const ctx = this.wallCtx; ctx.clearRect(0, 0, this.wallCanvas.width, this.wallCanvas.height); ctx.fillStyle = this.startColor; ctx.fillRect(this.maze.start.x * this.cellSize, this.maze.start.y * this.cellSize, this.cellSize, this.cellSize); ctx.fillStyle = this.endColor; ctx.fillRect(this.maze.end.x * this.cellSize, this.maze.end.y * this.cellSize, this.cellSize, this.cellSize); ctx.strokeStyle = this.wallColor; ctx.lineWidth = Math.max(1, this.cellSize * this.wallThicknessFactor); ctx.lineCap = 'round'; ctx.lineJoin = 'round'; const wallGlow = getCssVariable('--wall-glow'); if (wallGlow && wallGlow !== 'none' && wallGlow !== 'transparent') { ctx.shadowColor = wallGlow; ctx.shadowBlur = Math.max(3, this.cellSize * 0.15); ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1; } ctx.beginPath(); for (let y = 0; y < this.maze.height; y++) { for (let x = 0; x < this.maze.width; x++) { const cell = this.maze.grid[y]?.[x]; if (!cell) continue; const cx = x * this.cellSize; const cy = y * this.cellSize; const cew = cx + this.cellSize; const ceh = cy + this.cellSize; if (cell.walls.top) { ctx.moveTo(cx, cy); ctx.lineTo(cew, cy); } if (cell.walls.right) { ctx.moveTo(cew, cy); ctx.lineTo(cew, ceh); } if (cell.walls.bottom) { ctx.moveTo(cew, ceh); ctx.lineTo(cx, ceh); } if (cell.walls.left) { ctx.moveTo(cx, ceh); ctx.lineTo(cx, cy); } } } ctx.stroke(); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; if (this.exitMarker) { const markerSize = this.cellSize * this.endMarkerSizeFactor; const markerX = this.maze.end.x * this.cellSize + this.cellSize / 2; const markerY = this.maze.end.y * this.cellSize + this.cellSize / 2; ctx.font = `${markerSize * 0.8}px ${getCssVariable('--font-family')}`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = this.wallColor; ctx.fillText(this.exitMarker, markerX, markerY); } }
         prepareForPrint() { if (!this.maze || !this.player) return null; this.isPrinting = true; const currentViewMode = this.viewMode; this.setViewMode('overview'); const PRINT_RESOLUTION_BASE = 2000; const aspect = this.maze.width / this.maze.height; let printCellSize = (aspect > 1) ? Math.max(1, Math.floor(PRINT_RESOLUTION_BASE / this.maze.width)) : Math.max(1, Math.floor(PRINT_RESOLUTION_BASE / this.maze.height)); const printCanvasWidth = this.maze.width * printCellSize; const printCanvasHeight = this.maze.height * printCellSize; const oldW = this.canvas.width; const oldH = this.canvas.height; const oldCellSize = this.cellSize; const oldStyles = { width: this.canvas.style.width, height: this.canvas.style.height, left: this.canvas.style.left, top: this.canvas.style.top, transform: this.canvas.style.transform, backgroundColor: this.canvas.style.backgroundColor }; this.canvas.width = printCanvasWidth; this.canvas.height = printCanvasHeight; this.cellSize = printCellSize; this.wallColor = '#000000'; this.bgColor = '#ffffff'; this.startColor = '#dddddd'; this.endColor = '#cccccc'; this.playerColor = '#aaaaaa'; this.wallThicknessFactor = 0.1; this.playerSizeFactor = 0.6; this.endMarkerSizeFactor = 0.7; this.wallCtx.shadowColor = 'transparent'; this.ctx.shadowColor = 'transparent'; this.drawWallsToOffscreen(); const ctx = this.ctx; ctx.fillStyle = this.bgColor; ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); ctx.drawImage(this.wallCanvas, 0, 0); const playerSize = this.cellSize * this.playerSizeFactor; ctx.fillStyle = this.playerColor; ctx.beginPath(); ctx.arc(this.player.x * this.cellSize + this.cellSize / 2, this.player.y * this.cellSize + this.cellSize / 2, playerSize / 2, 0, Math.PI * 2); ctx.fill(); return { oldW, oldH, oldCellSize, oldStyles, currentViewMode }; }
         restoreAfterPrint(savedState) { if (!savedState) return; this.canvas.width = savedState.oldW; this.canvas.height = savedState.oldH; this.cellSize = savedState.oldCellSize; this.canvas.style.width = savedState.oldStyles.width; this.canvas.style.height = savedState.oldStyles.height; this.canvas.style.left = savedState.oldStyles.left; this.canvas.style.top = savedState.oldStyles.top; this.canvas.style.transform = savedState.oldStyles.transform; this.canvas.style.backgroundColor = savedState.oldStyles.backgroundColor; this.isPrinting = false; this.updateStyleSettings(true); /* Force redraw after print */ this.setViewMode(savedState.currentViewMode); /* This redraws */ }
    }


    // --- Game Controller Logic ---
    class Game {
        constructor() {
             // ... (Initialization como antes) ...
             this.mazeGenerator = new MazeGenerator();
             this.renderer = new Renderer('mazeCanvas', 'maze-container');
             this.minimap = new Minimap('minimapCanvas', 'minimapContainer');
             this.renderer.setMinimap(this.minimap);
             this.player = null;
             this.gameActive = false; this.lastTimestamp = 0; this.animationFrameId = null; this.isLoading = false;
             this.gameStartTime = 0; this.gameTimer = null; this.currentTime = 0; this.timerStarted = false;
             this.bestTimes = JSON.parse(localStorage.getItem('mazeBestTimes') || '{}');
             this.touchStartX = 0; this.touchStartY = 0; this.touchEndX = 0; this.touchEndY = 0;

             // References to modal controls
             this.widthInput = document.getElementById('modal-width');
             this.heightInput = document.getElementById('modal-height');
             this.darkModeToggle = document.getElementById('modal-darkModeToggle');
             this.mazeStyleGroup = document.getElementById('modal-mazeStyle');
             this.playerChoiceGroup = document.getElementById('modal-playerChoice');
             this.exitChoiceGroup = document.getElementById('modal-exitChoice');
             this.viewModeGroup = document.getElementById('modal-viewMode');

             this.bindUI();
             this.applyInitialSettings();
             this.startNewGame();
        }

         bindUI() {
             // ... (Bindings como antes, asegurándose de que los listeners de modal estén correctos) ...
             document.getElementById('newGameBtn').addEventListener('click', () => this.startNewGame());
             document.getElementById('settingsBtn').addEventListener('click', () => this.openSettingsModal());
             document.getElementById('closeSettingsBtn').addEventListener('click', () => this.closeSettingsModal());
             document.getElementById('settings-modal-backdrop').addEventListener('click', () => this.closeSettingsModal());
             this.widthInput.addEventListener('input', this.validateDimensions);
             this.heightInput.addEventListener('input', this.validateDimensions);
             this.darkModeToggle.addEventListener('change', (e) => this.setDarkMode(e.target.checked));
             this.mazeStyleGroup.addEventListener('change', (e) => this.setMazeStyle(e.target.value));
             this.playerChoiceGroup.addEventListener('change', (e) => this.updatePlayerColor(e.target));
             this.exitChoiceGroup.addEventListener('change', (e) => this.renderer.setExitMarker(e.target.value));
             this.viewModeGroup.addEventListener('change', (e) => this.renderer.setViewMode(e.target.value));
             document.getElementById('modal-fullscreenBtn').addEventListener('click', this.toggleFullscreen);
             document.getElementById('modal-printBtn').addEventListener('click', () => this.handlePrint());
             document.getElementById('playAgainBtn').addEventListener('click', () => { this.hideMessage(); this.startNewGame(); });
             document.addEventListener('keydown', (e) => this.handleKeyDown(e));
             const mazeContainer = document.getElementById('maze-container');
             mazeContainer.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
             mazeContainer.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
             mazeContainer.addEventListener('touchend', (e) => this.handleTouchEnd(e));
             mazeContainer.addEventListener('touchcancel', (e) => this.handleTouchEnd(e));
             document.addEventListener('fullscreenchange', this.handleFullscreenChange.bind(this));
             document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange.bind(this));
             document.addEventListener('mozfullscreenchange', this.handleFullscreenChange.bind(this));
             document.addEventListener('MSFullscreenChange', this.handleFullscreenChange.bind(this));
         }

         openSettingsModal() { /* ... (Unchanged) ... */
            this.syncModalControls();
            document.getElementById('settings-modal-backdrop').classList.add('visible');
            document.getElementById('settings-modal').classList.add('visible');
            document.getElementById('settingsBtn').classList.add('active');
         }
         closeSettingsModal() { /* ... (Unchanged) ... */
            document.getElementById('settings-modal-backdrop').classList.remove('visible');
            document.getElementById('settings-modal').classList.remove('visible');
            document.getElementById('settingsBtn').classList.remove('active');
         }
         syncModalControls() { /* ... (Unchanged - syncs controls with current state) ... */
             this.widthInput.value = this.mazeGenerator?.width || this.widthInput.value;
             this.heightInput.value = this.mazeGenerator?.height || this.heightInput.value;
             this.validateDimensions();
             this.darkModeToggle.checked = document.body.classList.contains('dark-mode');
             const currentStyle = document.body.dataset.mazeStyle || 'classic';
             const styleRadio = document.querySelector(`#modal-mazeStyle input[value="${currentStyle}"]`);
             if (styleRadio) styleRadio.checked = true;
             else document.querySelector('#modal-mazeStyle input').checked = true; // Default

             const currentPlayerColorVal = this.getCurrentPlayerColor(true); // Get base value
             const playerRadio = document.querySelector(`#modal-playerChoice input[value="${currentPlayerColorVal}"]`);
             if (playerRadio) playerRadio.checked = true;
             else document.querySelector('#modal-playerChoice input').checked = true; // Default

             const currentExit = this.renderer.exitMarker || '🏁';
             const exitRadio = document.querySelector(`#modal-exitChoice input[value="${currentExit}"]`);
             if (exitRadio) exitRadio.checked = true;
             else document.querySelector('#modal-exitChoice input').checked = true; // Default

             const currentView = this.renderer.viewMode || 'overview';
             const viewRadio = document.querySelector(`#modal-viewMode input[value="${currentView}"]`);
             if (viewRadio) viewRadio.checked = true;
             else document.querySelector('#modal-viewMode input').checked = true; // Default

             this.updateBestTimeDisplay(this.mazeGenerator.width && this.mazeGenerator.height ? `${this.mazeGenerator.width}x${this.mazeGenerator.height}` : '0x0', true);
         }

         applyInitialSettings() { /* ... (Unchanged - sets initial state based on modal) ... */
             const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
             this.setDarkMode(prefersDark); // Apply initial theme first
             this.widthInput.max = MOBILE_MAX_MAZE_DIMENSION;
             this.heightInput.max = MOBILE_MAX_MAZE_DIMENSION;
             this.widthInput.value = clamp(parseInt(this.widthInput.value || 15), MIN_MAZE_DIMENSION, MOBILE_MAX_MAZE_DIMENSION);
             this.heightInput.value = clamp(parseInt(this.heightInput.value || 15), MIN_MAZE_DIMENSION, MOBILE_MAX_MAZE_DIMENSION);
             this.syncModalControls(); // Sync modal to defaults/prefs
             this.applySettingsFromModal(); // Apply these synced settings to the game
             this.validateDimensions();
         }

         validateDimensions() { /* ... (Unchanged) ... */
            const maxDim = MOBILE_MAX_MAZE_DIMENSION; this.widthInput.max = maxDim; this.heightInput.max = maxDim;
            this.widthInput.value = clamp(parseInt(this.widthInput.value || MIN_MAZE_DIMENSION, 10), MIN_MAZE_DIMENSION, maxDim);
            this.heightInput.value = clamp(parseInt(this.heightInput.value || MIN_MAZE_DIMENSION, 10), MIN_MAZE_DIMENSION, maxDim);
            this.updateBestTimeDisplay(`${this.widthInput.value}x${this.heightInput.value}`, true);
         }

         // --- Timer Methods ---
         startTimer() { /* ... (Unchanged) ... */
             if (this.timerStarted) return; this.timerStarted = true; this.gameStartTime = Date.now(); this.currentTime = 0;
             this.updateTimerDisplay(); clearInterval(this.gameTimer);
             this.gameTimer = setInterval(() => { this.currentTime = Math.floor((Date.now() - this.gameStartTime) / 1000); this.updateTimerDisplay(); }, 100);
         }
         resetTimer() { /* ... (Unchanged) ... */
             clearInterval(this.gameTimer); this.gameTimer = null; this.timerStarted = false; this.currentTime = 0; this.updateTimerDisplay();
         }
         stopTimer() { /* ... (Unchanged) ... */
             clearInterval(this.gameTimer); const finalTime = this.currentTime;
             const mazeSize = `${this.mazeGenerator.width}x${this.mazeGenerator.height}`; let isNewBest = false;
             if (!this.bestTimes[mazeSize] || finalTime < this.bestTimes[mazeSize]) { this.bestTimes[mazeSize] = finalTime; localStorage.setItem('mazeBestTimes', JSON.stringify(this.bestTimes)); isNewBest = true; this.updateBestTimeDisplay(mazeSize, true); }
             return { time: finalTime, isNewBest: isNewBest };
         }
         updateTimerDisplay() { /* ... (Unchanged) ... */
             const minutes = Math.floor(this.currentTime / 60); const seconds = this.currentTime % 60; document.getElementById('current-time').textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
         }
         updateBestTimeDisplay(mazeSize, targetModal = false) { /* ... (Unchanged) ... */
             const bestTime = this.bestTimes[mazeSize]; let timeStr = '--:--'; if (bestTime !== undefined) { const minutes = Math.floor(bestTime / 60); const seconds = bestTime % 60; timeStr = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; }
             if (targetModal) { const bestTimeEl = document.getElementById('best-time-modal'); if (bestTimeEl) { bestTimeEl.textContent = `Record (${mazeSize === '0x0' ? 'Actual' : mazeSize}): ${timeStr}`; } }
         }

         async startNewGame() { /* ... (Unchanged logic, just ensures settings applied) ... */
             this.closeSettingsModal(); if (this.isLoading) return; this.isLoading = true; this.gameActive = false; document.getElementById('newGameBtn').disabled = true;
             if (this.animationFrameId) { cancelAnimationFrame(this.animationFrameId); this.animationFrameId = null; }
             this.showLoading(true, 'Generando...'); this.hideMessage(); this.validateDimensions();
             const width = parseInt(this.widthInput.value); const height = parseInt(this.heightInput.value);
             try {
                 const maze = await this.mazeGenerator.generate(width, height, (progress) => { this.showLoading(true, `Generando... ${Math.round(progress * 100)}%`); });
                 if (!maze || !maze.grid) throw new Error("Maze generation failed.");
                 this.renderer.setMaze(maze);
                 const playerColor = this.getCurrentPlayerColor(); // Get color based on modal selection & theme
                 this.player = new Player(maze.start.x, maze.start.y, playerColor);
                 this.renderer.setPlayer(this.player);
                 this.minimap.updateSource(maze, this.player);
                 this.applySettingsFromModal(); // Apply style/view settings from modal *before* first draw
                 this.renderer.resetCamera();
                 this.renderer.needsWallRedraw = true; this.renderer.drawFrame();
                 this.gameActive = true; this.lastTimestamp = performance.now(); this.resetTimer();
                 const currentMazeSize = `${maze.width}x${maze.height}`; this.updateBestTimeDisplay(currentMazeSize, true);
                 this.gameLoop();
             } catch (error) { console.error("Error:", error); this.showMessage("Error", "Error al generar: " + error.message); this.gameActive = false; }
             finally { this.showLoading(false); this.isLoading = false; document.getElementById('newGameBtn').disabled = false; }
         }

         applySettingsFromModal() { /* ... (Unchanged) ... */
            this.setDarkMode(this.darkModeToggle.checked);
            this.setMazeStyle(document.querySelector('#modal-mazeStyle input:checked').value);
            this.updatePlayerColor(document.querySelector('#modal-playerChoice input:checked'));
            this.renderer.setExitMarker(document.querySelector('#modal-exitChoice input:checked').value);
            this.renderer.setViewMode(document.querySelector('#modal-viewMode input:checked').value);
         }

         gameLoop(timestamp = 0) { /* ... (Unchanged) ... */
             if (!this.gameActive && !this.player?.isMoving && !this.isLoading) { this.animationFrameId = null; return; } const deltaTime = timestamp - this.lastTimestamp; this.lastTimestamp = timestamp; if (this.gameActive || this.player?.isMoving) { this.player?.update(deltaTime); } this.renderer.drawFrame(); this.animationFrameId = requestAnimationFrame((ts) => this.gameLoop(ts));
         }

         handleMoveAttempt(dx, dy) {
            if (!this.gameActive || !this.player || this.isLoading || this.player.isMoving) return;
            const moveResult = this.player.canMove(dx, dy, this.mazeGenerator);
            if (moveResult) {
                if (!this.timerStarted) { this.startTimer(); }
                this.player.moveTo(moveResult.newX, moveResult.newY);
                
                if (!this.animationFrameId && !this.isLoading) {
                    this.lastTimestamp = performance.now();
                    this.gameLoop();
                }
                
                // Check for maze completion
                if (moveResult.newX === this.mazeGenerator.end.x && moveResult.newY === this.mazeGenerator.end.y) {
                    this.gameActive = false;
                    const finalTimeResult = this.stopTimer();
                    
                    // Wait for player movement animation to complete
                    setTimeout(() => {
                        if (this.player && this.player.x === this.mazeGenerator.end.x && this.player.y === this.mazeGenerator.end.y) {
                            const minutes = Math.floor(finalTimeResult.time / 60);
                            const seconds = finalTimeResult.time % 60;
                            const timeStr = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                            const mazeSize = `${this.mazeGenerator.width}x${this.mazeGenerator.height}`;
                            
                            // Show different messages for new records vs normal completion
                            if (finalTimeResult.isNewBest) {
                                this.showMessage(
                                    "¡Nuevo Récord! 🏆",
                                    "¡Increíble! Has superado el récord anterior.",
                                    timeStr,
                                    `Nuevo récord (${mazeSize}): ${timeStr}`
                                );
                            } else {
                                const bestTime = this.bestTimes[mazeSize];
                                const bestTimeStr = bestTime !== undefined ? 
                                    `${Math.floor(bestTime / 60)}:${(bestTime % 60).toString().padStart(2, '0')}` : 
                                    '--:--';
                                
                                this.showMessage(
                                    "¡Completado! 🎉",
                                    "Has encontrado la salida del laberinto.",
                                    timeStr,
                                    `Mejor tiempo (${mazeSize}): ${bestTimeStr}`
                                );
                            }
                        }
                    }, PLAYER_SMOOTHING * 500 + 50); // Wait for movement animation
                }
            }
         }

         // --- Input Handling ---
         handleKeyDown(e) { /* ... (Unchanged) ... */
              if (document.getElementById('settings-modal').classList.contains('visible')) return; let dx = 0; let dy = 0; switch (e.key) { case 'ArrowUp': case 'w': case 'W': dy = -1; break; case 'ArrowDown': case 's': case 'S': dy = 1; break; case 'ArrowLeft': case 'a': case 'A': dx = -1; break; case 'ArrowRight': case 'd': case 'D': dx = 1; break; default: return; } e.preventDefault(); this.handleMoveAttempt(dx, dy);
         }
         handleTouchStart(e) { /* ... (Unchanged) ... */
             if (document.getElementById('settings-modal').classList.contains('visible')) return; if (e.touches.length !== 1) return; e.preventDefault(); this.touchStartX = e.touches[0].clientX; this.touchStartY = e.touches[0].clientY; this.touchEndX = this.touchStartX; this.touchEndY = this.touchStartY;
         }
         handleTouchMove(e) { /* ... (Unchanged) ... */
              if (document.getElementById('settings-modal').classList.contains('visible')) return; if (e.touches.length !== 1) return; e.preventDefault(); this.touchEndX = e.touches[0].clientX; this.touchEndY = e.touches[0].clientY;
         }
         handleTouchEnd(e) { /* ... (Unchanged) ... */
             if (document.getElementById('settings-modal').classList.contains('visible')) return; const deltaX = this.touchEndX - this.touchStartX; const deltaY = this.touchEndY - this.touchStartY; const absDeltaX = Math.abs(deltaX); const absDeltaY = Math.abs(deltaY); let dx = 0; let dy = 0; if (Math.max(absDeltaX, absDeltaY) > SWIPE_THRESHOLD) { if (absDeltaX > absDeltaY) { dx = deltaX > 0 ? 1 : -1; } else { dy = deltaY > 0 ? 1 : -1; } this.handleMoveAttempt(dx, dy); } this.touchStartX = 0; this.touchStartY = 0; this.touchEndX = 0; this.touchEndY = 0;
         }

          // --- UI Update Methods ---
          setDarkMode(isDark) { /* ... (Unchanged - targets body class) ... */
              document.body.classList.toggle('dark-mode', isDark);
              this.updatePlayerColorVisuals(isDark); // Update previews in modal
              if (this.renderer && this.mazeGenerator.generationComplete) {
                 this.renderer.updateStyleSettings(true); // Force redraw on theme change
                 this.renderer.drawFrame();
              }
          }
           // Updated setMazeStyle to force renderer update
           setMazeStyle(styleName, forceUpdate = false) {
                const currentStyle = document.body.dataset.mazeStyle;
                if (!forceUpdate && currentStyle === styleName) return;
                console.log("Setting maze style:", styleName); // Debug log
                document.body.dataset.mazeStyle = styleName;
                this.updatePlayerColorVisuals(document.body.classList.contains('dark-mode'));
                if (this.renderer) {
                    this.renderer.updateStyleSettings(true); // Force redraw of static elements
                    // Re-apply marker just in case its color depends on style
                    this.renderer.setExitMarker(document.querySelector('#modal-exitChoice input:checked').value);
                    if (this.mazeGenerator.generationComplete) {
                        this.renderer.drawFrame(); // Trigger immediate visual update
                    } else {
                         console.log("Draw skipped, maze not generated yet."); // Debug log
                    }
                }
           }
          updatePlayerColor(radioElement) { /* ... (Unchanged) ... */
             if (!radioElement || !radioElement.checked) return; const newColor = this.getCurrentPlayerColor(); if (this.player) { this.player.setColor(newColor); } if(this.renderer) { this.renderer.updateStyleSettings(true); /* Update + force redraw */ if (this.mazeGenerator.generationComplete) this.renderer.drawFrame(); }
          }
          updatePlayerColorVisuals(isDark) { /* ... (Unchanged - targets modal) ... */
              const playerRadios = document.querySelectorAll('#modal-playerChoice input[type="radio"]'); playerRadios.forEach(radio => { const lightColor = radio.dataset.light; const darkColor = radio.dataset.dark; const colorToShow = isDark ? darkColor : lightColor; if (radio.nextElementSibling) { radio.nextElementSibling.style.backgroundColor = colorToShow || radio.value; } }); this.updatePlayerColor(document.querySelector('#modal-playerChoice input:checked'));
          }
          getCurrentPlayerColor(getBaseValue = false) { /* ... (Unchanged - reads modal) ... */
              const selectedRadio = document.querySelector('#modal-playerChoice input:checked'); if (!selectedRadio) return getCssVariable('--player-color'); if (getBaseValue) return selectedRadio.value; const isDark = document.body.classList.contains('dark-mode'); const lightColor = selectedRadio.dataset.light; const darkColor = selectedRadio.dataset.dark; return isDark ? (darkColor || lightColor || selectedRadio.value) : (lightColor || selectedRadio.value);
          }
          showMessage(title, text, finalTimeStr = '', bestTimeMsg = '') { /* ... (Unchanged) ... */
              const overlay = document.getElementById('message-overlay'); overlay.querySelector('h2').textContent = title; overlay.querySelector('p').innerHTML = text.replace('\n', '<br>'); const finalTimeEl = document.getElementById('final-time-msg'); const bestTimeEl = document.getElementById('final-best-time-msg'); finalTimeEl.textContent = finalTimeStr ? `Tu Tiempo: ${finalTimeStr}` : ''; bestTimeEl.textContent = bestTimeMsg; finalTimeEl.style.display = finalTimeStr ? 'block' : 'none'; bestTimeEl.style.display = bestTimeMsg ? 'block' : 'none'; overlay.classList.add('visible'); this.gameActive = false;
          }
          hideMessage() { /* ... (Unchanged) ... */
              document.getElementById('message-overlay').classList.remove('visible');
          }
          showLoading(show, text = 'Generando...') { /* ... (Unchanged) ... */
              const indicator = document.getElementById('loading-indicator'); const newGameBtn = document.getElementById('newGameBtn'); if (show) { indicator.textContent = text; indicator.classList.add('visible'); if(newGameBtn) newGameBtn.disabled = true; } else { indicator.classList.remove('visible'); if(newGameBtn) newGameBtn.disabled = false; }
          }

          // --- System Integration ---
          toggleFullscreen() { /* ... (Unchanged) ... */ }
          handleFullscreenChange() { /* ... (Unchanged - updates modal button) ... */
               const btn = document.getElementById('modal-fullscreenBtn'); const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement); if (btn) { btn.textContent = isFullscreen ? 'Salir P. Comp.' : 'P. Completa'; btn.title = isFullscreen ? 'Salir Pantalla Completa' : 'Activar Pantalla Completa'; } setTimeout(() => this.renderer.handleResize(), 100);
           }
          handlePrint() {
              if (!this.mazeGenerator?.generationComplete || !this.renderer) {
                  alert('Genera un laberinto primero');
                  return;
              }

              // Guardamos el estado actual
              const currentViewMode = this.renderer.viewMode;
              const currentDarkMode = document.body.classList.contains('dark-mode');
              
              // Optimizamos para impresión
              this.renderer.setViewMode('overview');
              document.body.classList.remove('dark-mode');
              
              // Esperamos a que se actualice el DOM
              requestAnimationFrame(() => {
                  // Forzamos actualización del renderer
                  this.renderer.handleResize();
                  this.renderer.updateStyleSettings(true);
                  this.renderer.drawFrame();
                  
                  // Imprimimos
                  window.print();
                  
                  // Restauramos el estado original
                  requestAnimationFrame(() => {
                      if (currentDarkMode) {
                          document.body.classList.add('dark-mode');
                      }
                      this.renderer.setViewMode(currentViewMode);
                      this.renderer.handleResize();
                      this.renderer.updateStyleSettings(true);
                      this.renderer.drawFrame();
                  });
              });
          }
    }

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        requestAnimationFrame(() => { window.mazeGame = new Game(); });
    });

</script>
</body>
</html>
