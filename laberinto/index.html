<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Laberinto</title>
    <style>
        /* --- ROOT VARIABLES --- */
        :root {
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --transition-speed: 0.3s;
            --bottom-nav-height: 60px;
            --modal-max-width: 500px;
            --top-ui-height: 40px;

            /* Factors */
            /* Default values, can be overridden by styles */
            --wall-thickness-factor: 0.1;
            --player-size-factor: 0.6;
            --end-marker-size-factor: 0.7;

            /* --- Light Theme Defaults --- */
            --bg-color-light: #f8f9fa; --panel-bg-light: #ffffff; --control-bg-light: #ffffff;
            --text-color-light: #212529; --text-muted-light: #6c757d; --border-color-light: #dee2e6;
            --primary-color-light: #007bff; --primary-hover-light: #0056b3; --shadow-light: rgba(0, 0, 0, 0.08);
            --input-bg-light: #ffffff; --input-border-light: #ced4da;
            /* Maze Specific - Light */
            --maze-bg-light: #e9ecef;
            --wall-color-light: #343a40; --wall-glow-light: transparent; --wall-shadow-light: rgba(0, 0, 0, 0.1);
            --player-color-light: #e63946; --player-glow-light: rgba(230, 57, 70, 0.3); --player-shadow-light: rgba(230, 57, 70, 0.4);
            --start-color-light: #a8dadc; --end-color-light: #457b9d; --path-color-light: rgba(227, 242, 253, 0.3); /* Path not currently used in drawing */
            --minimap-bg-light: rgba(255, 255, 255, 0.9); --minimap-border-light: #adb5bd;
            /* Minimap elements derive from main colors by default */
            --minimap-player-light: var(--player-color-light); --minimap-start-light: var(--start-color-light); --minimap-end-light: var(--end-color-light);

            /* --- Dark Theme Defaults --- */
            --bg-color-dark: #121212; --panel-bg-dark: #1e1e1e; --control-bg-dark: #2a2a2a;
            --text-color-dark: #e0e0e0; --text-muted-dark: #adb5bd; --border-color-dark: #333;
            --primary-color-dark: #4dabf7; --primary-hover-dark: #1e88e5; --shadow-dark: rgba(255, 255, 255, 0.06);
            --input-bg-dark: #252525; --input-border-dark: #444;
            /* Maze Specific - Dark */
            --maze-bg-dark: #212121;
            --wall-color-dark: #ced4da; --wall-glow-dark: rgba(206, 212, 218, 0.15); --wall-shadow-dark: transparent;
            --player-color-dark: #ff8a80; --player-glow-dark: rgba(255, 138, 128, 0.35); --player-shadow-dark: rgba(255, 138, 128, 0.5);
            --start-color-dark: #546e7a; --end-color-dark: #81d4fa; --path-color-dark: rgba(50, 50, 70, 0.3); /* Path not currently used */
            --minimap-bg-dark: rgba(30, 30, 30, 0.92); --minimap-border-dark: #6c757d;
            /* Minimap elements derive from main colors by default */
            --minimap-player-dark: var(--player-color-dark); --minimap-start-dark: var(--start-color-dark); --minimap-end-dark: var(--end-color-dark);

            /* --- Default assignments (will be overridden by theme) --- */
            --bg-color: var(--bg-color-light); --panel-bg: var(--panel-bg-light); --control-bg: var(--control-bg-light);
            --text-color: var(--text-color-light); --text-muted: var(--text-muted-light); --border-color: var(--border-color-light);
            --primary-color: var(--primary-color-light); --primary-hover: var(--primary-hover-light); --shadow: var(--shadow-light);
            --input-bg: var(--input-bg-light); --input-border: var(--input-border-light);
            --maze-bg: var(--maze-bg-light); --wall-color: var(--wall-color-light); --wall-glow: var(--wall-glow-light); --wall-shadow: var(--wall-shadow-light);
            --player-color: var(--player-color-light); --player-glow: var(--player-glow-light); --player-shadow: var(--player-shadow-light);
            --start-color: var(--start-color-light); --end-color: var(--end-color-light); --path-color: var(--path-color-light);
            --minimap-bg: var(--minimap-bg-light); --minimap-border: var(--minimap-border-light); --minimap-player: var(--minimap-player-light);
            --minimap-start: var(--minimap-start-light); --minimap-end: var(--minimap-end-light);
            --primary-color-rgb: 0, 123, 255; --panel-bg-rgb: 255, 255, 255;
        }

        /* --- Theme Application --- */
        body {
            /* Light Theme Variables */
            --bg-color: var(--bg-color-light); --panel-bg: var(--panel-bg-light); --control-bg: var(--control-bg-light);
            --text-color: var(--text-color-light); --text-muted: var(--text-muted-light); --border-color: var(--border-color-light);
            --primary-color: var(--primary-color-light); --primary-hover: var(--primary-hover-light); --shadow: var(--shadow-light);
            --input-bg: var(--input-bg-light); --input-border: var(--input-border-light);
            --primary-color-rgb: 0, 123, 255; --panel-bg-rgb: 255, 255, 255;

            /* Style defaults point to Light theme values initially */
            --maze-bg: var(--_maze-style-light, var(--maze-bg-light));
            --wall-color: var(--_wall-style-light, var(--wall-color-light));
            --wall-glow: var(--_wall-glow-style-light, var(--wall-glow-light));
            --wall-shadow: var(--_wall-shadow-style-light, var(--wall-shadow-light));
            --player-color: var(--_player-style-light, var(--player-color-light)); /* Player color is special, set via JS */
            --player-glow: var(--_player-glow-style-light, var(--player-glow-light));
            --player-shadow: var(--_player-shadow-style-light, var(--player-shadow-light));
            --start-color: var(--_start-style-light, var(--start-color-light));
            --end-color: var(--_end-style-light, var(--end-color-light));
            --minimap-bg: var(--_minimap-bg-style-light, var(--minimap-bg-light));
            --minimap-border: var(--_minimap-border-style-light, var(--minimap-border-light));
            --minimap-player: var(--_minimap-player-style-light, var(--player-color)); /* Minimap player uses current player color */
            --minimap-start: var(--_minimap-start-style-light, var(--start-color-light));
            --minimap-end: var(--_minimap-end-style-light, var(--end-color-light));
        }

        body.dark-mode {
            /* Dark Theme Variables */
            --bg-color: var(--bg-color-dark); --panel-bg: var(--panel-bg-dark); --control-bg: var(--control-bg-dark);
            --text-color: var(--text-color-dark); --text-muted: var(--text-muted-dark); --border-color: var(--border-color-dark);
            --primary-color: var(--primary-color-dark); --primary-hover: var(--primary-hover-dark); --shadow: var(--shadow-dark);
            --input-bg: var(--input-bg-dark); --input-border: var(--input-border-dark);
            --primary-color-rgb: 74, 171, 247; --panel-bg-rgb: 30, 30, 30;

            /* Style defaults point to Dark theme values */
            --maze-bg: var(--_maze-style-dark, var(--maze-bg-dark));
            --wall-color: var(--_wall-style-dark, var(--wall-color-dark));
            --wall-glow: var(--_wall-glow-style-dark, var(--wall-glow-dark));
            --wall-shadow: var(--_wall-shadow-style-dark, var(--wall-shadow-dark));
            --player-color: var(--_player-style-dark, var(--player-color-dark)); /* Player color is special, set via JS */
            --player-glow: var(--_player-glow-style-dark, var(--player-glow-dark));
            --player-shadow: var(--_player-shadow-style-dark, var(--player-shadow-dark));
            --start-color: var(--_start-style-dark, var(--start-color-dark));
            --end-color: var(--_end-style-dark, var(--end-color-dark));
            --minimap-bg: var(--_minimap-bg-style-dark, var(--minimap-bg-dark));
            --minimap-border: var(--_minimap-border-style-dark, var(--minimap-border-dark));
            --minimap-player: var(--_minimap-player-style-dark, var(--player-color)); /* Minimap player uses current player color */
            --minimap-start: var(--_minimap-start-style-dark, var(--start-color-dark));
            --minimap-end: var(--_minimap-end-style-dark, var(--end-color-dark));
        }

        /* --- Maze Style Definitions (_style-theme variants) --- */
        /* Classic Style */
        body[data-maze-style="classic"] {
            --_maze-style-light: var(--maze-bg-light);           --_maze-style-dark: var(--maze-bg-dark);
            --_wall-style-light: var(--wall-color-light);         --_wall-style-dark: var(--wall-color-dark);
            --_wall-glow-style-light: transparent;                --_wall-glow-style-dark: rgba(206, 212, 218, 0.1);
            --_wall-shadow-style-light: rgba(0, 0, 0, 0.1);       --_wall-shadow-style-dark: transparent;
            --_player-glow-style-light: var(--player-glow-light); --_player-glow-style-dark: var(--player-glow-dark);
            --_player-shadow-style-light: var(--player-shadow-light); --_player-shadow-style-dark: var(--player-shadow-dark);
            --_start-style-light: var(--start-color-light);       --_start-style-dark: var(--start-color-dark);
            --_end-style-light: var(--end-color-light);           --_end-style-dark: var(--end-color-dark);
            --_minimap-bg-style-light: var(--minimap-bg-light);   --_minimap-bg-style-dark: var(--minimap-bg-dark);
            --_minimap-border-style-light: var(--minimap-border-light); --_minimap-border-style-dark: var(--minimap-border-dark);
            --_minimap-start-style-light: var(--_start-style-light); --_minimap-start-style-dark: var(--_start-style-dark);
            --_minimap-end-style-light: var(--_end-style-light);     --_minimap-end-style-dark: var(--_end-style-dark);
            --wall-thickness-factor: 0.1;
            --player-size-factor: 0.6;
        }
        /* Matrix Style */
        body[data-maze-style="matrix"] {
            --_maze-style-light: #030303;                         --_maze-style-dark: #000000;
            --_wall-style-light: #00ff41;                         --_wall-style-dark: #00ff41;
            --_wall-glow-style-light: rgba(0, 255, 65, 0.3);      --_wall-glow-style-dark: rgba(0, 255, 65, 0.35);
            --_wall-shadow-style-light: transparent;              --_wall-shadow-style-dark: transparent;
            --_player-glow-style-light: rgba(255, 255, 255, 0.4); --_player-glow-style-dark: rgba(255, 255, 255, 0.5);
            --_player-shadow-style-light: transparent;            --_player-shadow-style-dark: transparent;
            --_start-style-light: #00330a;                        --_start-style-dark: #004d11;
            --_end-style-light: #00801c;                          --_end-style-dark: #00cc2e;
            --_minimap-bg-style-light: rgba(0, 20, 0, 0.9);       --_minimap-bg-style-dark: rgba(0, 10, 0, 0.95);
            --_minimap-border-style-light: #00ff41;               --_minimap-border-style-dark: #00cc2e;
            --_minimap-start-style-light: var(--_start-style-light); --_minimap-start-style-dark: var(--_start-style-dark);
            --_minimap-end-style-light: var(--_end-style-light);     --_minimap-end-style-dark: var(--_end-style-dark);
            --wall-thickness-factor: 0.08;
            --player-size-factor: 0.55;
        }
        /* Blueprint Style */
        body[data-maze-style="blueprint"] {
            --_maze-style-light: #2962ff;                         --_maze-style-dark: #1a237e; /* Darker blue */
            --_wall-style-light: #ffffff;                         --_wall-style-dark: #bbdefb; /* Light blue lines */
            --_wall-glow-style-light: rgba(255, 255, 255, 0.1);   --_wall-glow-style-dark: rgba(187, 222, 251, 0.15);
            --_wall-shadow-style-light: transparent;              --_wall-shadow-style-dark: transparent;
            --_player-glow-style-light: rgba(255, 235, 59, 0.5);  --_player-glow-style-dark: rgba(255, 245, 157, 0.5); /* Yellow player glow */
            --_player-shadow-style-light: transparent;            --_player-shadow-style-dark: transparent;
            --_start-style-light: #1c50d3;                        --_start-style-dark: #101649;
            --_end-style-light: #5c87ff;                          --_end-style-dark: #3f51b5;
            --_minimap-bg-style-light: rgba(41, 98, 255, 0.85);   --_minimap-bg-style-dark: rgba(26, 35, 126, 0.9);
            --_minimap-border-style-light: #ffffff;               --_minimap-border-style-dark: #bbdefb;
            --_minimap-start-style-light: var(--_start-style-light); --_minimap-start-style-dark: var(--_start-style-dark);
            --_minimap-end-style-light: var(--_end-style-light);     --_minimap-end-style-dark: var(--_end-style-dark);
            --wall-thickness-factor: 0.04; /* Thinner lines */
            --player-size-factor: 0.65;
        }
        /* Neon Style */
        body[data-maze-style="neon"] {
            --_maze-style-light: #1a1a2e;                         --_maze-style-dark: #0f0f1a;
            --_wall-style-light: #ff00ff;                         --_wall-style-dark: #ff40ff; /* Magenta */
            --_wall-glow-style-light: rgba(255, 0, 255, 0.4);     --_wall-glow-style-dark: rgba(255, 64, 255, 0.5);
            --_wall-shadow-style-light: transparent;              --_wall-shadow-style-dark: transparent;
            --_player-glow-style-light: rgba(0, 255, 255, 0.5);   --_player-glow-style-dark: rgba(100, 255, 255, 0.6); /* Cyan player glow */
            --_player-shadow-style-light: transparent;            --_player-shadow-style-dark: transparent;
            --_start-style-light: #330033;                        --_start-style-dark: #4d004d;
            --_end-style-light: #800080;                          --_end-style-dark: #b300b3;
            --_minimap-bg-style-light: rgba(26, 26, 46, 0.9);     --_minimap-bg-style-dark: rgba(15, 15, 26, 0.95);
            --_minimap-border-style-light: #ff00ff;               --_minimap-border-style-dark: #ff40ff;
            --_minimap-start-style-light: var(--_start-style-light); --_minimap-start-style-dark: var(--_start-style-dark);
            --_minimap-end-style-light: var(--_end-style-light);     --_minimap-end-style-dark: var(--_end-style-dark);
            --wall-thickness-factor: 0.1;
            --player-size-factor: 0.6;
        }
        /* Cyber Style */
        body[data-maze-style="cyber"] {
            --_maze-style-light: #2a004f;                         --_maze-style-dark: #1a0033; /* Deep Purple/Indigo */
            --_wall-style-light: #00ffff;                         --_wall-style-dark: #7fffd4; /* Cyan/Aquamarine */
            --_wall-glow-style-light: rgba(0, 255, 255, 0.3);     --_wall-glow-style-dark: rgba(127, 255, 212, 0.35);
            --_wall-shadow-style-light: transparent;              --_wall-shadow-style-dark: transparent;
            --_player-glow-style-light: rgba(255, 105, 180, 0.5); --_player-glow-style-dark: rgba(255, 155, 200, 0.6); /* Hot Pink player glow */
            --_player-shadow-style-light: transparent;            --_player-shadow-style-dark: transparent;
            --_start-style-light: #480082;                        --_start-style-dark: #300050;
            --_end-style-light: #8a2be2;                          --_end-style-dark: #9370db; /* Blue Violet / Medium Purple */
            --_minimap-bg-style-light: rgba(42, 0, 79, 0.9);      --_minimap-bg-style-dark: rgba(26, 0, 51, 0.95);
            --_minimap-border-style-light: #00ffff;               --_minimap-border-style-dark: #7fffd4;
            --_minimap-start-style-light: var(--_start-style-light); --_minimap-start-style-dark: var(--_start-style-dark);
            --_minimap-end-style-light: var(--_end-style-light);     --_minimap-end-style-dark: var(--_end-style-dark);
            --wall-thickness-factor: 0.08;
            --player-size-factor: 0.6;
        }

        /* --- General Layout & UI Elements --- */
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        html, body { height: 100%; width: 100%; } /* Ensure body takes full width */
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            width: 100%; /* Redundant but safe */
            overflow: hidden; /* Prevent scrollbars */
            display: flex;
            flex-direction: column;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
        }
        #main-content {
            flex-grow: 1;
            position: relative;
            overflow: hidden; /* Container should hide overflow */
            display: flex;
            flex-direction: column;
        }
        #game-ui-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: var(--top-ui-height);
            display: flex; justify-content: center; align-items: center; padding: 5px 10px;
            z-index: 100; pointer-events: none; /* Allow clicks through */
        }
        .timer-display {
            background-color: rgba(var(--panel-bg-rgb, 255, 255, 255), 0.85);
            color: var(--primary-color);
            padding: 0.3rem 0.8rem; border-radius: 15px; font-size: 0.9rem; font-weight: bold;
            box-shadow: 0 1px 3px var(--shadow); pointer-events: auto; /* Timer is clickable */
            display: inline-flex; align-items: center;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
        }
        #maze-container {
            flex-grow: 1;
            position: relative; /* Needed for absolute positioning of canvas */
            overflow: hidden; /* CRITICAL: Prevents canvas overflow */
            background-color: var(--maze-bg);
            display: flex; /* Needed for centering in overview */
            justify-content: center; /* Needed for centering in overview */
            align-items: center; /* Needed for centering in overview */
            touch-action: none; /* Prevent default touch actions like scrolling */
            z-index: 1;
            transition: background-color var(--transition-speed) ease;
        }
        #mazeCanvas {
            display: block;
            position: absolute; /* Necessary for both overview centering and player view */
            image-rendering: pixelated; /* For sharp pixels at low res */
            image-rendering: crisp-edges;
            transform-origin: top left;
        }
        #bottom-nav {
            flex-shrink: 0; height: var(--bottom-nav-height); background-color: var(--panel-bg);
            border-top: 1px solid var(--border-color); box-shadow: 0 -2px 5px var(--shadow);
            display: flex; justify-content: space-around; align-items: center; padding: 0 10px;
            gap: 5px;
            z-index: 1000;
            transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
        }
        #bottom-nav button {
             background: none; border: none; color: var(--text-muted);
             display: flex; flex-direction: column; align-items: center;
             padding: 4px 8px;
             font-size: 0.7rem;
             cursor: pointer; transition: color 0.2s ease, background-color 0.2s ease;
             border-radius: 4px; min-height: 50px; justify-content: center;
             flex-grow: 1; max-width: 100px;
             text-align: center;
             white-space: nowrap;
        }
        #bottom-nav button .icon { font-size: 1.4rem; margin-bottom: 1px; }
        #bottom-nav button.active { color: var(--primary-color); background-color: rgba(var(--primary-color-rgb), 0.1); }
        #bottom-nav button:hover:not(:disabled):not(.active) { background-color: rgba(var(--primary-color-rgb), 0.05); }
        #bottom-nav button:disabled { color: var(--border-color); cursor: not-allowed; opacity: 0.6; }

        /* --- Modals Common --- */
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 0.8rem 1.2rem; border-bottom: 1px solid var(--border-color); flex-shrink: 0; transition: border-color var(--transition-speed) ease; }
        .modal-header h2 { margin: 0; font-size: 1.2rem; color: var(--primary-color); transition: color var(--transition-speed) ease; }
        .modal-content { overflow-y: auto; display: flex; flex-direction: column; flex-grow: 1; }
        .modal-footer { flex-shrink: 0; padding: 0.8rem 1.2rem; border-top: 1px solid var(--border-color); text-align: right; transition: border-color var(--transition-speed) ease; }

        /* --- Settings Modal Specific --- */
        #settings-modal-backdrop { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.6); z-index: 1100; opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, visibility 0s linear var(--transition-speed); }
        #settings-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9); width: 90%; max-width: var(--modal-max-width); max-height: 85vh; background-color: var(--panel-bg); border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); z-index: 1110; opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, transform var(--transition-speed) ease, visibility 0s linear var(--transition-speed), background-color var(--transition-speed) ease; display: flex; flex-direction: column; }
        #settings-modal-backdrop.visible { opacity: 1; visibility: visible; transition-delay: 0s; }
        #settings-modal.visible { opacity: 1; visibility: visible; transform: translate(-50%, -50%) scale(1); transition-delay: 0s; }
        #closeSettingsBtn { background: none; border: none; font-size: 1.8rem; line-height: 1; color: var(--text-muted); cursor: pointer; padding: 0.2rem; transition: color var(--transition-speed) ease; }
        #settings-modal .modal-content { padding: 1rem 1.2rem; gap: 1.2rem; }
        .control-group { background-color: var(--control-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 0.8rem 1rem; box-shadow: 0 1px 3px var(--shadow); transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease; }
        .control-group h3 { margin: 0 0 0.8rem 0; font-size: 0.9rem; font-weight: 600; color: var(--primary-color); padding-bottom: 0.4rem; border-bottom: 1px solid var(--border-color); transition: color var(--transition-speed) ease, border-color var(--transition-speed) ease; }
        label, .label-like { display: block; margin-bottom: 0.3rem; font-weight: 500; font-size: 0.85rem; color: var(--text-muted); padding-top: 0.2rem; transition: color var(--transition-speed) ease; }
        input[type="number"], select { width: 100%; padding: 0.6rem 0.75rem; margin-bottom: 0.75rem; min-height: 42px; border: 1px solid var(--input-border); border-radius: 4px; background-color: var(--input-bg); color: var(--text-color); font-size: 0.9rem; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, color var(--transition-speed) ease; }
        button.modal-button { display: block; width: 100%; padding: 0.7rem 1.2rem; background-color: var(--primary-color); color: #ffffff; border: none; border-radius: 5px; cursor: pointer; font-size: 0.9rem; font-weight: 500; margin-top: 0.5rem; text-align: center; min-height: 42px; transition: background-color var(--transition-speed) ease; }
        button.modal-button:hover:not(:disabled) { background-color: var(--primary-hover); }
        .button-group { display: flex; gap: 0.75rem; }
        .button-group button { flex: 1; }
        .switch-container { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem; min-height: 40px;}
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; flex-shrink: 0; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary-color); }
        input:checked + .slider:before { transform: translateX(20px); }
        .choice-group { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.5rem; }
        .choice-group label { margin-bottom: 0; cursor: pointer; }
        .choice-group label[hidden] { display: none; }
        .choice-group input[type="radio"], .choice-group input[type="checkbox"] { display: none; }
        .choice-group span { display: inline-flex; align-items: center; justify-content: center; padding: 0.5rem 0.8rem; border: 1px solid var(--border-color); border-radius: 4px; background-color: var(--input-bg); font-size: 0.85rem; text-align: center; min-width: 36px; min-height: 36px; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, color var(--transition-speed) ease, box-shadow var(--transition-speed) ease; }
        .choice-group span.color-preview { width: 32px; height: 32px; padding: 0; border-radius: 50%; box-shadow: inset 0 0 0 1px var(--border-color); }
        .choice-group input:checked + span { background-color: var(--primary-color); color: white; border-color: var(--primary-color); box-shadow: 0 0 0 2px rgba(var(--primary-color-rgb), 0.4); }

        /* --- Scores Modal Specific --- */
         #scores-modal-backdrop { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.6); z-index: 1090; opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, visibility 0s linear var(--transition-speed); }
         #scores-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9); width: 90%; max-width: 450px; max-height: 75vh; background-color: var(--panel-bg); border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); z-index: 1095; opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, transform var(--transition-speed) ease, visibility 0s linear var(--transition-speed), background-color var(--transition-speed) ease; display: flex; flex-direction: column; }
         #scores-modal-backdrop.visible { opacity: 1; visibility: visible; transition-delay: 0s; }
         #scores-modal.visible { opacity: 1; visibility: visible; transform: translate(-50%, -50%) scale(1); transition-delay: 0s; }
         #scores-modal .modal-header h2 { color: var(--primary-color); }
         #closeScoresBtn { background: none; border: none; font-size: 1.8rem; line-height: 1; color: var(--text-muted); cursor: pointer; padding: 0.2rem; transition: color var(--transition-speed) ease; }
         #scores-list-container { padding: 0.5rem 0; }
         .score-entry { display: flex; justify-content: space-between; align-items: center; padding: 0.7rem 1.2rem; border-bottom: 1px solid var(--border-color); font-size: 0.95rem; transition: background-color 0.2s ease, border-color var(--transition-speed) ease; }
         .score-entry:last-child { border-bottom: none; }
         .score-entry:hover { background-color: rgba(var(--primary-color-rgb), 0.05); }
         .score-size { font-weight: 600; color: var(--text-color); flex-basis: 40%; transition: color var(--transition-speed) ease; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
         .score-time { font-weight: 500; color: var(--primary-color); flex-basis: 50%; text-align: right; font-family: 'Courier New', Courier, monospace; font-size: 1rem; transition: color var(--transition-speed) ease; }
         .no-scores-message { display: none; text-align: center; color: var(--text-muted); padding: 2rem 1.2rem; transition: color var(--transition-speed) ease; }
         #clearScoresBtn { background-color: transparent; color: var(--text-muted); border: 1px solid var(--border-color); padding: 0.5rem 1rem; font-size: 0.8rem; border-radius: 5px; cursor: pointer; min-height: auto; width: auto; display: inline-block; transition: background-color 0.2s ease, color 0.2s ease, border-color var(--transition-speed) ease; }
         body.dark-mode #clearScoresBtn { color: var(--text-muted-dark); }
         #clearScoresBtn:hover:not(:disabled) { background-color: rgba(220, 53, 69, 0.1); color: #dc3545; border-color: rgba(220, 53, 69, 0.3); }
         #clearScoresBtn:disabled { opacity: 0.5; cursor: not-allowed; background-color: transparent !important; color: var(--text-muted) !important; border-color: var(--border-color) !important; }
         #bottom-nav button#scoresBtn.active { color: var(--primary-color); background-color: rgba(var(--primary-color-rgb), 0.1); }

        /* --- Message Overlay, Loading, Minimap --- */
        #message-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.75); display: flex; justify-content: center; align-items: center; z-index: 1200; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s; padding: 1rem; }
        #message-overlay.visible { opacity: 1; visibility: visible; transition-delay: 0s; }
        #message-box { background-color: var(--panel-bg); color: var(--text-color); padding: 1.5rem 2rem; border-radius: 10px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.25); transform: scale(0.9); transition: transform 0.3s ease, background-color var(--transition-speed) ease, color var(--transition-speed) ease; width: 90%; max-width: 350px; }
        #message-overlay.visible #message-box { transform: scale(1); transition-delay: 0s;}
        #message-box h2 { margin: 0 0 1rem 0; font-size: 1.4rem; color: var(--primary-color); transition: color var(--transition-speed) ease; }
        #message-box p { margin-bottom: 1.5rem; font-size: 0.95rem; line-height: 1.5; }
        #message-box button { width: auto; padding: 0.7rem 1.8rem; font-size: 0.95rem; }
        #final-time-msg { font-weight: bold; margin-top:-0.5rem; margin-bottom: 1.5rem; display: none; }
        #final-best-time-msg { font-size: 0.85rem; color: var(--text-muted); margin-top:-1rem; margin-bottom: 1.5rem; display: none; transition: color var(--transition-speed) ease; }
        #loading-indicator { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 1.2rem 1.5rem; border-radius: 8px; font-size: 1rem; z-index: 1250; text-align: center; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s; pointer-events: none; }
        #loading-indicator.visible { opacity: 1; visibility: visible; transition-delay: 0s; }
        #minimapContainer { position: absolute; bottom: calc(var(--bottom-nav-height) + 15px); right: 15px; border: 2px solid var(--minimap-border); background-color: var(--minimap-bg); box-shadow: 0 0 8px rgba(0,0,0,0.25); z-index: 10; display: none; max-width: 120px; max-height: 120px; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease; border-radius: 4px; }
        #minimapCanvas { display: block; image-rendering: pixelated; image-rendering: crisp-edges; }

        /* --- Print Styles --- */
        @media print {
            body { --transition-speed: 0s !important; }
            #bottom-nav, #settings-modal-backdrop, #settings-modal, #scores-modal-backdrop, #scores-modal, #game-ui-overlay, #message-overlay, #loading-indicator, #minimapContainer { display: none !important; }
            #main-content { border: none; padding: 0; width: 100% !important; height: 100% !important; flex-grow: 1 !important; }
            #maze-container { width: 100% !important; height: auto !important; max-height: 95vh !important; padding: 0 !important; margin: 0 !important; overflow: visible !important; border: 1px solid #ccc !important; background-color: #fff !important; justify-content: flex-start !important; align-items: flex-start !important; flex-grow: 1 !important; }
            body, body.dark-mode { /* Force light theme for printing */
                background-color: #fff !important; color: #000 !important;
                --bg-color: #ffffff; --text-color: #000000;
                --maze-bg: #ffffff;
                --wall-color: #000000; --wall-glow: transparent; --wall-shadow: transparent;
                --player-color: #aaaaaa; --player-glow: transparent; --player-shadow: transparent;
                --start-color: #e0e0e0; --end-color: #c0c0c0;
                --minimap-start: var(--start-color); --minimap-end: var(--end-color);
                 /* Reset factors potentially modified by styles */
                --wall-thickness-factor: 0.1;
                --player-size-factor: 0.6;
                --end-marker-size-factor: 0.7;
            }
            #mazeCanvas { position: static !important; max-width: 100% !important; height: auto !important; box-shadow: none !important; border: none !important; background-color: transparent !important; transform: none !important; left: 0 !important; top: 0 !important; }
            @page { size: auto; margin: 5mm; }
        }
    </style>
</head>
<body data-maze-style="classic"> <!-- Default style -->

<main id="main-content">
    <div id="game-ui-overlay"><div class="timer-display"><span id="current-time">00:00</span></div></div>
    <div id="maze-container">
        <canvas id="mazeCanvas"></canvas>
        <div id="minimapContainer"><canvas id="minimapCanvas"></canvas></div>
    </div>
    <div id="message-overlay">
        <div id="message-box">
            <h2>¡Victoria!</h2>
            <p>¡Has encontrado la salida!</p> <!-- Default text -->
            <p id="final-time-msg"></p>
            <p id="final-best-time-msg"></p>
            <button id="playAgainBtn" class="modal-button">Jugar Otra Vez</button>
        </div>
    </div>
    <div id="loading-indicator">Generando...</div>
</main>

<nav id="bottom-nav">
    <button id="newGameBtn" title="Generar Nuevo Laberinto"><span class="icon">➕</span><span>Nuevo</span></button>
    <button id="viewModeBtn" title="Cambiar Vista (Actual: General)" data-mode="overview"><span class="icon">👁️</span><span>Vista</span></button>
    <button id="scoresBtn" title="Ver Mejores Tiempos"><span class="icon">🏆</span><span>Marcas</span></button>
    <button id="settingsBtn" title="Abrir Ajustes"><span class="icon">⚙️</span><span>Ajustes</span></button>
</nav>

<!-- Settings Modal -->
<div id="settings-modal-backdrop"></div>
<div id="settings-modal" role="dialog" aria-labelledby="settingsModalTitle" aria-modal="true">
    <div class="modal-header">
        <h2 id="settingsModalTitle">Ajustes</h2>
        <button id="closeSettingsBtn" aria-label="Cerrar Ajustes">×</button>
    </div>
    <div class="modal-content">
        <div class="control-group">
            <h3>Generación</h3>
            <label for="modal-width">Ancho (5-500):</label>
            <input type="number" id="modal-width" value="15" min="5" max="500">
            <label for="modal-height">Alto (5-500):</label>
            <input type="number" id="modal-height" value="15" min="5" max="500">
            <p id="best-time-modal" style="font-size: 0.85rem; color: var(--text-muted); margin: 0.5rem 0;">Record (Actual): --:--</p>
            <button id="modal-generateBtn" class="modal-button">Generar Nuevo</button>
        </div>
        <div class="control-group">
            <h3>Apariencia</h3>
            <div class="switch-container">
                <label for="modal-darkModeToggle" class="label-like" style="margin-bottom: 0;">Modo Oscuro</label>
                <label class="switch">
                    <input type="checkbox" id="modal-darkModeToggle">
                    <span class="slider round"></span>
                </label>
            </div>
            <label for="modal-mazeStyle" class="label-like">Estilo Visual:</label>
            <div class="choice-group" id="modal-mazeStyle">
                <label><input type="radio" name="modal-style" value="classic" checked> <span>Clásico</span></label>
                <label><input type="radio" name="modal-style" value="matrix"> <span>Matrix</span></label>
                <label><input type="radio" name="modal-style" value="blueprint"> <span>Plano</span></label>
                <label><input type="radio" name="modal-style" value="neon"> <span>Neón</span></label>
                <label><input type="radio" name="modal-style" value="cyber"> <span>Cyber</span></label>
            </div>
            <label class="label-like">Personaje:</label>
             <div class="choice-group" id="modal-playerChoice">
                 <!-- Generic Choices -->
                 <label title="Rojo"><input type="radio" name="modal-player" value="#e63946" data-light="#e63946" data-dark="#ff8a80" checked> <span class="color-preview" style="background-color: #e63946;"></span></label>
                 <label title="Azul"><input type="radio" name="modal-player" value="#1d3557" data-light="#1d3557" data-dark="#a1c4fd"> <span class="color-preview" style="background-color: #1d3557;"></span></label>
                 <label title="Verde"><input type="radio" name="modal-player" value="#588157" data-light="#588157" data-dark="#a5d6a7"> <span class="color-preview" style="background-color: #588157;"></span></label>
                 <label title="Amarillo"><input type="radio" name="modal-player" value="#ffb703" data-light="#ffb703" data-dark="#fff176"> <span class="color-preview" style="background-color: #ffb703;"></span></label>
                 <label title="Púrpura"><input type="radio" name="modal-player" value="#6a0dad" data-light="#6a0dad" data-dark="#ce93d8"> <span class="color-preview" style="background-color: #6a0dad;"></span></label>
                 <!-- Style-Specific Choices (Hidden by default, shown by JS) -->
                 <label title="Matrix Player" data-style-specific="matrix" hidden><input type="radio" name="modal-player" value="#ffffff" data-light="#ffffff" data-dark="#ffffff"> <span class="color-preview" style="background-color: #ffffff;"></span></label>
                 <label title="Blueprint Player" data-style-specific="blueprint" hidden><input type="radio" name="modal-player" value="#ffeb3b" data-light="#ffeb3b" data-dark="#fff59d"> <span class="color-preview" style="background-color: #ffeb3b;"></span></label>
                 <label title="Neon Player" data-style-specific="neon" hidden><input type="radio" name="modal-player" value="#00ffff" data-light="#00ffff" data-dark="#7fffd4"> <span class="color-preview" style="background-color: #00ffff;"></span></label>
                 <label title="Cyber Player" data-style-specific="cyber" hidden><input type="radio" name="modal-player" value="#ff69b4" data-light="#ff69b4" data-dark="#ff85c0"> <span class="color-preview" style="background-color: #ff69b4;"></span></label>
             </div>
            <label class="label-like">Indicador Salida:</label>
            <div class="choice-group" id="modal-exitChoice">
                <label><input type="radio" name="modal-exit" value="🏁" checked> <span>🏁</span></label>
                <label><input type="radio" name="modal-exit" value="★"> <span>★</span></label>
                <label><input type="radio" name="modal-exit" value="◎"> <span>◎</span></label>
                <label><input type="radio" name="modal-exit" value="🎯"> <span>🎯</span></label>
                <label><input type="radio" name="modal-exit" value="✅"> <span>✅</span></label>
            </div>
            <div class="button-group" style="margin-top: 1rem;">
                <button id="modal-printBtn" class="modal-button" title="Imprimir Laberinto Actual">Imprimir</button>
            </div>
        </div>
    </div>
</div>

<!-- Scores Modal -->
<div id="scores-modal-backdrop"></div>
<div id="scores-modal" role="dialog" aria-labelledby="scoresModalTitle" aria-modal="true">
    <div class="modal-header">
        <h2 id="scoresModalTitle">Mejores Tiempos</h2>
        <button id="closeScoresBtn" aria-label="Cerrar Mejores Tiempos">×</button>
    </div>
    <div class="modal-content" id="scores-list-container">
        <div class="no-scores-message" style="display: none;">
            Aún no has completado ningún laberinto. ¡Juega para registrar tus marcas!
        </div>
    </div>
    <div class="modal-footer">
         <button id="clearScoresBtn" class="modal-button secondary-button" title="Borrar todos los récords guardados">Borrar Todo</button>
    </div>
</div>


<script>
    // --- Constants & Settings ---
    const MAX_MAZE_DIMENSION = 500;
    const MOBILE_BREAKPOINT_WIDTH = 768;
    const MOBILE_MAX_INPUT_DIMENSION = 70;
    const MIN_MAZE_DIMENSION = 5;
    const CAMERA_SMOOTHING = 0.08;
    const PLAYER_SMOOTHING = 0.2;
    const GENERATION_YIELD_INTERVAL = 5000;
    const MINIMAP_MAX_SIZE = 120;
    const MINIMAP_PLAYER_DOT_SIZE = 3;
    const MINIMAP_CELL_MARKER_SCALE = 0.7;
    const BASE_CELL_SIZE_PLAYER_VIEW = 45;
    const SWIPE_THRESHOLD = 25;
    const EFFECTS_MIN_CELL_SIZE = 12;

    // --- Polyfills ---
    if (!Element.prototype.requestFullscreen) Element.prototype.requestFullscreen = Element.prototype.mozRequestFullScreen || Element.prototype.webkitRequestFullscreen || Element.prototype.msRequestFullscreen;
    if (!document.exitFullscreen) document.exitFullscreen = document.mozCancelFullScreen || document.webkitExitFullscreen || document.msExitFullscreen;
    Object.defineProperty(document, 'fullscreenElement', { get: () => document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document._fullscreenElement });

    // --- Helper Functions ---
    const lerp = (a, b, t) => a + (b - a) * t;
    const clamp = (val, min, max) => Math.min(Math.max(val, min), max);
    const getCssVariable = (varName) => getComputedStyle(document.body).getPropertyValue(varName).trim();

    // --- GA Event Tracking Helper ---
    function trackEvent(eventName, params = {}) {
        if (typeof gtag === 'function') {
            // Limpia parámetros indefinidos o nulos para evitar errores en GA
            const cleanParams = {};
            for (const key in params) {
                if (params[key] !== undefined && params[key] !== null) {
                    cleanParams[key] = params[key];
                }
            }
            console.log(`Tracking Event: ${eventName}`, cleanParams); // Log para depuración
            try {
                gtag('event', eventName, cleanParams);
            } catch (e) {
                console.error(`Error sending gtag event '${eventName}':`, e);
            }
        } else {
            console.warn(`gtag not available, event not tracked: ${eventName}`);
        }
    }

    // --- Classes (Cell, MazeGenerator, Player) ---
    class Cell { constructor(x, y) { this.x = x; this.y = y; this.visited = false; this.walls = { top: true, right: true, bottom: true, left: true }; } }
    class MazeGenerator {
        constructor() { this.grid = []; this.width = 0; this.height = 0; this.start = { x: 0, y: 0 }; this.end = { x: 0, y: 0 }; this.generationComplete = false; }
        async generate(width, height, yieldCallback) {
            this.width = clamp(width, MIN_MAZE_DIMENSION, MAX_MAZE_DIMENSION); this.height = clamp(height, MIN_MAZE_DIMENSION, MAX_MAZE_DIMENSION);
            this.generationComplete = false; const startTime = performance.now(); console.log(`Starting generation for ${this.width}x${this.height}...`);
            this.grid = Array.from({ length: this.height }, (_, y) => Array.from({ length: this.width }, (_, x) => new Cell(x, y)));
            this.start = { x: 0, y: 0 }; this.end = { x: Math.max(0,this.width - 1), y: Math.max(0, this.height - 1) };
            const stack = []; let cellsProcessedSinceYield = 0; const totalCells = this.width * this.height; let visitedCells = 0;
            const startCell = this.grid[this.start.y][this.start.x]; startCell.visited = true; visitedCells++; stack.push(startCell);
            while (stack.length > 0) {
                const current = stack[stack.length - 1]; const neighbors = this.getUnvisitedNeighbors(current);
                if (neighbors.length > 0) { const next = neighbors[Math.floor(Math.random() * neighbors.length)]; this.removeWall(current, next); next.visited = true; visitedCells++; stack.push(next); }
                else { stack.pop(); }
                cellsProcessedSinceYield++;
                if (yieldCallback && cellsProcessedSinceYield >= GENERATION_YIELD_INTERVAL) {
                    const progress = visitedCells / totalCells; yieldCallback(progress);
                    await new Promise(resolve => setTimeout(resolve, 0)); cellsProcessedSinceYield = 0;
                }
            }
            if (yieldCallback) yieldCallback(1); this.generationComplete = true; const endTime = performance.now(); console.log(`Generation finished in ${(endTime - startTime).toFixed(2)} ms`); return this;
        }
        getUnvisitedNeighbors(cell) { const neighbors = []; const { x, y } = cell; const check = (nx, ny) => { if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height && !this.grid[ny][nx].visited) { neighbors.push(this.grid[ny][nx]); } }; check(x, y - 1); check(x + 1, y); check(x, y + 1); check(x - 1, y); return neighbors; }
        removeWall(a, b) { const dx = a.x - b.x; const dy = a.y - b.y; if (dx === 1) { a.walls.left = false; b.walls.right = false; } else if (dx === -1) { a.walls.right = false; b.walls.left = false; } if (dy === 1) { a.walls.top = false; b.walls.bottom = false; } else if (dy === -1) { a.walls.bottom = false; b.walls.top = false; } }
    }
    class Player { constructor(x, y, color) { this.x = x; this.y = y; this.targetX = x; this.targetY = y; this.pixelX = x; this.pixelY = y; this.color = color; this.isMoving = false; } moveTo(newX, newY) { this.targetX = newX; this.targetY = newY; if (Math.abs(this.targetX - this.pixelX) > 0.01 || Math.abs(this.targetY - this.pixelY) > 0.01) { this.isMoving = true; } } update(deltaTime) { if (!this.isMoving) return; this.pixelX = lerp(this.pixelX, this.targetX, PLAYER_SMOOTHING); this.pixelY = lerp(this.pixelY, this.targetY, PLAYER_SMOOTHING); if (Math.abs(this.pixelX - this.targetX) < 0.01 && Math.abs(this.pixelY - this.targetY) < 0.01) { this.pixelX = this.targetX; this.pixelY = this.targetY; this.x = Math.round(this.targetX); /* Snap logical position */ this.y = Math.round(this.targetY); this.isMoving = false; } } canMove(dx, dy, maze) { if (this.isMoving) return false; const currentX = this.x; const currentY = this.y; const nextX = currentX + dx; const nextY = currentY + dy; if (nextX < 0 || nextX >= maze.width || nextY < 0 || nextY >= maze.height) return false; const currentCell = maze.grid[currentY]?.[currentX]; if (!currentCell) return false; if (dx === 1 && currentCell.walls.right) return false; if (dx === -1 && currentCell.walls.left) return false; if (dy === 1 && currentCell.walls.bottom) return false; if (dy === -1 && currentCell.walls.top) return false; return { newX: nextX, newY: nextY }; } setColor(color) { this.color = color; } }

    // --- Minimap Class ---
    class Minimap {
        constructor(canvasId, containerId) {
            this.container = document.getElementById(containerId);
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d', { alpha: false }); // No transparency needed for base
            this.maze = null;
            this.player = null;
            this.size = MINIMAP_MAX_SIZE;
            this.cellWidth = 1;
            this.cellHeight = 1;
            // Colors read dynamically from CSS
            this.wallColor = '#000';
            this.playerColor = '#f00';
            this.bgColor = 'rgba(255, 255, 255, 0.7)';
            this.borderColor = '#888';
            this.startColor = '#afa';
            this.endColor = '#aaf';
            this.visible = false;
            // Offscreen canvas for static maze elements
            this.offscreenCanvas = document.createElement('canvas');
            this.offscreenCtx = this.offscreenCanvas.getContext('2d', { alpha: false });
            this.needsRedraw = true; // Flag to redraw the static background
        }

        updateSource(maze, player) {
            const mazeChanged = this.maze !== maze;
            this.maze = maze;
            this.player = player;
            if (mazeChanged) {
                 this.needsRedraw = true;
            }
            this.updateColors(); // Always check colors in case theme/style changed
            if (this.maze && this.maze.generationComplete) {
                 this.calculateDimensions(); // Recalculate size if maze exists
            }
        }

        updateColors() {
             // Read FINAL computed values, which depend on theme and style
            const newWallColor = getCssVariable('--wall-color'); // Use main wall color for minimap
            const newPlayerColor = getCssVariable('--minimap-player'); // Specific minimap player color (often same as main player)
            const newBgColor = getCssVariable('--minimap-bg');
            const newBorderColor = getCssVariable('--minimap-border');
            const newStartColor = getCssVariable('--minimap-start'); // Specific minimap start
            const newEndColor = getCssVariable('--minimap-end');     // Specific minimap end

            let colorsChanged = false;
            if (this.wallColor !== newWallColor) { this.wallColor = newWallColor; colorsChanged = true; }
            if (this.playerColor !== newPlayerColor) { this.playerColor = newPlayerColor; /* No need to redraw static for player color */ }
            if (this.bgColor !== newBgColor) { this.bgColor = newBgColor; this.container.style.backgroundColor = this.bgColor; colorsChanged = true; }
            if (this.borderColor !== newBorderColor) { this.borderColor = newBorderColor; this.container.style.borderColor = this.borderColor; colorsChanged = true; } // Border change doesn't require canvas redraw
            if (this.startColor !== newStartColor) { this.startColor = newStartColor; colorsChanged = true; }
            if (this.endColor !== newEndColor) { this.endColor = newEndColor; colorsChanged = true; }

            if (colorsChanged) {
                this.needsRedraw = true; // Need to redraw offscreen canvas if static colors changed
            }
        }

        calculateDimensions() {
            if (!this.maze || !this.container) return;
            const aspect = this.maze.width / this.maze.height;
            let mapW, mapH;
            const maxSize = parseInt(getComputedStyle(this.container).maxWidth) || MINIMAP_MAX_SIZE;

            if (aspect >= 1) { mapW = maxSize; mapH = Math.max(1, Math.floor(maxSize / aspect)); }
            else { mapH = maxSize; mapW = Math.max(1, Math.floor(maxSize * aspect)); }

            if (this.canvas.width !== mapW || this.canvas.height !== mapH) {
                this.canvas.width = mapW; this.canvas.height = mapH;
                this.offscreenCanvas.width = mapW; this.offscreenCanvas.height = mapH;
                this.cellWidth = mapW / this.maze.width; this.cellHeight = mapH / this.maze.height;
                this.needsRedraw = true;
            }
            this.container.style.width = `${mapW}px`; this.container.style.height = `${mapH}px`;
        }

        show() {
            if (!this.visible) {
                 this.container.style.display = 'block'; this.visible = true;
                 if (this.maze && this.maze.generationComplete) { this.calculateDimensions(); this.needsRedraw = true; this.draw(); }
            }
        }

        hide() {
            if (this.visible) { this.container.style.display = 'none'; this.visible = false; }
        }

        draw() {
            if (!this.visible || !this.maze || !this.player || !this.maze.generationComplete) return;
            const newPlayerColor = getCssVariable('--minimap-player');
            if (this.playerColor !== newPlayerColor) this.playerColor = newPlayerColor;
            if (this.needsRedraw) { this.drawMazeToOffscreen(); this.needsRedraw = false; }
            this.ctx.drawImage(this.offscreenCanvas, 0, 0);
            // Draw Player dot
            this.ctx.fillStyle = this.playerColor;
            const playerX = this.player.pixelX * this.cellWidth; const playerY = this.player.pixelY * this.cellHeight;
            const playerDrawSize = Math.max(1.5, MINIMAP_PLAYER_DOT_SIZE);
            const centerX = playerX + this.cellWidth / 2; const centerY = playerY + this.cellHeight / 2;
            this.ctx.beginPath(); this.ctx.arc(centerX, centerY, playerDrawSize / 2, 0, Math.PI * 2); this.ctx.fill();
        }

        drawMazeToOffscreen() {
            if (!this.maze) return;
            const ctx = this.offscreenCtx; const width = this.offscreenCanvas.width; const height = this.offscreenCanvas.height;
            // Background
            ctx.fillStyle = this.bgColor; ctx.fillRect(0, 0, width, height);
            // Start/End Markers
            const markerSizeW = Math.max(1, this.cellWidth * MINIMAP_CELL_MARKER_SCALE); const markerSizeH = Math.max(1, this.cellHeight * MINIMAP_CELL_MARKER_SCALE);
            const markerOffsetX = (this.cellWidth - markerSizeW) / 2; const markerOffsetY = (this.cellHeight - markerSizeH) / 2;
            ctx.fillStyle = this.startColor; ctx.fillRect(this.maze.start.x * this.cellWidth + markerOffsetX, this.maze.start.y * this.cellHeight + markerOffsetY, markerSizeW, markerSizeH);
            ctx.fillStyle = this.endColor; ctx.fillRect(this.maze.end.x * this.cellWidth + markerOffsetX, this.maze.end.y * this.cellHeight + markerOffsetY, markerSizeW, markerSizeH);
            // Walls
            ctx.strokeStyle = this.wallColor; ctx.lineWidth = Math.max(1, Math.min(this.cellWidth, this.cellHeight) * 0.1);
            ctx.beginPath();
            for (let y = 0; y < this.maze.height; y++) {
                for (let x = 0; x < this.maze.width; x++) {
                    const cell = this.maze.grid[y]?.[x]; if (!cell) continue;
                    const cx = x * this.cellWidth; const cy = y * this.cellHeight;
                    const cew = cx + this.cellWidth; const ceh = cy + this.cellHeight;
                    if (cell.walls.right) { ctx.moveTo(cew, cy); ctx.lineTo(cew, ceh); }
                    if (cell.walls.bottom) { ctx.moveTo(cx, ceh); ctx.lineTo(cew, ceh); }
                }
            }
            ctx.moveTo(0, 0); ctx.lineTo(width, 0); ctx.moveTo(0, 0); ctx.lineTo(0, height);
            ctx.stroke();
        }
    }

    // --- Renderer Class (REFACTORED) ---
    class Renderer {
         constructor(canvasId, mazeContainerId) {
            this.canvas = document.getElementById(canvasId);
            this.container = document.getElementById(mazeContainerId);
            if (!this.canvas || !this.container) { throw new Error("Canvas or container element not found!"); }
            this.ctx = this.canvas.getContext('2d', { alpha: false });
            this.maze = null; this.player = null; this.minimap = null;
            this.cellSize = 20; this.viewMode = 'overview'; this.isPrinting = false; this.lastDrawTime = 0;
            this.cameraX = 0; this.cameraY = 0; this.targetCameraX = 0; this.targetCameraY = 0;
            this.wallCanvas = document.createElement('canvas'); this.wallCtx = this.wallCanvas.getContext('2d', { alpha: true });
            this.needsWallRedraw = true;
            this.wallColor = '#000'; this.bgColor = '#fff'; this.startColor = '#afa'; this.endColor = '#aaf';
            this.wallGlow = 'transparent'; this.wallShadow = 'transparent';
            this.playerGlow = 'transparent'; this.playerShadow = 'transparent';
            this.exitMarker = '🏁';
            this.wallThicknessFactor = 0.1; this.playerSizeFactor = 0.6; this.endMarkerSizeFactor = 0.7;
            this.resizeTimeout = null;
            window.addEventListener('resize', () => { clearTimeout(this.resizeTimeout); this.resizeTimeout = setTimeout(() => this.handleResize(), 150); });
            this.updateStyleSettings(true);
         }
         setMaze(maze) { this.maze = maze; this.needsWallRedraw = true; this.handleResize(); this.resetCamera(); if (this.minimap) this.minimap.updateSource(maze, this.player); console.log(`Renderer: Maze set (${maze.width}x${maze.height})`); }
         setPlayer(player) { this.player = player; this.resetCamera(); if (this.minimap) this.minimap.updateSource(this.maze, player); console.log("Renderer: Player set"); }
         setMinimap(minimap) { this.minimap = minimap; }
         updateStyleSettings(forceUpdate = false) {
             const newWallColor = getCssVariable('--wall-color'); const newBgColor = getCssVariable('--maze-bg');
             const newStartColor = getCssVariable('--start-color'); const newEndColor = getCssVariable('--end-color');
             const newWallGlow = getCssVariable('--wall-glow'); const newWallShadow = getCssVariable('--wall-shadow');
             const newPlayerGlow = getCssVariable('--player-glow'); const newPlayerShadow = getCssVariable('--player-shadow');
             const newWallThickness = parseFloat(getCssVariable('--wall-thickness-factor'));
             const newPlayerSize = parseFloat(getCssVariable('--player-size-factor'));
             const newEndMarkerSize = parseFloat(getCssVariable('--end-marker-size-factor'));
             let changed = forceUpdate;
             if (this.wallColor !== newWallColor) { this.wallColor = newWallColor; changed = true; }
             if (this.bgColor !== newBgColor) { this.bgColor = newBgColor; changed = true; }
             if (this.startColor !== newStartColor) { this.startColor = newStartColor; changed = true; }
             if (this.endColor !== newEndColor) { this.endColor = newEndColor; changed = true; }
             if (this.wallGlow !== newWallGlow) { this.wallGlow = newWallGlow; changed = true; }
             if (this.wallShadow !== newWallShadow) { this.wallShadow = newWallShadow; changed = true; }
             if (this.playerGlow !== newPlayerGlow) { this.playerGlow = newPlayerGlow; changed = true; }
             if (this.playerShadow !== newPlayerShadow) { this.playerShadow = newPlayerShadow; changed = true; }
             if (this.wallThicknessFactor !== newWallThickness) { this.wallThicknessFactor = newWallThickness; changed = true; }
             if (this.playerSizeFactor !== newPlayerSize) { this.playerSizeFactor = newPlayerSize; changed = true; }
             if (this.endMarkerSizeFactor !== newEndMarkerSize) { this.endMarkerSizeFactor = newEndMarkerSize; changed = true; }
             if (changed) { console.log("Renderer: Styles updated."); this.needsWallRedraw = true; if (this.minimap) this.minimap.updateColors(); return true; }
             return false;
         }
         setExitMarker(marker) { if (this.exitMarker !== marker) { this.exitMarker = marker; this.needsWallRedraw = true; console.log(`Renderer: Exit marker set to ${marker}`); } }
         setViewMode(mode) {
             if (this.viewMode !== mode) {
                 console.log(`Renderer: Switching view mode to: ${mode}`); this.viewMode = mode; this.handleResize();
                 if (this.minimap) { if (mode === 'playerCamera') this.minimap.show(); else this.minimap.hide(); }
                 const viewBtn = document.getElementById('viewModeBtn');
                 if (viewBtn) { viewBtn.title = mode === 'overview' ? 'Cambiar Vista (Actual: General)' : 'Cambiar Vista (Actual: Jugador)'; viewBtn.dataset.mode = mode; viewBtn.classList.toggle('active', mode === 'playerCamera'); }
                 this.needsWallRedraw = true; this.drawFrame();
             }
         }
         resetCamera() {
             if (!this.maze || !this.player) return;
             const currentCellSize = this.viewMode === 'playerCamera' ? BASE_CELL_SIZE_PLAYER_VIEW : this.cellSize;
             this.targetCameraX = (this.player.x + 0.5) * currentCellSize; this.targetCameraY = (this.player.y + 0.5) * currentCellSize;
             this.cameraX = this.targetCameraX; this.cameraY = this.targetCameraY;
             console.log(`Renderer: Camera reset/snapped to world coords (${this.cameraX.toFixed(1)}, ${this.cameraY.toFixed(1)})`);
         }
         handleResize() {
             if (!this.container) return; const containerWidth = this.container.clientWidth; const containerHeight = this.container.clientHeight;
             if (containerWidth <= 0 || containerHeight <= 0) return;
             console.log(`Renderer: HandleResize called. Mode: ${this.viewMode}, Container: ${containerWidth}x${containerHeight}`);
             if (this.viewMode === 'overview') {
                 if (!this.maze) return;
                 const cellW = containerWidth / this.maze.width; const cellH = containerHeight / this.maze.height;
                 this.cellSize = Math.max(1, Math.floor(Math.min(cellW, cellH)));
                 const totalMazeWidth = this.maze.width * this.cellSize; const totalMazeHeight = this.maze.height * this.cellSize;
                 this.canvas.width = totalMazeWidth; this.canvas.height = totalMazeHeight;
                 this.canvas.style.width = `${totalMazeWidth}px`; this.canvas.style.height = `${totalMazeHeight}px`;
                 this.canvas.style.left = `${Math.round((containerWidth - totalMazeWidth) / 2)}px`; this.canvas.style.top = `${Math.round((containerHeight - totalMazeHeight) / 2)}px`;
                 this.canvas.style.position = 'absolute';
                 console.log(`Renderer: Overview resize - cellSize=${this.cellSize.toFixed(2)}, canvas=${this.canvas.width}x${this.canvas.height}`);
                 this.needsWallRedraw = true;
             } else { // 'playerCamera' mode
                 this.cellSize = BASE_CELL_SIZE_PLAYER_VIEW;
                 this.canvas.width = containerWidth; this.canvas.height = containerHeight;
                 this.canvas.style.width = `${containerWidth}px`; this.canvas.style.height = `${containerHeight}px`;
                 this.canvas.style.left = '0px'; this.canvas.style.top = '0px'; this.canvas.style.position = 'absolute';
                 console.log(`Renderer: PlayerCamera resize - cellSize=${this.cellSize}, canvas=${this.canvas.width}x${this.canvas.height}`);
                 this.resetCamera();
             }
             if(this.minimap) { this.minimap.calculateDimensions(); this.minimap.needsRedraw = true; }
             this.drawFrame();
         }
         updateCamera(deltaTime) {
            if (this.viewMode !== 'playerCamera' || !this.player || !this.maze) return;
            this.targetCameraX = (this.player.pixelX + 0.5) * this.cellSize; this.targetCameraY = (this.player.pixelY + 0.5) * this.cellSize;
            const smoothingFactor = clamp(CAMERA_SMOOTHING * (deltaTime / (1000/60)), 0.01, 0.9);
            this.cameraX = lerp(this.cameraX, this.targetCameraX, smoothingFactor); this.cameraY = lerp(this.cameraY, this.targetCameraY, smoothingFactor);
         }
         drawFrame(timestamp = 0) {
            if (!this.maze || !this.player || !this.maze.generationComplete || this.isPrinting) return;
            const stylesPossiblyChanged = this.updateStyleSettings();
            const deltaTime = timestamp > 0 && this.lastDrawTime > 0 ? timestamp - this.lastDrawTime : 16.67;
            if (this.player.isMoving) { this.player.update(deltaTime); }
            if (this.viewMode === 'playerCamera') { this.updateCamera(deltaTime); }
            this.lastDrawTime = timestamp;
            const ctx = this.ctx; const canvasW = this.canvas.width; const canvasH = this.canvas.height;
            ctx.fillStyle = this.bgColor; ctx.fillRect(0, 0, canvasW, canvasH);
            if (this.viewMode === 'overview') {
                if (this.needsWallRedraw || stylesPossiblyChanged) { this.drawMazeStaticToOffscreen(); this.needsWallRedraw = false; console.log("Renderer: Redrawing overview offscreen canvas"); }
                if (this.wallCanvas.width > 0 && this.wallCanvas.height > 0) { ctx.drawImage(this.wallCanvas, 0, 0); }
                if (this.cellSize >= 1) { this.drawPlayer(ctx, this.player.pixelX * this.cellSize, this.player.pixelY * this.cellSize, 0, 0); }
            } else { // 'playerCamera'
                const camX = this.cameraX; const camY = this.cameraY;
                const halfW = canvasW / 2; const halfH = canvasH / 2;
                const currentCellSize = this.cellSize;
                const offsetX = -camX + halfW; const offsetY = -camY + halfH;
                const minVisibleX = Math.max(0, Math.floor((camX - halfW) / currentCellSize) - 1);
                const maxVisibleX = Math.min(this.maze.width, Math.ceil((camX + halfW) / currentCellSize) + 1);
                const minVisibleY = Math.max(0, Math.floor((camY - halfH) / currentCellSize) - 1);
                const maxVisibleY = Math.min(this.maze.height, Math.ceil((camY + halfH) / currentCellSize) + 1);

                // Draw Start/End Backgrounds
                ctx.fillStyle = this.startColor; const startDrawX = this.maze.start.x * currentCellSize + offsetX; const startDrawY = this.maze.start.y * currentCellSize + offsetY;
                if (this.maze.start.x >= minVisibleX && this.maze.start.x < maxVisibleX && this.maze.start.y >= minVisibleY && this.maze.start.y < maxVisibleY) { ctx.fillRect(startDrawX, startDrawY, currentCellSize, currentCellSize); }
                ctx.fillStyle = this.endColor; const endDrawX = this.maze.end.x * currentCellSize + offsetX; const endDrawY = this.maze.end.y * currentCellSize + offsetY;
                if (this.maze.end.x >= minVisibleX && this.maze.end.x < maxVisibleX && this.maze.end.y >= minVisibleY && this.maze.end.y < maxVisibleY) { ctx.fillRect(endDrawX, endDrawY, currentCellSize, currentCellSize); }

                // Draw Walls
                ctx.strokeStyle = this.wallColor; ctx.lineWidth = Math.max(1, currentCellSize * this.wallThicknessFactor); ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                const canShowEffects = currentCellSize > EFFECTS_MIN_CELL_SIZE; let shadowApplied = false;
                if (canShowEffects) {
                    if (this.wallGlow && this.wallGlow !== 'transparent' && this.wallGlow !== 'none') { ctx.shadowColor = this.wallGlow; ctx.shadowBlur = Math.max(3, currentCellSize * 0.15); ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; shadowApplied = true; }
                    else if (this.wallShadow && this.wallShadow !== 'transparent' && this.wallShadow !== 'none') { ctx.shadowColor = this.wallShadow; ctx.shadowBlur = Math.max(2, currentCellSize * 0.05); ctx.shadowOffsetX = Math.max(1, currentCellSize * 0.02); ctx.shadowOffsetY = Math.max(1, currentCellSize * 0.02); shadowApplied = true; }
                }
                ctx.beginPath();
                for (let y = minVisibleY; y < maxVisibleY; y++) {
                    for (let x = minVisibleX; x < maxVisibleX; x++) {
                        const cell = this.maze.grid[y]?.[x]; if (!cell) continue;
                        const drawX = Math.round(x * currentCellSize + offsetX); const drawY = Math.round(y * currentCellSize + offsetY);
                        if (drawX + currentCellSize < -ctx.lineWidth || drawX > canvasW + ctx.lineWidth || drawY + currentCellSize < -ctx.lineWidth || drawY > canvasH + ctx.lineWidth) continue;
                        const drawX_right = Math.round(drawX + currentCellSize); const drawY_bottom = Math.round(drawY + currentCellSize);
                        if (cell.walls.top) { ctx.moveTo(drawX, drawY); ctx.lineTo(drawX_right, drawY); }
                        if (cell.walls.right) { ctx.moveTo(drawX_right, drawY); ctx.lineTo(drawX_right, drawY_bottom); }
                        if (cell.walls.bottom) { ctx.moveTo(drawX_right, drawY_bottom); ctx.lineTo(drawX, drawY_bottom); }
                        if (cell.walls.left) { ctx.moveTo(drawX, drawY_bottom); ctx.lineTo(drawX, drawY); }
                    }
                }
                ctx.stroke();
                if (shadowApplied) { ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; }

                 // Draw Exit Marker
                if (this.exitMarker && currentCellSize > 10 && this.maze.end.x >= minVisibleX && this.maze.end.x < maxVisibleX && this.maze.end.y >= minVisibleY && this.maze.end.y < maxVisibleY) {
                    const markerSize = currentCellSize * this.endMarkerSizeFactor; const markerX = endDrawX + currentCellSize / 2; const markerY = endDrawY + currentCellSize / 2 + markerSize * 0.1;
                    ctx.font = `${markerSize * 0.8}px ${getCssVariable('--font-family')}`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = this.wallColor; ctx.fillText(this.exitMarker, markerX, markerY);
                }

                // Draw Player
                const playerWorldX = this.player.pixelX * currentCellSize; const playerWorldY = this.player.pixelY * currentCellSize;
                this.drawPlayer(ctx, playerWorldX, playerWorldY, offsetX, offsetY);

                // Draw Minimap
                if (this.minimap) this.minimap.draw();
            }
         }
         drawPlayer(ctx, worldX, worldY, offsetX, offsetY) {
             const currentCellSize = this.cellSize; const centerX = worldX + offsetX + currentCellSize / 2; const centerY = worldY + offsetY + currentCellSize / 2;
             const playerRadius = Math.max(1, (currentCellSize * this.playerSizeFactor) / 2);
             if (!this.player || !this.player.color) return;
             ctx.fillStyle = this.player.color;
             const canShowEffects = currentCellSize > EFFECTS_MIN_CELL_SIZE; let shadowApplied = false;
             // Draw Glow
             if (canShowEffects && this.playerGlow && this.playerGlow !== 'transparent' && this.playerGlow !== 'none') { ctx.shadowColor = this.playerGlow; ctx.shadowBlur = Math.max(5, currentCellSize * 0.25); ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; ctx.beginPath(); ctx.arc(centerX, centerY, playerRadius, 0, Math.PI * 2); ctx.fill(); shadowApplied = true; }
             if (shadowApplied) { ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; shadowApplied = false; }
             // Draw Main Circle
             ctx.beginPath(); ctx.arc(centerX, centerY, playerRadius, 0, Math.PI * 2); ctx.fill();
             // Draw Shadow
             if (canShowEffects && this.playerShadow && this.playerShadow !== 'transparent' && this.playerShadow !== 'none') { ctx.shadowColor = this.playerShadow; ctx.shadowBlur = Math.max(3, currentCellSize * 0.1); ctx.shadowOffsetX = Math.max(1, currentCellSize * 0.03); ctx.shadowOffsetY = Math.max(1, currentCellSize * 0.03); ctx.fill(); shadowApplied = true; }
             if (shadowApplied) { ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; }
         }
         drawMazeStaticToOffscreen() {
            if (this.viewMode === 'playerCamera' && !this.isPrinting) { console.warn("drawMazeStaticToOffscreen called unexpectedly in playerCamera mode (non-print)"); return; }
            if (!this.maze || this.maze.width <= 0 || this.maze.height <= 0) { console.warn("drawMazeStaticToOffscreen skipped: no valid maze."); if (this.wallCanvas.width > 0) this.wallCtx.clearRect(0, 0, this.wallCanvas.width, this.wallCanvas.height); return; }
            const currentCellSize = this.cellSize; if (currentCellSize <= 0) { console.warn(`drawMazeStaticToOffscreen skipped: invalid cellSize ${currentCellSize}`); return; }
            const canvasW = Math.ceil(this.maze.width * currentCellSize); const canvasH = Math.ceil(this.maze.height * currentCellSize);
            if (canvasW <= 0 || canvasH <= 0) { console.warn(`drawMazeStaticToOffscreen skipped: invalid calculated canvas size ${canvasW}x${canvasH}`); return; }
            if (this.wallCanvas.width !== canvasW || this.wallCanvas.height !== canvasH) { this.wallCanvas.width = canvasW; this.wallCanvas.height = canvasH; console.log(`Renderer: Resized offscreen wallCanvas to ${canvasW}x${canvasH}`); }
            const ctx = this.wallCtx; ctx.clearRect(0, 0, this.wallCanvas.width, this.wallCanvas.height);
            // Draw Start/End Backgrounds
            ctx.fillStyle = this.startColor; ctx.fillRect(this.maze.start.x * currentCellSize, this.maze.start.y * currentCellSize, currentCellSize, currentCellSize);
            ctx.fillStyle = this.endColor; ctx.fillRect(this.maze.end.x * currentCellSize, this.maze.end.y * currentCellSize, currentCellSize, currentCellSize);
            // Draw Walls
            ctx.strokeStyle = this.wallColor; ctx.lineWidth = Math.max(1, currentCellSize * this.wallThicknessFactor); ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            const canShowEffects = currentCellSize > EFFECTS_MIN_CELL_SIZE; let shadowApplied = false;
             if (canShowEffects) {
                 if (this.wallGlow && this.wallGlow !== 'transparent' && this.wallGlow !== 'none') { ctx.shadowColor = this.wallGlow; ctx.shadowBlur = Math.max(3, currentCellSize * 0.15); ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; shadowApplied = true; }
                 else if (this.wallShadow && this.wallShadow !== 'transparent' && this.wallShadow !== 'none') { ctx.shadowColor = this.wallShadow; ctx.shadowBlur = Math.max(2, currentCellSize * 0.05); ctx.shadowOffsetX = Math.max(1, currentCellSize * 0.02); ctx.shadowOffsetY = Math.max(1, currentCellSize * 0.02); shadowApplied = true; }
             }
            ctx.beginPath();
            for (let y = 0; y < this.maze.height; y++) {
                for (let x = 0; x < this.maze.width; x++) {
                    const cell = this.maze.grid[y]?.[x]; if (!cell) continue;
                    const cx = x * currentCellSize; const cy = y * currentCellSize; const cew = cx + currentCellSize; const ceh = cy + currentCellSize;
                    if (cell.walls.top) { ctx.moveTo(cx, cy); ctx.lineTo(cew, cy); } if (cell.walls.right) { ctx.moveTo(cew, cy); ctx.lineTo(cew, ceh); }
                    if (cell.walls.bottom) { ctx.moveTo(cew, ceh); ctx.lineTo(cx, ceh); } if (cell.walls.left) { ctx.moveTo(cx, ceh); ctx.lineTo(cx, cy); }
                }
            }
            ctx.stroke();
            if (shadowApplied) { ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; }
            // Draw Exit Marker
            if (this.exitMarker && currentCellSize > 10) {
                const markerSize = currentCellSize * this.endMarkerSizeFactor; const markerX = this.maze.end.x * currentCellSize + currentCellSize / 2; const markerY = this.maze.end.y * currentCellSize + currentCellSize / 2 + markerSize * 0.1;
                ctx.font = `${markerSize * 0.8}px ${getCssVariable('--font-family')}`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = this.wallColor; ctx.fillText(this.exitMarker, markerX, markerY);
            }
         }
         prepareForPrint() {
            if (!this.maze || !this.player || !this.maze.generationComplete) return null;
            console.log("Renderer: Preparing for print..."); this.isPrinting = true;
            const savedState = { /* ... (state saving as before) ... */
                 currentViewMode: this.viewMode, currentDarkMode: document.body.classList.contains('dark-mode'),
                 oldCanvasWidth: this.canvas.width, oldCanvasHeight: this.canvas.height,
                 oldElementWidth: this.canvas.style.width, oldElementHeight: this.canvas.style.height,
                 oldElementLeft: this.canvas.style.left, oldElementTop: this.canvas.style.top,
                 oldCellSize: this.cellSize,
                 originalWallColor: this.wallColor, originalBgColor: this.bgColor, originalStartColor: this.startColor, originalEndColor: this.endColor,
                 originalPlayerColor: this.player.color, originalWallGlow: this.wallGlow, originalWallShadow: this.wallShadow,
                 originalPlayerGlow: this.playerGlow, originalPlayerShadow: this.playerShadow,
                 originalWallThickness: this.wallThicknessFactor, originalPlayerSize: this.playerSizeFactor,
                 originalEndMarkerSize: this.endMarkerSizeFactor, originalExitMarker: this.exitMarker };
             if (savedState.currentDarkMode) document.body.classList.remove('dark-mode');
             this.viewMode = 'overview';
             const PRINT_RESOLUTION_BASE = 2400; const aspect = this.maze.width / this.maze.height;
             let printCellSize; if (aspect >= 1) { printCellSize = Math.max(1, Math.floor(PRINT_RESOLUTION_BASE / this.maze.width)); } else { printCellSize = Math.max(1, Math.floor(PRINT_RESOLUTION_BASE / this.maze.height)); }
             printCellSize = Math.max(printCellSize, 1); const printCanvasWidth = this.maze.width * printCellSize; const printCanvasHeight = this.maze.height * printCellSize;
             this.cellSize = printCellSize; this.wallColor = '#000000'; this.bgColor = '#ffffff'; this.startColor = '#e0e0e0'; this.endColor = '#cccccc';
             this.wallGlow = 'transparent'; this.wallShadow = 'transparent'; this.playerGlow = 'transparent'; this.playerShadow = 'transparent'; const printPlayerColor = '#aaaaaa';
             this.wallThicknessFactor = 0.1; this.playerSizeFactor = 0.6; this.endMarkerSizeFactor = 0.7; this.exitMarker = savedState.originalExitMarker;
             this.canvas.style.width = `${printCanvasWidth}px`; this.canvas.style.height = `${printCanvasHeight}px`; this.canvas.style.left = '0px'; this.canvas.style.top = '0px';
             this.canvas.width = printCanvasWidth; this.canvas.height = printCanvasHeight;
             this.needsWallRedraw = true; this.drawMazeStaticToOffscreen();
             const ctx = this.ctx; ctx.fillStyle = this.bgColor; ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); ctx.drawImage(this.wallCanvas, 0, 0);
             if (this.cellSize >= 1) { const playerDrawX = this.player.x * this.cellSize; const playerDrawY = this.player.y * this.cellSize; const originalDrawColor = this.player.color; this.player.color = printPlayerColor; this.drawPlayer(ctx, playerDrawX, playerDrawY, 0, 0); this.player.color = originalDrawColor; }
             console.log(`Renderer: Prepared print canvas ${printCanvasWidth}x${printCanvasHeight}, cellSize=${printCellSize}`);
             return savedState;
         }
         restoreAfterPrint(savedState) {
             if (!savedState) return; console.log("Renderer: Restoring after print...");
             this.wallColor = savedState.originalWallColor; this.bgColor = savedState.originalBgColor; this.startColor = savedState.originalStartColor; this.endColor = savedState.originalEndColor;
             this.wallGlow = savedState.originalWallGlow; this.wallShadow = savedState.originalWallShadow; this.playerGlow = savedState.originalPlayerGlow; this.playerShadow = savedState.originalPlayerShadow;
             this.wallThicknessFactor = savedState.originalWallThickness; this.playerSizeFactor = savedState.originalPlayerSize; this.endMarkerSizeFactor = savedState.originalEndMarkerSize; this.exitMarker = savedState.originalExitMarker;
             if (this.player) this.player.color = savedState.originalPlayerColor;
             this.canvas.width = savedState.oldCanvasWidth; this.canvas.height = savedState.oldCanvasHeight;
             this.canvas.style.width = savedState.oldElementWidth; this.canvas.style.height = savedState.oldElementHeight;
             this.canvas.style.left = savedState.oldElementLeft; this.canvas.style.top = savedState.oldElementTop;
             this.cellSize = savedState.oldCellSize;
             if (savedState.currentDarkMode) document.body.classList.add('dark-mode');
             if (this.minimap) this.minimap.updateColors();
             this.isPrinting = false;
             this.setViewMode(savedState.currentViewMode);
             this.needsWallRedraw = true;
             requestAnimationFrame(() => this.drawFrame());
             console.log("Renderer: Restored state after printing.");
         }
    }

    // --- Game Controller Logic ---
    class Game {
        constructor() {
             this.mazeGenerator = new MazeGenerator();
             this.renderer = new Renderer('mazeCanvas', 'maze-container');
             this.minimap = new Minimap('minimapCanvas', 'minimapContainer');
             this.renderer.setMinimap(this.minimap);
             this.player = null;
             this.gameActive = false;
             this.lastTimestamp = 0;
             this.animationFrameId = null;
             this.isLoading = false;
             // Timer state
             this.gameStartTime = 0; this.gameTimer = null; this.currentTime = 0; this.timerStarted = false;
             // Best times storage
             this.bestTimes = JSON.parse(localStorage.getItem('mazeBestTimes') || '{}');
             // Touch state
             this.touchStartX = 0; this.touchStartY = 0; this.touchEndX = 0; this.touchEndY = 0;
             // UI Element Refs
             this.widthInput = document.getElementById('modal-width');
             this.heightInput = document.getElementById('modal-height');
             this.darkModeToggle = document.getElementById('modal-darkModeToggle');
             this.mazeStyleGroup = document.getElementById('modal-mazeStyle');
             this.playerChoiceGroup = document.getElementById('modal-playerChoice');
             this.exitChoiceGroup = document.getElementById('modal-exitChoice');
             this.viewModeBtn = document.getElementById('viewModeBtn');
             // Scores Modal Refs
             this.scoresModal = document.getElementById('scores-modal');
             this.scoresModalBackdrop = document.getElementById('scores-modal-backdrop');
             this.scoresListContainer = document.getElementById('scores-list-container');
             this.noScoresMessage = this.scoresModal.querySelector('.no-scores-message');
             this.clearScoresBtn = document.getElementById('clearScoresBtn');

             // --- NUEVO: Estadísticas Persistentes ---
             this.statsKey = 'mazeGameStats_v1'; // Cambiar versión si la estructura cambia mucho
             this.gameStats = {}; // Se inicializará en loadStats
             // --------------------------------------

             // Initial setup
             this.loadStats(); // Cargar estadísticas ANTES de bindUI o applyInitialSettings
             this.bindUI();
             this.applyInitialSettings();
             // Delay first game start slightly to allow layout calculation
             requestAnimationFrame(() => {
                 this.startNewGame('initial_load');
             });
        }

        // --- NUEVO: Métodos para Estadísticas ---
        loadStats() {
            try {
                const storedStats = localStorage.getItem(this.statsKey);
                if (storedStats) {
                    this.gameStats = JSON.parse(storedStats);
                    // Asegurar que todas las claves esperadas existan (para compatibilidad futura)
                    this.gameStats.total_played = this.gameStats.total_played || 0;
                    this.gameStats.total_completed = this.gameStats.total_completed || 0;
                    this.gameStats.completions_by_resolution = this.gameStats.completions_by_resolution || {};
                    this.gameStats.completions_by_style = this.gameStats.completions_by_style || {};
                    this.gameStats.completions_by_player_color = this.gameStats.completions_by_player_color || {};
                    this.gameStats.completions_by_exit_marker = this.gameStats.completions_by_exit_marker || {};
                    this.gameStats.view_mode_switches = this.gameStats.view_mode_switches || 0;
                    console.log("Game stats loaded:", this.gameStats);
                } else {
                    this.resetStatsObject(); // Inicializar si no hay nada guardado
                    console.log("No game stats found, initialized new object.");
                }
            } catch (e) {
                console.error("Error loading game stats from localStorage:", e);
                 trackEvent('exception', {
                      'description': `Error loading localStorage stats: ${e.message}`,
                      'fatal': false
                    });
                this.resetStatsObject(); // Resetear en caso de error de parseo
            }
        }

        saveStats() {
            try {
                localStorage.setItem(this.statsKey, JSON.stringify(this.gameStats));
                // console.log("Game stats saved."); // Descomentar para depuración intensiva
            } catch (e) {
                console.error("Error saving game stats to localStorage:", e);
                 trackEvent('exception', {
                      'description': `Error saving localStorage stats: ${e.message}`,
                      'fatal': false
                    });
            }
        }

        resetStatsObject() {
             this.gameStats = {
                total_played: 0,
                total_completed: 0,
                completions_by_resolution: {},
                completions_by_style: {},
                completions_by_player_color: {},
                completions_by_exit_marker: {},
                view_mode_switches: 0
            };
        }

        // Incrementa un contador de nivel superior
        incrementStat(statName) {
            if (typeof this.gameStats[statName] === 'number') {
                this.gameStats[statName]++;
            } else {
                this.gameStats[statName] = 1;
                console.warn(`Stat '${statName}' was not a number, initialized to 1.`);
            }
            // No guardamos aquí, se guarda después de un grupo de incrementos
        }

        // Incrementa un contador dentro de un objeto anidado
        incrementNestedStat(parentStatName, key) {
            if (!this.gameStats[parentStatName]) {
                this.gameStats[parentStatName] = {};
            }
            const parentObj = this.gameStats[parentStatName];
            if (typeof parentObj[key] === 'number') {
                parentObj[key]++;
            } else {
                parentObj[key] = 1;
            }
            // No guardamos aquí
        }
        // --------------------------------------

         bindUI() {
             // Bottom Nav
             document.getElementById('newGameBtn').addEventListener('click', () => this.startNewGame('new_game_button'));
             this.viewModeBtn.addEventListener('click', () => this.toggleViewMode());
             document.getElementById('scoresBtn').addEventListener('click', () => this.openScoresModal());
             document.getElementById('settingsBtn').addEventListener('click', () => this.openSettingsModal());

             // Settings Modal
             document.getElementById('closeSettingsBtn').addEventListener('click', () => this.closeSettingsModal());
             document.getElementById('settings-modal-backdrop').addEventListener('click', () => this.closeSettingsModal());
             this.widthInput.addEventListener('input', () => this.validateDimensionsAndUpdateBestTime()); // Valida en input
             this.widthInput.addEventListener('change', (e) => { // Trackea en change
                const newValue = clamp(parseInt(e.target.value || MIN_MAZE_DIMENSION, 10), MIN_MAZE_DIMENSION, parseInt(e.target.max));
                trackEvent('change_setting', { 'setting_name': 'width', 'setting_value': newValue });
             });
             this.heightInput.addEventListener('input', () => this.validateDimensionsAndUpdateBestTime()); // Valida en input
             this.heightInput.addEventListener('change', (e) => { // Trackea en change
                const newValue = clamp(parseInt(e.target.value || MIN_MAZE_DIMENSION, 10), MIN_MAZE_DIMENSION, parseInt(e.target.max));
                trackEvent('change_setting', { 'setting_name': 'height', 'setting_value': newValue });
             });
             document.getElementById('modal-generateBtn').addEventListener('click', () => {
                 this.closeSettingsModal();
                 setTimeout(() => this.startNewGame('settings_modal'), 50);
             });
             this.darkModeToggle.addEventListener('change', (e) => {
                 const isDark = e.target.checked;
                 trackEvent('change_setting', { 'setting_name': 'darkMode', 'setting_value': isDark ? 'true' : 'false' });
                 this.setDarkMode(isDark);
             });
             this.mazeStyleGroup.addEventListener('change', (e) => {
                 if (e.target.checked) {
                     const newStyle = e.target.value;
                     trackEvent('change_setting', { 'setting_name': 'mazeStyle', 'setting_value': newStyle });
                     this.setMazeStyle(newStyle);
                 }
             });
             this.playerChoiceGroup.addEventListener('change', (e) => {
                 if (e.target.checked) {
                     const colorBase = e.target.value;
                     trackEvent('change_setting', { 'setting_name': 'playerColor', 'setting_value': colorBase });
                     this.updatePlayerColor(e.target);
                 }
             });
             this.exitChoiceGroup.addEventListener('change', (e) => {
                 if (e.target.checked) {
                     const newMarker = e.target.value;
                     trackEvent('change_setting', { 'setting_name': 'exitMarker', 'setting_value': newMarker });
                     this.renderer.setExitMarker(newMarker);
                     if (this.gameActive || this.renderer.maze) this.renderer.drawFrame();
                 }
             });
             document.getElementById('modal-printBtn').addEventListener('click', () => this.handlePrint());

             // Scores Modal
             document.getElementById('closeScoresBtn').addEventListener('click', () => this.closeScoresModal());
             this.scoresModalBackdrop.addEventListener('click', () => this.closeScoresModal());
             this.clearScoresBtn.addEventListener('click', () => this.confirmClearScores());

             // Message Overlay
             document.getElementById('playAgainBtn').addEventListener('click', () => {
                 this.hideMessage();
                 this.startNewGame('play_again_button');
             });

             // Input Handlers
             document.addEventListener('keydown', (e) => this.handleKeyDown(e));
             const mazeContainer = document.getElementById('maze-container');
             mazeContainer.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
             mazeContainer.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
             mazeContainer.addEventListener('touchend', (e) => this.handleTouchEnd(e));
             mazeContainer.addEventListener('touchcancel', (e) => this.handleTouchEnd(e));
        }

         toggleViewMode() {
             const currentMode = this.renderer.viewMode;
             const nextMode = currentMode === 'overview' ? 'playerCamera' : 'overview';

             // --- Incrementar Stat y Guardar ---
             this.incrementStat('view_mode_switches');
             this.saveStats();
             // -----------------------------------

             // --- Track Event ---
             trackEvent('change_view_mode', {
                 'new_view_mode': nextMode,
                 'switch_count': this.gameStats.view_mode_switches // Enviar conteo actual
             });
             // --------------------
             this.renderer.setViewMode(nextMode);
         }

         openSettingsModal() {
             trackEvent('modal_interaction', {'modal_type': 'settings', 'interaction': 'open'});
             this.syncModalControls();
             document.getElementById('settings-modal-backdrop').classList.add('visible');
             document.getElementById('settings-modal').classList.add('visible');
             document.getElementById('settingsBtn').classList.add('active');
             document.getElementById('scoresBtn').classList.remove('active');
             if (this.scoresModal.classList.contains('visible')) this.closeScoresModal();
         }

         closeSettingsModal() {
             trackEvent('modal_interaction', {'modal_type': 'settings', 'interaction': 'close'});
             document.getElementById('settings-modal-backdrop').classList.remove('visible');
             document.getElementById('settings-modal').classList.remove('visible');
             document.getElementById('settingsBtn').classList.remove('active');
         }

         openScoresModal() {
             trackEvent('modal_interaction', {'modal_type': 'scores', 'interaction': 'open'});
             this.populateScoresModalContent();
             this.scoresModalBackdrop.classList.add('visible');
             this.scoresModal.classList.add('visible');
             document.getElementById('scoresBtn').classList.add('active');
             document.getElementById('settingsBtn').classList.remove('active');
             if (document.getElementById('settings-modal').classList.contains('visible')) this.closeSettingsModal();
         }

         closeScoresModal() {
             trackEvent('modal_interaction', {'modal_type': 'scores', 'interaction': 'close'});
             this.scoresModalBackdrop.classList.remove('visible');
             this.scoresModal.classList.remove('visible');
             document.getElementById('scoresBtn').classList.remove('active');
         }

         sortMazeSizes(sizeA, sizeB) {
             const [wA, hA] = sizeA.split('x').map(Number); const [wB, hB] = sizeB.split('x').map(Number);
             const areaA = wA * hA; const areaB = wB * hB;
             if (areaA !== areaB) return areaA - areaB;
             if (wA !== wB) return wA - wB;
             return hA - hB;
         }

         populateScoresModalContent() {
             this.scoresListContainer.innerHTML = '';
             const scoreKeys = Object.keys(this.bestTimes);
             if (scoreKeys.length === 0) {
                 if (!this.noScoresMessage) {
                     this.noScoresMessage = document.createElement('div'); this.noScoresMessage.className = 'no-scores-message';
                     this.noScoresMessage.textContent = 'Aún no has completado ningún laberinto. ¡Juega para registrar tus marcas!';
                 }
                 this.noScoresMessage.style.display = 'block'; this.scoresListContainer.appendChild(this.noScoresMessage);
                 this.clearScoresBtn.disabled = true;
             } else {
                 if (this.noScoresMessage) this.noScoresMessage.style.display = 'none';
                 this.clearScoresBtn.disabled = false;
                 scoreKeys.sort(this.sortMazeSizes);
                 scoreKeys.forEach(size => {
                     const time = this.bestTimes[size]; if (time === undefined || time === null) return;
                     const formattedTime = this.formatTime(time);
                     const entryDiv = document.createElement('div'); entryDiv.className = 'score-entry';
                     const sizeSpan = document.createElement('span'); sizeSpan.className = 'score-size'; sizeSpan.textContent = size; sizeSpan.title = size;
                     const timeSpan = document.createElement('span'); timeSpan.className = 'score-time'; timeSpan.textContent = formattedTime;
                     entryDiv.appendChild(sizeSpan); entryDiv.appendChild(timeSpan);
                     this.scoresListContainer.appendChild(entryDiv);
                 });
             }
         }

         confirmClearScores() {
             if (confirm('¿Estás seguro de que quieres borrar todos tus récords guardados? Esta acción no se puede deshacer.')) {
                 // --- Track Event ---
                 const scoreCount = Object.keys(this.bestTimes).length;
                 trackEvent('clear_all_scores', {
                     'score_count_cleared': scoreCount
                 });
                 // --------------------
                 this.clearAllScores();
             }
         }

         clearAllScores() {
             this.bestTimes = {};
             localStorage.removeItem('mazeBestTimes');
             console.log("All best times cleared.");
             this.populateScoresModalContent();
             const modalWidth = this.widthInput?.value || 0; const modalHeight = this.heightInput?.value || 0;
             this.updateBestTimeDisplay(`${modalWidth}x${modalHeight}`, true);
             // Opcional: this.saveStats(); // Guardar por si acaso, aunque no afecte a gameStats
         }

         syncModalControls() {
            const maxInputDim = parseInt(this.widthInput.max);
            this.widthInput.value = clamp(this.mazeGenerator?.width || parseInt(this.widthInput.value), MIN_MAZE_DIMENSION, maxInputDim);
            this.heightInput.value = clamp(this.mazeGenerator?.height || parseInt(this.heightInput.value), MIN_MAZE_DIMENSION, maxInputDim);
            this.darkModeToggle.checked = document.body.classList.contains('dark-mode');
            const currentStyle = document.body.dataset.mazeStyle || 'classic';
            const styleRadio = document.querySelector(`#modal-mazeStyle input[value="${currentStyle}"]`);
            if (styleRadio) styleRadio.checked = true;
            else document.querySelector('#modal-mazeStyle input[value="classic"]').checked = true;
            this.filterPlayerChoicesByStyle(currentStyle);
            const currentPlayerBaseColor = this.getCurrentPlayerColor(true);
            const playerRadio = document.querySelector(`#modal-playerChoice input[value="${currentPlayerBaseColor}"]`);
            if (playerRadio && !playerRadio.parentElement.hidden) { playerRadio.checked = true; }
            else { const firstVisibleChoice = document.querySelector('#modal-playerChoice input[name="modal-player"]:not([data-style-specific]):not([hidden])'); if (firstVisibleChoice) firstVisibleChoice.checked = true; else { const absoluteFallback = document.querySelector('#modal-playerChoice input[name="modal-player"]'); if (absoluteFallback) absoluteFallback.checked = true; } }
            this.updatePlayerColorVisuals(this.darkModeToggle.checked);
            const currentExit = this.renderer.exitMarker || '🏁';
            const exitRadio = document.querySelector(`#modal-exitChoice input[value="${currentExit}"]`);
            if (exitRadio) exitRadio.checked = true; else document.querySelector('#modal-exitChoice input[value="🏁"]').checked = true;
            this.updateBestTimeDisplay(`${this.widthInput.value}x${this.heightInput.value}`, true);
         }

         applyInitialSettings() {
            const isLikelyMobile = window.innerWidth < MOBILE_BREAKPOINT_WIDTH;
            const maxInputDim = isLikelyMobile ? MOBILE_MAX_INPUT_DIMENSION : MAX_MAZE_DIMENSION;
            this.widthInput.max = maxInputDim; this.heightInput.max = maxInputDim;
             if (this.widthInput.previousElementSibling?.tagName === 'LABEL') { this.widthInput.previousElementSibling.textContent = `Ancho (${MIN_MAZE_DIMENSION}-${maxInputDim}):`; }
             if (this.heightInput.previousElementSibling?.tagName === 'LABEL') { this.heightInput.previousElementSibling.textContent = `Alto (${MIN_MAZE_DIMENSION}-${maxInputDim}):`; }
            this.widthInput.value = clamp(parseInt(this.widthInput.value || 15), MIN_MAZE_DIMENSION, maxInputDim);
            this.heightInput.value = clamp(parseInt(this.heightInput.value || 15), MIN_MAZE_DIMENSION, maxInputDim);
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            this.setDarkMode(prefersDark); this.darkModeToggle.checked = prefersDark;
             const initialStyle = document.querySelector('#modal-mazeStyle input:checked')?.value || 'classic';
            this.setMazeStyle(initialStyle);
             if (!document.querySelector('#modal-playerChoice input:checked') || document.querySelector('#modal-playerChoice input:checked').parentElement.hidden) { const firstVisibleChoice = document.querySelector(`#modal-playerChoice label:not([hidden]) input`); if (firstVisibleChoice) firstVisibleChoice.checked = true; }
            this.updatePlayerColor(document.querySelector('#modal-playerChoice input:checked'));
            this.renderer.setExitMarker(document.querySelector('#modal-exitChoice input:checked')?.value || '🏁');
             this.viewModeBtn.title = this.renderer.viewMode === 'overview' ? 'Cambiar Vista (Actual: General)' : 'Cambiar Vista (Actual: Jugador)';
         }

         validateDimensions() {
             const maxDim = parseInt(this.widthInput.max);
             this.widthInput.value = clamp(parseInt(this.widthInput.value || MIN_MAZE_DIMENSION, 10), MIN_MAZE_DIMENSION, maxDim);
             this.heightInput.value = clamp(parseInt(this.heightInput.value || MIN_MAZE_DIMENSION, 10), MIN_MAZE_DIMENSION, maxDim);
         }

         validateDimensionsAndUpdateBestTime() {
             this.validateDimensions();
             this.updateBestTimeDisplay(`${this.widthInput.value}x${this.heightInput.value}`, true);
         }

         startTimer() {
             if (this.timerStarted) return;
             this.timerStarted = true; this.gameStartTime = Date.now(); this.currentTime = 0; this.updateTimerDisplay();
             clearInterval(this.gameTimer);
             this.gameTimer = setInterval(() => { this.currentTime = Math.floor((Date.now() - this.gameStartTime) / 1000); this.updateTimerDisplay(); }, 1000);
             console.log("Timer started");
         }

         resetTimer() {
             clearInterval(this.gameTimer); this.gameTimer = null; this.timerStarted = false; this.currentTime = 0; this.updateTimerDisplay();
             console.log("Timer reset");
         }

         stopTimer() {
             clearInterval(this.gameTimer); const finalTime = this.currentTime;
             const mazeSize = `${this.mazeGenerator.width}x${this.mazeGenerator.height}`; let isNewBest = false;
             if (!this.bestTimes[mazeSize] || finalTime < this.bestTimes[mazeSize]) {
                 this.bestTimes[mazeSize] = finalTime; localStorage.setItem('mazeBestTimes', JSON.stringify(this.bestTimes)); isNewBest = true;
                 // --- Track New Best Time ---
                 trackEvent('new_best_time_set', {
                     'level_name': mazeSize,
                     'maze_width': this.mazeGenerator.width,
                     'maze_height': this.mazeGenerator.height,
                     'maze_style': document.body.dataset.mazeStyle || 'classic',
                     'time_seconds': finalTime,
                     'value': finalTime // GA recomienda usar 'value'
                 });
                 // --------------------------
                 console.log(`New best time for ${mazeSize}: ${finalTime}s`);
                 this.updateBestTimeDisplay(mazeSize, true); if (this.scoresModal.classList.contains('visible')) { this.populateScoresModalContent(); }
             }
             console.log(`Timer stopped. Final time: ${finalTime}s`);
             return { time: finalTime, isNewBest: isNewBest };
         }

         formatTime(totalSeconds) {
             if (totalSeconds === undefined || totalSeconds === null || totalSeconds < 0) return '--:--:--';
             const hours = Math.floor(totalSeconds / 3600); const minutes = Math.floor((totalSeconds % 3600) / 60); const seconds = totalSeconds % 60;
             if (hours > 0) { return `${hours.toString()}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; }
             else { return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; }
         }

         updateTimerDisplay() {
             const displayTime = this.currentTime >= 3600 ? this.formatTime(this.currentTime) : this.formatTime(this.currentTime).split(':').slice(-2).join(':');
             document.getElementById('current-time').textContent = displayTime;
         }

         updateBestTimeDisplay(mazeSize, targetModal = false) {
             const bestTime = this.bestTimes[mazeSize]; let timeStr = '--:--';
             if (bestTime !== undefined && bestTime !== null) { timeStr = this.formatTime(bestTime); }
             const label = `Record (${mazeSize === '0x0' || !mazeSize ? 'N/A' : mazeSize}): ${timeStr}`;
             if (targetModal) { const bestTimeEl = document.getElementById('best-time-modal'); if (bestTimeEl) bestTimeEl.textContent = label; }
         }

        async startNewGame(method = 'unknown') {
            if (document.getElementById('settings-modal').classList.contains('visible')) { this.closeSettingsModal(); await new Promise(resolve => setTimeout(resolve, 50)); }
            if (document.getElementById('scores-modal').classList.contains('visible')) { this.closeScoresModal(); await new Promise(resolve => setTimeout(resolve, 50)); }
            if (this.isLoading) { console.warn("Attempted to start new game while already loading."); return; }

            this.isLoading = true; this.gameActive = false; this.stopGameLoop(); this.showLoading(true, 'Generando...');
            this.hideMessage(); this.resetTimer();
            document.getElementById('newGameBtn').disabled = true; this.viewModeBtn.disabled = true;
            document.getElementById('settingsBtn').disabled = true; document.getElementById('scoresBtn').disabled = true;

            // --- Incrementar Stat y Guardar ---
            this.incrementStat('total_played');
            this.saveStats();
            // -----------------------------------

            try {
                this.validateDimensions();
                const width = parseInt(this.widthInput.value); const height = parseInt(this.heightInput.value); const isDark = this.darkModeToggle.checked;
                const currentStyle = document.querySelector('#modal-mazeStyle input:checked')?.value || 'classic'; const playerColorBase = this.getCurrentPlayerColor(true);
                const initialExitMarker = document.querySelector('#modal-exitChoice input:checked')?.value || '🏁';
                const genStartTime = performance.now();

                this.setDarkMode(isDark); // Asegurar consistencia
                this.setMazeStyle(currentStyle, true);
                this.renderer.setExitMarker(initialExitMarker);

                const maze = await this.mazeGenerator.generate(width, height, (progress) => { this.showLoading(true, `Generando... ${Math.round(progress * 100)}%`); });
                const genEndTime = performance.now(); const genDuration = Math.round(genEndTime - genStartTime);

                if (!maze || !maze.grid) throw new Error("Maze generation failed unexpectedly.");

                // --- Track Event (Generación) ---
                trackEvent('generate_maze', {
                    'maze_width': width, 'maze_height': height, 'maze_style': currentStyle, 'player_color': playerColorBase,
                    'exit_marker': initialExitMarker, 'dark_mode': isDark, 'generation_method': method,
                    'generation_time_ms': genDuration, 'total_played_count': this.gameStats.total_played
                });
                // ---------------------------------

                // Setup Renderer and Player
                this.player = new Player(maze.start.x, maze.start.y, this.getCurrentPlayerColor());
                this.renderer.setMaze(maze); this.renderer.setPlayer(this.player);
                this.renderer.setViewMode(this.viewModeBtn.dataset.mode || 'overview');

                const currentMazeSize = `${maze.width}x${maze.height}`; this.updateBestTimeDisplay(currentMazeSize, true);

                this.gameActive = true; this.lastTimestamp = performance.now(); this.startGameLoop();
                console.log("New game started successfully.");

            } catch (error) {
                trackEvent('exception', { 'description': `Maze generation failed: ${error.message}`, 'fatal': false });
                console.error("Error starting new game:", error);
                this.showMessage("Error", `No se pudo generar el laberinto.\n(${error.message})`); this.gameActive = false;
            } finally {
                this.showLoading(false); this.isLoading = false;
                document.getElementById('newGameBtn').disabled = false; this.viewModeBtn.disabled = false;
                document.getElementById('settingsBtn').disabled = false; document.getElementById('scoresBtn').disabled = false;
            }
        }

         startGameLoop() {
             if (this.animationFrameId) return; console.log("Starting game loop...");
             let lastLoopTime = performance.now();
             const loop = (timestamp) => {
                 if (!this.gameActive && !this.player?.isMoving && this.renderer.viewMode !== 'playerCamera') { console.log("Game loop stopping (inactive)."); this.animationFrameId = null; return; }
                 const deltaTime = timestamp - lastLoopTime; lastLoopTime = timestamp;
                 if (this.player?.isMoving) this.player.update(deltaTime);
                 if (this.renderer.viewMode === 'playerCamera') this.renderer.updateCamera(deltaTime);
                 this.renderer.drawFrame(timestamp);
                 this.animationFrameId = requestAnimationFrame(loop);
             };
             this.animationFrameId = requestAnimationFrame(loop);
         }

         stopGameLoop() {
             if (this.animationFrameId) { cancelAnimationFrame(this.animationFrameId); this.animationFrameId = null; console.log("Game loop stopped."); }
         }

         handleMoveAttempt(dx, dy, inputMethod = 'unknown') {
             if (!this.gameActive || !this.player || this.isLoading || this.player.isMoving) return;
             const moveResult = this.player.canMove(dx, dy, this.mazeGenerator);
             if (moveResult) {
                 // --- Track first move ---
                 if (!this.timerStarted) {
                     this.startTimer();
                     trackEvent('start_gameplay', {
                         'maze_width': this.mazeGenerator.width, 'maze_height': this.mazeGenerator.height,
                         'maze_style': document.body.dataset.mazeStyle || 'classic', 'input_method': inputMethod,
                     });
                 }
                 // -----------------------
                 this.player.moveTo(moveResult.newX, moveResult.newY);
                 if (!this.animationFrameId) this.startGameLoop();

                 // --- Check de victoria ---
                 if (moveResult.newX === this.mazeGenerator.end.x && moveResult.newY === this.mazeGenerator.end.y) {
                     this.gameActive = false;
                     const finalTimeResult = this.stopTimer();

                     // --- Incrementar Stats de Completado ---
                     const mazeW = this.mazeGenerator.width; const mazeH = this.mazeGenerator.height;
                     const mazeSizeKey = `${mazeW}x${mazeH}`; const currentStyle = document.body.dataset.mazeStyle || 'classic';
                     const playerColorBase = this.getCurrentPlayerColor(true); const currentExitMarker = this.renderer.exitMarker || '🏁';
                     const viewModeOnCompletion = this.renderer.viewMode;

                     this.incrementStat('total_completed');
                     this.incrementNestedStat('completions_by_resolution', mazeSizeKey);
                     this.incrementNestedStat('completions_by_style', currentStyle);
                     this.incrementNestedStat('completions_by_player_color', playerColorBase);
                     this.incrementNestedStat('completions_by_exit_marker', currentExitMarker);
                     this.saveStats();
                     // -----------------------------------------

                     // --- Track Event (Victoria) ---
                     trackEvent('level_end', {
                         'level_name': mazeSizeKey, 'maze_width': mazeW, 'maze_height': mazeH,
                         'maze_style': currentStyle, 'player_color': playerColorBase, 'exit_marker': currentExitMarker,
                         'time_seconds': finalTimeResult.time, 'value': finalTimeResult.time,
                         'is_new_record': finalTimeResult.isNewBest, 'success': true,
                         'view_mode_at_completion': viewModeOnCompletion,
                         'total_completed_count': this.gameStats.total_completed
                     });
                     // ---------------------------------

                     // Delay showing the message
                     setTimeout(() => {
                         if (this.player && Math.round(this.player.pixelX) === this.mazeGenerator.end.x && Math.round(this.player.pixelY) === this.mazeGenerator.end.y) {
                             const finalTimeStr = this.formatTime(finalTimeResult.time); const mazeSize = `${this.mazeGenerator.width}x${this.mazeGenerator.height}`;
                             if (finalTimeResult.isNewBest) { this.showMessage("¡Nuevo Récord! 🏆", "¡Increíble! Has establecido un nuevo récord.", finalTimeStr, `Récord (${mazeSize}): ${finalTimeStr}`); }
                             else { const bestTime = this.bestTimes[mazeSize]; const bestTimeStr = bestTime !== undefined ? this.formatTime(bestTime) : '--:--'; this.showMessage("¡Completado! 🎉", "Has encontrado la salida del laberinto.", finalTimeStr, `Mejor tiempo (${mazeSize}): ${bestTimeStr}`); }
                         } else { console.warn("Win condition met, but player not at end coords after delay. Showing generic win message."); this.showMessage("¡Completado! 🎉", "Has encontrado la salida del laberinto."); }
                     }, PLAYER_SMOOTHING * 800);
                 }
             } else {
                 // trackEvent('player_move_fail', { /* ... */ });
             }
         }

         handleKeyDown(e) {
             if (document.getElementById('settings-modal').classList.contains('visible') || document.getElementById('scores-modal').classList.contains('visible') || !this.gameActive || this.isLoading) return;
             let dx = 0; let dy = 0;
             switch (e.key) {
                 case 'ArrowUp': case 'w': case 'W': dy = -1; break;
                 case 'ArrowDown': case 's': case 'S': dy = 1; break;
                 case 'ArrowLeft': case 'a': case 'A': dx = -1; break;
                 case 'ArrowRight': case 'd': case 'D': dx = 1; break;
                 default: return;
             }
             e.preventDefault();
             this.handleMoveAttempt(dx, dy, 'keyboard'); // <-- Pasar método
         }

         handleTouchStart(e) {
             if (document.getElementById('settings-modal').classList.contains('visible') || document.getElementById('scores-modal').classList.contains('visible') || !this.gameActive || this.isLoading || e.touches.length !== 1) return;
             this.touchStartX = e.touches[0].clientX; this.touchStartY = e.touches[0].clientY;
             this.touchEndX = this.touchStartX; this.touchEndY = this.touchStartY;
         }

         handleTouchMove(e) {
             if (document.getElementById('settings-modal').classList.contains('visible') || document.getElementById('scores-modal').classList.contains('visible') || !this.gameActive || this.isLoading || e.touches.length !== 1) return;
             this.touchEndX = e.touches[0].clientX; this.touchEndY = e.touches[0].clientY;
             e.preventDefault();
         }

         handleTouchEnd(e) {
            if (document.getElementById('settings-modal').classList.contains('visible') || document.getElementById('scores-modal').classList.contains('visible') || !this.gameActive || this.isLoading) return;
             if (this.touchStartX === 0 && this.touchStartY === 0) return;
             const deltaX = this.touchEndX - this.touchStartX; const deltaY = this.touchEndY - this.touchStartY;
             const absDeltaX = Math.abs(deltaX); const absDeltaY = Math.abs(deltaY);
             let dx = 0; let dy = 0;
             if (Math.max(absDeltaX, absDeltaY) > SWIPE_THRESHOLD) {
                 if (absDeltaX > absDeltaY) dx = deltaX > 0 ? 1 : -1; else dy = deltaY > 0 ? 1 : -1;
                 this.handleMoveAttempt(dx, dy, 'touch_swipe'); // <-- Pasar método
             }
             this.touchStartX = 0; this.touchStartY = 0; this.touchEndX = 0; this.touchEndY = 0;
         }

         setDarkMode(isDark) {
             document.body.classList.toggle('dark-mode', isDark);
             this.updatePlayerColorVisuals(isDark);
             this.updatePlayerColor(document.querySelector('#modal-playerChoice input:checked'));
             if (this.renderer) { this.renderer.updateStyleSettings(true); if (this.gameActive || this.renderer.maze) this.renderer.drawFrame(); }
             console.log(`Dark mode ${isDark ? 'enabled' : 'disabled'}`);
         }

         setMazeStyle(styleName, forceUpdate = false) {
             const currentStyle = document.body.dataset.mazeStyle; if (!forceUpdate && currentStyle === styleName) return;
             document.body.dataset.mazeStyle = styleName; console.log(`Maze style set to: ${styleName}`);
             this.filterPlayerChoicesByStyle(styleName);
             const currentSelectedPlayerRadio = document.querySelector('#modal-playerChoice input:checked');
             if (!currentSelectedPlayerRadio || currentSelectedPlayerRadio.parentElement.hidden) { const firstVisibleChoice = document.querySelector(`#modal-playerChoice label:not([hidden]) input`); if (firstVisibleChoice) firstVisibleChoice.checked = true; else { const fallback = document.querySelector('#modal-playerChoice input[name="modal-player"]'); if(fallback) fallback.checked = true; } }
             this.updatePlayerColor(document.querySelector('#modal-playerChoice input:checked'));
             if (this.renderer) { this.renderer.updateStyleSettings(true); this.renderer.setExitMarker(document.querySelector('#modal-exitChoice input:checked')?.value || '🏁'); if (this.gameActive || this.renderer.maze) this.renderer.drawFrame(); }
         }

         filterPlayerChoicesByStyle(styleName) {
             const playerLabels = document.querySelectorAll('#modal-playerChoice label');
             playerLabels.forEach(label => { const input = label.querySelector('input'); const specificStyle = input.dataset.styleSpecific; label.hidden = specificStyle && specificStyle !== styleName; });
              this.updatePlayerColorVisuals(document.body.classList.contains('dark-mode'));
         }

         updatePlayerColor(radioElement) {
             if (!radioElement || !radioElement.checked) { radioElement = document.querySelector('#modal-playerChoice input:checked'); if (!radioElement) return; }
             const newColor = this.calculatePlayerColor(radioElement);
             if (this.player) { this.player.setColor(newColor); console.log(`Player color updated to: ${newColor}`); if(this.renderer && (this.gameActive || this.renderer.maze)) { this.renderer.drawFrame(); } }
             if (this.minimap) this.minimap.updateColors();
         }

         updatePlayerColorVisuals(isDark) {
             const playerRadios = document.querySelectorAll('#modal-playerChoice input[type="radio"]');
             playerRadios.forEach(radio => { const colorToShow = this.calculatePlayerColor(radio, isDark); const previewSpan = radio.nextElementSibling; if (previewSpan && previewSpan.classList.contains('color-preview')) { previewSpan.style.backgroundColor = colorToShow; } });
         }

         calculatePlayerColor(radioElement, isDark = document.body.classList.contains('dark-mode')) {
              if (!radioElement) return getCssVariable('--player-color');
              const lightColor = radioElement.dataset.light; const darkColor = radioElement.dataset.dark; const baseColor = radioElement.value;
              return isDark ? (darkColor || baseColor) : (lightColor || baseColor);
         }

         getCurrentPlayerColor(getBaseValue = false) {
             const selectedRadio = document.querySelector('#modal-playerChoice input:checked');
             if (!selectedRadio) return getCssVariable('--player-color');
             if (getBaseValue) return selectedRadio.value;
             return this.calculatePlayerColor(selectedRadio);
         }

         showMessage(title, text, finalTimeStr = '', bestTimeMsg = '') {
            trackEvent('modal_interaction', {'modal_type': 'win_message', 'interaction': 'open'});
            const overlay = document.getElementById('message-overlay');
            overlay.querySelector('h2').textContent = title;
            const textParagraph = overlay.querySelector('p:not([id])');
            if (textParagraph) textParagraph.innerHTML = text.replace(/\n/g, '<br>');
            const finalTimeEl = document.getElementById('final-time-msg');
            const bestTimeEl = document.getElementById('final-best-time-msg');
            finalTimeEl.textContent = finalTimeStr ? `Tu Tiempo: ${finalTimeStr}` : '';
            bestTimeEl.textContent = bestTimeMsg;
            finalTimeEl.style.display = finalTimeStr ? 'block' : 'none';
            bestTimeEl.style.display = bestTimeMsg ? 'block' : 'none';
            overlay.classList.add('visible');
            this.gameActive = false; this.stopGameLoop();
            console.log(`Message shown: ${title}`);
         }

         hideMessage() {
             const overlay = document.getElementById('message-overlay');
             if (overlay.classList.contains('visible')) { // Evitar eventos dobles
                trackEvent('modal_interaction', {'modal_type': 'win_message', 'interaction': 'close'});
             }
             overlay.classList.remove('visible');
         }

         showLoading(show, text = 'Generando...') {
            const indicator = document.getElementById('loading-indicator');
            const newGameBtn = document.getElementById('newGameBtn'); const viewModeBtn = this.viewModeBtn;
            const settingsBtn = document.getElementById('settingsBtn'); const scoresBtn = document.getElementById('scoresBtn');
            if (show) {
                indicator.textContent = text; indicator.classList.add('visible');
                if(newGameBtn) newGameBtn.disabled = true; if(viewModeBtn) viewModeBtn.disabled = true;
                if(settingsBtn) settingsBtn.disabled = true; if(scoresBtn) scoresBtn.disabled = true;
            } else {
                indicator.classList.remove('visible');
                if (!this.isLoading) { // Solo habilitar si no está cargando
                     if(newGameBtn) newGameBtn.disabled = false; if(viewModeBtn) viewModeBtn.disabled = false;
                     if(settingsBtn) settingsBtn.disabled = false; if(scoresBtn) scoresBtn.disabled = false;
                }
            }
         }

         handlePrint() {
             if (!this.mazeGenerator?.generationComplete || !this.renderer || !this.player) { alert('Genera un laberinto completo antes de imprimir.'); return; }
             if (this.isLoading || this.renderer.isPrinting) { alert('Espera a que termine la acción actual antes de imprimir.'); return; }
             console.log("Initiating print...");
             // --- Track Event ---
             trackEvent('print_maze', {
                 'maze_width': this.mazeGenerator.width, 'maze_height': this.mazeGenerator.height,
                 'maze_style': document.body.dataset.mazeStyle || 'classic',
                 'player_color': this.getCurrentPlayerColor(true),
                 'exit_marker': this.renderer.exitMarker || '🏁'
             });
             // --------------------
             const savedState = this.renderer.prepareForPrint();
             if (!savedState) { console.error("Failed to prepare renderer for printing."); alert("Error al preparar la impresión."); this.renderer.isPrinting = false; return; }
             setTimeout(() => {
                 try {
                     window.print(); console.log("Print dialog should be open.");
                      setTimeout(() => { this.renderer.restoreAfterPrint(savedState); }, 200);
                 } catch (e) {
                     console.error("Error during window.print():", e); alert("Ocurrió un error al intentar imprimir.");
                     trackEvent('exception', { 'description': `Print execution error: ${e.message}`, 'fatal': false });
                     this.renderer.restoreAfterPrint(savedState);
                 }
             }, 100);
         }
    } // End of Game class

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        requestAnimationFrame(() => { // Use rAF for potentially smoother start
            try {
                 window.mazeGame = new Game();
                 console.log("Maze Game Initialized.");
            } catch (error) {
                 console.error("Failed to initialize Maze Game:", error);
                  trackEvent('exception', { // Trackear error de inicialización
                      'description': `Critical init error: ${error.message}`,
                      'fatal': true
                    });
                 document.body.innerHTML = `<div style="padding: 20px; text-align: center; color: red;">Error crítico al iniciar la aplicación: ${error.message}. Por favor, recarga la página.</div>`;
            }
        });
    });

</script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8RTR00RC0J"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8RTR00RC0J');
</script>
</body>
</html>
