<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Laberinto Pro</title> <!-- Version updated -->

    <!-- Google tag (gtag.js) - TU CÓDIGO DE SEGUIMIENTO -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-8RTR00RC0J"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      // ¡¡IMPORTANTE!! Reemplaza G-XXXXXXXXXX con tu ID de medición real de GA4
      gtag('config', 'G-8RTR00RC0J');
    </script>
    <!-- Fin Google tag -->

    <style>
        /* --- ROOT VARIABLES --- */
        :root {
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --transition-speed: 0.3s;
            --bottom-nav-height: 60px;
            --modal-max-width: 500px;
            --top-ui-height: 40px;

            /* Factors */
            --wall-thickness-factor: 0.1;
            --player-size-factor: 0.6;
            --end-marker-size-factor: 0.7;
            --exploration-reveal-radius-factor: 3.0;
            --exploration-gradient-inner-factor: 0.4;

            /* --- Light Theme Defaults --- */
            --bg-color-light: #f8f9fa; --panel-bg-light: #ffffff; --control-bg-light: #ffffff;
            --text-color-light: #212529; --text-muted-light: #6c757d; --border-color-light: #dee2e6;
            --primary-color-light: #007bff; --primary-hover-light: #0056b3; --shadow-light: rgba(0, 0, 0, 0.08);
            --input-bg-light: #ffffff; --input-border-light: #ced4da; --input-disabled-bg-light: #e9ecef;
            --fog-color-opaque-light: #343a40;
            /* Maze Specific - Light */
            --maze-bg-light: #e9ecef;
            --wall-color-light: #343a40; --wall-glow-light: transparent; --wall-shadow-light: rgba(0, 0, 0, 0.1);
            --player-color-light: #e63946; --player-glow-light: rgba(230, 57, 70, 0.3); --player-shadow-light: rgba(230, 57, 70, 0.4);
            --start-color-light: #a8dadc; --end-color-light: #457b9d; --path-color-light: rgba(227, 242, 253, 0.3);
            --minimap-bg-light: rgba(255, 255, 255, 0.9); --minimap-border-light: #adb5bd;
            --minimap-player-light: var(--player-color-light); --minimap-start-light: var(--start-color-light); --minimap-end-light: var(--end-color-light);

            /* --- Dark Theme Defaults --- */
            --bg-color-dark: #121212; --panel-bg-dark: #1e1e1e; --control-bg-dark: #2a2a2a;
            --text-color-dark: #e0e0e0; --text-muted-dark: #adb5bd; --border-color-dark: #333;
            --primary-color-dark: #4dabf7; --primary-hover-dark: #1e88e5; --shadow-dark: rgba(255, 255, 255, 0.06);
            --input-bg-dark: #252525; --input-border-dark: #444; --input-disabled-bg-dark: #3a3a3a;
            --fog-color-opaque-dark: #000000;
            /* Maze Specific - Dark */
            --maze-bg-dark: #212121;
            --wall-color-dark: #ced4da; --wall-glow-dark: rgba(206, 212, 218, 0.15); --wall-shadow-dark: transparent;
            --player-color-dark: #ff8a80; --player-glow-dark: rgba(255, 138, 128, 0.35); --player-shadow-dark: rgba(255, 138, 128, 0.5);
            --start-color-dark: #546e7a; --end-color-dark: #81d4fa; --path-color-dark: rgba(50, 50, 70, 0.3);
            --minimap-bg-dark: rgba(30, 30, 30, 0.92); --minimap-border-dark: #6c757d;
            --minimap-player-dark: var(--player-color-dark); --minimap-start-dark: var(--start-color-dark); --minimap-end-dark: var(--end-color-dark);

            /* --- Default assignments --- */
            --bg-color: var(--bg-color-light); --panel-bg: var(--panel-bg-light); --control-bg: var(--control-bg-light);
            --text-color: var(--text-color-light); --text-muted: var(--text-muted-light); --border-color: var(--border-color-light);
            --primary-color: var(--primary-color-light); --primary-hover: var(--primary-hover-light); --shadow: var(--shadow-light);
            --input-bg: var(--input-bg-light); --input-border: var(--input-border-light); --input-disabled-bg: var(--input-disabled-bg-light);
            --fog-color-opaque: var(--fog-color-opaque-light);
            --maze-bg: var(--maze-bg-light); --wall-color: var(--wall-color-light); --wall-glow: var(--wall-glow-light); --wall-shadow: var(--wall-shadow-light);
            --player-color: var(--player-color-light); --player-glow: var(--player-glow-light); --player-shadow: var(--player-shadow-light);
            --start-color: var(--start-color-light); --end-color: var(--end-color-light); --path-color: var(--path-color-light);
            --minimap-bg: var(--minimap-bg-light); --minimap-border: var(--minimap-border-light); --minimap-player: var(--minimap-player-light);
            --minimap-start: var(--minimap-start-light); --minimap-end: var(--minimap-end-light);
            --primary-color-rgb: 0, 123, 255; --panel-bg-rgb: 255, 255, 255;
        }

        /* --- Theme Application --- */
        body {
            --bg-color: var(--bg-color-light); --panel-bg: var(--panel-bg-light); --control-bg: var(--control-bg-light);
            --text-color: var(--text-color-light); --text-muted: var(--text-muted-light); --border-color: var(--border-color-light);
            --primary-color: var(--primary-color-light); --primary-hover: var(--primary-hover-light); --shadow: var(--shadow-light);
            --input-bg: var(--input-bg-light); --input-border: var(--input-border-light); --input-disabled-bg: var(--input-disabled-bg-light);
             --fog-color-opaque: var(--fog-color-opaque-light);
            --primary-color-rgb: 0, 123, 255; --panel-bg-rgb: 255, 255, 255;
            --maze-bg: var(--_maze-style-light, var(--maze-bg-light));
            --wall-color: var(--_wall-style-light, var(--wall-color-light));
            --wall-glow: var(--_wall-glow-style-light, var(--wall-glow-light));
            --wall-shadow: var(--_wall-shadow-style-light, var(--wall-shadow-light));
            --player-color: var(--_player-style-light, var(--player-color-light));
            --player-glow: var(--_player-glow-style-light, var(--player-glow-light));
            --player-shadow: var(--_player-shadow-style-light, var(--player-shadow-light));
            --start-color: var(--_start-style-light, var(--start-color-light));
            --end-color: var(--_end-style-light, var(--end-color-light));
            --minimap-bg: var(--_minimap-bg-style-light, var(--minimap-bg-light));
            --minimap-border: var(--_minimap-border-style-light, var(--minimap-border-light));
            --minimap-player: var(--_minimap-player-style-light, var(--player-color));
            --minimap-start: var(--_minimap-start-style-light, var(--start-color-light));
            --minimap-end: var(--_minimap-end-style-light, var(--end-color-light));
        }

        body.dark-mode {
            --bg-color: var(--bg-color-dark); --panel-bg: var(--panel-bg-dark); --control-bg: var(--control-bg-dark);
            --text-color: var(--text-color-dark); --text-muted: var(--text-muted-dark); --border-color: var(--border-color-dark);
            --primary-color: var(--primary-color-dark); --primary-hover: var(--primary-hover-dark); --shadow: var(--shadow-dark);
            --input-bg: var(--input-bg-dark); --input-border: var(--input-border-dark); --input-disabled-bg: var(--input-disabled-bg-dark);
            --fog-color-opaque: var(--fog-color-opaque-dark);
            --primary-color-rgb: 74, 171, 247; --panel-bg-rgb: 30, 30, 30;
            --maze-bg: var(--_maze-style-dark, var(--maze-bg-dark));
            --wall-color: var(--_wall-style-dark, var(--wall-color-dark));
            --wall-glow: var(--_wall-glow-style-dark, var(--wall-glow-dark));
            --wall-shadow: var(--_wall-shadow-style-dark, var(--wall-shadow-dark));
            --player-color: var(--_player-style-dark, var(--player-color-dark));
            --player-glow: var(--_player-glow-style-dark, var(--player-glow-dark));
            --player-shadow: var(--_player-shadow-style-dark, var(--player-shadow-dark));
            --start-color: var(--_start-style-dark, var(--start-color-dark));
            --end-color: var(--_end-style-dark, var(--end-color-dark));
            --minimap-bg: var(--_minimap-bg-style-dark, var(--minimap-bg-dark));
            --minimap-border: var(--_minimap-border-style-dark, var(--minimap-border-dark));
            --minimap-player: var(--_minimap-player-style-dark, var(--player-color));
            --minimap-start: var(--_minimap-start-style-dark, var(--start-color-dark));
            --minimap-end: var(--_minimap-end-style-dark, var(--end-color-dark));
        }

        /* --- Maze Style Definitions (_style-theme variants) --- */
        body[data-maze-style="classic"]{--_maze-style-light:var(--maze-bg-light);--_maze-style-dark:var(--maze-bg-dark);--_wall-style-light:var(--wall-color-light);--_wall-style-dark:var(--wall-color-dark);--_wall-glow-style-light:transparent;--_wall-glow-style-dark:rgba(206,212,218,.1);--_wall-shadow-style-light:rgba(0,0,0,.1);--_wall-shadow-style-dark:transparent;--_player-glow-style-light:var(--player-glow-light);--_player-glow-style-dark:var(--player-glow-dark);--_player-shadow-style-light:var(--player-shadow-light);--_player-shadow-style-dark:var(--player-shadow-dark);--_start-style-light:var(--start-color-light);--_start-style-dark:var(--start-color-dark);--_end-style-light:var(--end-color-light);--_end-style-dark:var(--end-color-dark);--_minimap-bg-style-light:var(--minimap-bg-light);--_minimap-bg-style-dark:var(--minimap-bg-dark);--_minimap-border-style-light:var(--minimap-border-light);--_minimap-border-style-dark:var(--minimap-border-dark);--_minimap-start-style-light:var(--_start-style-light);--_minimap-start-style-dark:var(--_start-style-dark);--_minimap-end-style-light:var(--_end-style-light);--_minimap-end-style-dark:var(--_end-style-dark);--wall-thickness-factor:.1;--player-size-factor:.6}body[data-maze-style=matrix]{--_maze-style-light:#030303;--_maze-style-dark:#000;--_wall-style-light:#00ff41;--_wall-style-dark:#00ff41;--_wall-glow-style-light:rgba(0,255,65,.3);--_wall-glow-style-dark:rgba(0,255,65,.35);--_wall-shadow-style-light:transparent;--_wall-shadow-style-dark:transparent;--_player-glow-style-light:rgba(255,255,255,.4);--_player-glow-style-dark:rgba(255,255,255,.5);--_player-shadow-style-light:transparent;--_player-shadow-style-dark:transparent;--_start-style-light:#00330a;--_start-style-dark:#004d11;--_end-style-light:#00801c;--_end-style-dark:#00cc2e;--_minimap-bg-style-light:rgba(0,20,0,.9);--_minimap-bg-style-dark:rgba(0,10,0,.95);--_minimap-border-style-light:#00ff41;--_minimap-border-style-dark:#00cc2e;--_minimap-start-style-light:var(--_start-style-light);--_minimap-start-style-dark:var(--_start-style-dark);--_minimap-end-style-light:var(--_end-style-light);--_minimap-end-style-dark:var(--_end-style-dark);--wall-thickness-factor:.08;--player-size-factor:.55}body[data-maze-style=blueprint]{--_maze-style-light:#2962ff;--_maze-style-dark:#1a237e;--_wall-style-light:#fff;--_wall-style-dark:#bbdefb;--_wall-glow-style-light:rgba(255,255,255,.1);--_wall-glow-style-dark:rgba(187,222,251,.15);--_wall-shadow-style-light:transparent;--_wall-shadow-style-dark:transparent;--_player-glow-style-light:rgba(255,235,59,.5);--_player-glow-style-dark:rgba(255,245,157,.5);--_player-shadow-style-light:transparent;--_player-shadow-style-dark:transparent;--_start-style-light:#1c50d3;--_start-style-dark:#101649;--_end-style-light:#5c87ff;--_end-style-dark:#3f51b5;--_minimap-bg-style-light:rgba(41,98,255,.85);--_minimap-bg-style-dark:rgba(26,35,126,.9);--_minimap-border-style-light:#fff;--_minimap-border-style-dark:#bbdefb;--_minimap-start-style-light:var(--_start-style-light);--_minimap-start-style-dark:var(--_start-style-dark);--_minimap-end-style-light:var(--_end-style-light);--_minimap-end-style-dark:var(--_end-style-dark);--wall-thickness-factor:.04;--player-size-factor:.65}body[data-maze-style=neon]{--_maze-style-light:#1a1a2e;--_maze-style-dark:#0f0f1a;--_wall-style-light:#ff00ff;--_wall-style-dark:#ff40ff;--_wall-glow-style-light:rgba(255,0,255,.4);--_wall-glow-style-dark:rgba(255,64,255,.5);--_wall-shadow-style-light:transparent;--_wall-shadow-style-dark:transparent;--_player-glow-style-light:rgba(0,255,255,.5);--_player-glow-style-dark:rgba(100,255,255,.6);--_player-shadow-style-light:transparent;--_player-shadow-style-dark:transparent;--_start-style-light:#330033;--_start-style-dark:#4d004d;--_end-style-light:#800080;--_end-style-dark:#b300b3;--_minimap-bg-style-light:rgba(26,26,46,.9);--_minimap-bg-style-dark:rgba(15,15,26,.95);--_minimap-border-style-light:#ff00ff;--_minimap-border-style-dark:#ff40ff;--_minimap-start-style-light:var(--_start-style-light);--_minimap-start-style-dark:var(--_start-style-dark);--_minimap-end-style-light:var(--_end-style-light);--_minimap-end-style-dark:var(--_end-style-dark);--wall-thickness-factor:.1;--player-size-factor:.6}body[data-maze-style=cyber]{--_maze-style-light:#2a004f;--_maze-style-dark:#1a0033;--_wall-style-light:#00ffff;--_wall-style-dark:#7fffd4;--_wall-glow-style-light:rgba(0,255,255,.3);--_wall-glow-style-dark:rgba(127,255,212,.35);--_wall-shadow-style-light:transparent;--_wall-shadow-style-dark:transparent;--_player-glow-style-light:rgba(255,105,180,.5);--_player-glow-style-dark:rgba(255,155,200,.6);--_player-shadow-style-light:transparent;--_player-shadow-style-dark:transparent;--_start-style-light:#480082;--_start-style-dark:#300050;--_end-style-light:#8a2be2;--_end-style-dark:#9370db;--_minimap-bg-style-light:rgba(42,0,79,.9);--_minimap-bg-style-dark:rgba(26,0,51,.95);--_minimap-border-style-light:#00ffff;--_minimap-border-style-dark:#7fffd4;--_minimap-start-style-light:var(--_start-style-light);--_minimap-start-style-dark:var(--_start-style-dark);--_minimap-end-style-light:var(--_end-style-light);--_minimap-end-style-dark:var(--_end-style-dark);--wall-thickness-factor:.08;--player-size-factor:.6}

        /* --- General Layout & UI Elements --- */
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        html, body { height: 100%; width: 100%; }
        body { font-family: var(--font-family); background-color: var(--bg-color); color: var(--text-color); width: 100%; height: 100%; overflow: hidden; display: flex; flex-direction: column; transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease; }

        /* --- Game Mode Menu Styles --- */
        #game-mode-menu { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--bg-color); color: var(--text-color); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 2000; padding: 2rem; transition: opacity var(--transition-speed) ease, visibility 0s linear var(--transition-speed); }
        #game-mode-menu h1 { font-size: 2rem; color: var(--primary-color); margin-bottom: 2rem; text-align: center; }
        .game-mode-button { background-color: var(--primary-color); color: white; border: none; padding: 1rem 2rem; margin: 0.75rem 0; font-size: 1.1rem; font-weight: 500; border-radius: 8px; cursor: pointer; min-width: 220px; text-align: center; transition: background-color var(--transition-speed) ease, transform 0.1s ease; box-shadow: 0 2px 5px var(--shadow); }
        .game-mode-button:hover { background-color: var(--primary-hover); transform: translateY(-2px); }
        .game-mode-button:active { transform: translateY(0); }

        /* --- Game Wrapper Styles --- */
        #game-wrapper { display: none; flex-direction: column; width: 100%; height: 100%; flex-grow: 1; }
        body.game-active-view #game-mode-menu { opacity: 0; visibility: hidden; transition-delay: 0s; }
        body.game-active-view #game-wrapper { display: flex; }

        #main-content { flex-grow: 1; position: relative; overflow: hidden; display: flex; flex-direction: column; }
        #game-ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: var(--top-ui-height); display: flex; justify-content: center; align-items: center; padding: 5px 10px; z-index: 100; pointer-events: none; gap: 15px; }
        .game-mode-display-label { background-color: rgba(var(--panel-bg-rgb, 255, 255, 255), 0.75); color: var(--text-muted); padding: 0.3rem 0.6rem; border-radius: 15px; font-size: 0.8rem; font-weight: normal; box-shadow: 0 1px 2px var(--shadow); pointer-events: auto; transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease; }
        .timer-display { background-color: rgba(var(--panel-bg-rgb, 255, 255, 255), 0.85); color: var(--primary-color); padding: 0.3rem 0.8rem; border-radius: 15px; font-size: 0.9rem; font-weight: bold; box-shadow: 0 1px 3px var(--shadow); pointer-events: auto; display: inline-flex; align-items: center; transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease, box-shadow var(--transition-speed) ease; }
        #maze-container { flex-grow: 1; position: relative; overflow: hidden; background-color: var(--maze-bg); display: flex; justify-content: center; align-items: center; touch-action: none; z-index: 1; transition: background-color var(--transition-speed) ease; }
        #mazeCanvas { display: block; position: absolute; image-rendering: pixelated; image-rendering: crisp-edges; transform-origin: top left; }
        #bottom-nav { flex-shrink: 0; height: var(--bottom-nav-height); background-color: var(--panel-bg); border-top: 1px solid var(--border-color); box-shadow: 0 -2px 5px var(--shadow); display: flex; justify-content: space-around; align-items: center; padding: 0 5px; /* Reduced padding */ gap: 3px; /* Reduced gap */ z-index: 1000; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease; }
        #bottom-nav button { background: none; border: none; color: var(--text-muted); display: flex; flex-direction: column; align-items: center; padding: 4px 6px; /* Adjusted padding */ font-size: 0.7rem; cursor: pointer; transition: color 0.2s ease, background-color 0.2s ease; border-radius: 4px; min-height: 50px; justify-content: center; flex-grow: 1; max-width: 80px; /* Adjusted max-width */ text-align: center; white-space: normal; line-height: 1.1; }
        #bottom-nav button .icon { font-size: 1.3rem; margin-bottom: 1px; } /* Slightly smaller icon */
        #bottom-nav button.active { color: var(--primary-color); background-color: rgba(var(--primary-color-rgb), 0.1); }
        #bottom-nav button:hover:not(:disabled):not(.active) { background-color: rgba(var(--primary-color-rgb), 0.05); }
        #bottom-nav button:disabled { color: var(--border-color); cursor: not-allowed; opacity: 0.6; }

        /* --- Modals Common --- */
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 0.8rem 1.2rem; border-bottom: 1px solid var(--border-color); flex-shrink: 0; transition: border-color var(--transition-speed) ease; }
        .modal-header h2 { margin: 0; font-size: 1.2rem; color: var(--primary-color); transition: color var(--transition-speed) ease; }
        .modal-content { overflow-y: auto; display: flex; flex-direction: column; flex-grow: 1; padding: 1rem 1.2rem; gap: 1.2rem; }
        .modal-footer { flex-shrink: 0; padding: 0.8rem 1.2rem; border-top: 1px solid var(--border-color); text-align: right; transition: border-color var(--transition-speed) ease; }
        .modal-backdrop { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.6); z-index: 1090; opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, visibility 0s linear var(--transition-speed); }
        .modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9); width: 90%; max-width: var(--modal-max-width); max-height: 85vh; background-color: var(--panel-bg); border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); z-index: 1095; opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, transform var(--transition-speed) ease, visibility 0s linear var(--transition-speed), background-color var(--transition-speed) ease; display: flex; flex-direction: column; }
        .modal-backdrop.visible { opacity: 1; visibility: visible; transition-delay: 0s; }
        .modal.visible { opacity: 1; visibility: visible; transform: translate(-50%, -50%) scale(1); transition-delay: 0s; }
        .modal-close-btn { background: none; border: none; font-size: 1.8rem; line-height: 1; color: var(--text-muted); cursor: pointer; padding: 0.2rem; transition: color var(--transition-speed) ease; }

        /* --- Settings/New Game Modal Specific --- */
        #settings-modal-backdrop, #new-game-modal-backdrop { z-index: 1100; }
        #settings-modal, #new-game-modal { z-index: 1110; max-width: var(--modal-max-width); }
        .control-group { background-color: var(--control-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 0.8rem 1rem; box-shadow: 0 1px 3px var(--shadow); transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease; }
        .control-group h3 { margin: 0 0 0.8rem 0; font-size: 0.9rem; font-weight: 600; color: var(--primary-color); padding-bottom: 0.4rem; border-bottom: 1px solid var(--border-color); transition: color var(--transition-speed) ease, border-color var(--transition-speed) ease; }
        label, .label-like { display: block; margin-bottom: 0.3rem; font-weight: 500; font-size: 0.85rem; color: var(--text-muted); padding-top: 0.2rem; transition: color var(--transition-speed) ease; }
        input[type="number"], select { width: 100%; padding: 0.6rem 0.75rem; margin-bottom: 0.75rem; min-height: 42px; border: 1px solid var(--input-border); border-radius: 4px; background-color: var(--input-bg); color: var(--text-color); font-size: 0.9rem; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, color var(--transition-speed) ease; }
        input[type="number"]:disabled, select:disabled { background-color: var(--input-disabled-bg); color: var(--text-muted); cursor: not-allowed; opacity: 0.7; }
        .time-limit-input-group { margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px dashed var(--border-color); }
        .time-limit-input-group[hidden] { display: none; }
        button.modal-button { display: block; width: 100%; padding: 0.7rem 1.2rem; background-color: var(--primary-color); color: #ffffff; border: none; border-radius: 5px; cursor: pointer; font-size: 0.9rem; font-weight: 500; margin-top: 0.5rem; text-align: center; min-height: 42px; transition: background-color var(--transition-speed) ease; }
        button.modal-button:hover:not(:disabled) { background-color: var(--primary-hover); }
        .button-group { display: flex; gap: 0.75rem; }
        .button-group button { flex: 1; }
        .switch-container { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem; min-height: 40px;}
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; flex-shrink: 0; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary-color); }
        input:checked + .slider:before { transform: translateX(20px); }
        .choice-group { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.5rem; }
        .choice-group label { margin-bottom: 0; cursor: pointer; }
        .choice-group label[hidden] { display: none; }
        .choice-group input[type="radio"], .choice-group input[type="checkbox"] { display: none; }
        .choice-group span { display: inline-flex; align-items: center; justify-content: center; padding: 0.5rem 0.8rem; border: 1px solid var(--border-color); border-radius: 4px; background-color: var(--input-bg); font-size: 0.85rem; text-align: center; min-width: 36px; min-height: 36px; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, color var(--transition-speed) ease, box-shadow var(--transition-speed) ease; }
        .choice-group span.color-preview { width: 32px; height: 32px; padding: 0; border-radius: 50%; box-shadow: inset 0 0 0 1px var(--border-color); }
        .choice-group input:checked + span { background-color: var(--primary-color); color: white; border-color: var(--primary-color); box-shadow: 0 0 0 2px rgba(var(--primary-color-rgb), 0.4); }

        /* --- Scores Modal Specific --- */
         #scores-modal { max-width: 450px; max-height: 75vh; }
         #scores-modal .modal-header h2 { color: var(--primary-color); }
         #scores-list-container { padding: 0.5rem 0; }
         .score-entry { display: flex; justify-content: space-between; align-items: center; padding: 0.7rem 1.2rem; border-bottom: 1px solid var(--border-color); font-size: 0.95rem; transition: background-color 0.2s ease, border-color var(--transition-speed) ease; }
         .score-entry:last-child { border-bottom: none; }
         .score-entry:hover { background-color: rgba(var(--primary-color-rgb), 0.05); }
         .score-size { font-weight: 600; color: var(--text-color); flex-basis: 40%; transition: color var(--transition-speed) ease; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
         .score-time { font-weight: 500; color: var(--primary-color); flex-basis: 50%; text-align: right; font-family: 'Courier New', Courier, monospace; font-size: 1rem; transition: color var(--transition-speed) ease; }
         .no-scores-message { display: none; text-align: center; color: var(--text-muted); padding: 2rem 1.2rem; transition: color var(--transition-speed) ease; }
         #clearScoresBtn { background-color: transparent; color: var(--text-muted); border: 1px solid var(--border-color); padding: 0.5rem 1rem; font-size: 0.8rem; border-radius: 5px; cursor: pointer; min-height: auto; width: auto; display: inline-block; transition: background-color 0.2s ease, color 0.2s ease, border-color var(--transition-speed) ease; }
         body.dark-mode #clearScoresBtn { color: var(--text-muted-dark); }
         #clearScoresBtn:hover:not(:disabled) { background-color: rgba(220, 53, 69, 0.1); color: #dc3545; border-color: rgba(220, 53, 69, 0.3); }
         #clearScoresBtn:disabled { opacity: 0.5; cursor: not-allowed; background-color: transparent !important; color: var(--text-muted) !important; border-color: var(--border-color) !important; }
         #bottom-nav button#scoresBtn.active { color: var(--primary-color); background-color: rgba(var(--primary-color-rgb), 0.1); }
         #bottom-nav button#newGameBtn.active { color: var(--primary-color); background-color: rgba(var(--primary-color-rgb), 0.1); }

        /* --- Message Overlay, Loading, Minimap --- */
        #message-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.75); display: flex; justify-content: center; align-items: center; z-index: 1200; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s; padding: 1rem; }
        #message-overlay.visible { opacity: 1; visibility: visible; transition-delay: 0s; }
        #message-box { background-color: var(--panel-bg); color: var(--text-color); padding: 1.5rem 2rem; border-radius: 10px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.25); transform: scale(0.9); transition: transform 0.3s ease, background-color var(--transition-speed) ease, color var(--transition-speed) ease; width: 90%; max-width: 350px; }
        #message-overlay.visible #message-box { transform: scale(1); transition-delay: 0s;}
        #message-box h2 { margin: 0 0 1rem 0; font-size: 1.4rem; color: var(--primary-color); transition: color var(--transition-speed) ease; }
        #message-box p { margin-bottom: 1.5rem; font-size: 0.95rem; line-height: 1.5; }
        #message-box button { width: auto; padding: 0.7rem 1.8rem; font-size: 0.95rem; }
        #final-time-msg { font-weight: bold; margin-top:-0.5rem; margin-bottom: 1.5rem; display: none; }
        #final-best-time-msg { font-size: 0.85rem; color: var(--text-muted); margin-top:-1rem; margin-bottom: 1.5rem; display: none; transition: color var(--transition-speed) ease; }
        #loading-indicator { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 1.2rem 1.5rem; border-radius: 8px; font-size: 1rem; z-index: 1250; text-align: center; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s; pointer-events: none; }
        #loading-indicator.visible { opacity: 1; visibility: visible; transition-delay: 0s; }
        #minimapContainer { position: absolute; bottom: calc(var(--bottom-nav-height) + 15px); right: 15px; border: 2px solid var(--minimap-border); background-color: var(--minimap-bg); box-shadow: 0 0 8px rgba(0,0,0,0.25); z-index: 10; display: none; max-width: 120px; max-height: 120px; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease; border-radius: 4px; }
        #minimapCanvas { display: block; image-rendering: pixelated; image-rendering: crisp-edges; }

        /* --- Print Styles --- */
        @media print{body{--transition-speed: 0s !important}#game-mode-menu,#bottom-nav,.modal-backdrop,.modal,#game-ui-overlay,#message-overlay,#loading-indicator,#minimapContainer{display:none !important}#game-wrapper{display:flex !important}#main-content{border:none;padding:0;width:100% !important;height:100% !important;flex-grow:1 !important}#maze-container{width:100% !important;height:auto !important;max-height:95vh !important;padding:0 !important;margin:0 !important;overflow:visible !important;border:1px solid #ccc !important;background-color:#fff !important;justify-content:flex-start !important;align-items:flex-start !important;flex-grow:1 !important}body,body.dark-mode{background-color:#fff !important;color:#000 !important;--bg-color:#fff;--text-color:#000;--maze-bg:#fff;--wall-color:#000;--wall-glow:transparent;--wall-shadow:transparent;--player-color:#aaa;--player-glow:transparent;--player-shadow:transparent;--start-color:#e0e0e0;--end-color:#c0c0c0;--minimap-start:var(--start-color);--minimap-end:var(--end-color);--wall-thickness-factor:.1;--player-size-factor:.6;--end-marker-size-factor:.7}#mazeCanvas{position:static !important;max-width:100% !important;height:auto !important;box-shadow:none !important;border:none !important;background-color:transparent !important;transform:none !important;left:0 !important;top:0 !important}}
        @page { size: auto; margin: 5mm; }

        /* Optional pulse animation for timer */
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        .timer-display.pulsing { animation: pulse 1s infinite; }

    </style>
</head>
<body data-maze-style="classic">

<!-- START: Game Mode Menu -->
<div id="game-mode-menu">
    <h1>Selecciona Modo de Juego</h1>
    <button id="selectModeClassic" class="game-mode-button">Clásico</button>
    <button id="selectModeTimeAttack" class="game-mode-button">Contrarreloj</button>
    <button id="selectModeExploration" class="game-mode-button">Exploración</button>
</div>
<!-- END: Game Mode Menu -->

<!-- START: Game Wrapper (Hidden Initially) -->
<div id="game-wrapper">
    <main id="main-content">
        <div id="game-ui-overlay">
            <div class="game-mode-display-label"><span id="game-mode-display">Modo: -</span></div>
            <div class="timer-display"><span id="current-time">00:00</span></div>
        </div>
        <div id="maze-container">
            <canvas id="mazeCanvas"></canvas>
            <div id="minimapContainer"><canvas id="minimapCanvas"></canvas></div>
        </div>
        <div id="message-overlay">
            <div id="message-box">
                <h2>¡Completado!</h2>
                <p></p>
                <p id="final-time-msg"></p>
                <p id="final-best-time-msg"></p>
                <button id="playAgainBtn" class="modal-button">Jugar de Nuevo</button>
            </div>
        </div>
        <div id="loading-indicator">Generando...</div>
    </main>

    <nav id="bottom-nav">
        <button id="newGameBtn" title="Nuevo Laberinto"><span class="icon">➕</span><span>Nuevo</span></button>
        <button id="viewModeBtn" title="Cambiar Vista (Actual: General)" data-mode="overview"><span class="icon">👁️</span><span>Vista</span></button>
        <button id="scoresBtn" title="Ver Mejores Tiempos"><span class="icon">🏆</span><span>Marcas</span></button>
        <button id="settingsBtn" title="Abrir Ajustes"><span class="icon">⚙️</span><span>Ajustes</span></button>
        <button id="backToMenuBtn" title="Volver al Menú Principal"><span class="icon">↩️</span><span>Menú</span></button>
    </nav>
</div>
<!-- END: Game Wrapper -->


<!-- START: New Game Modal (Used after mode selection) -->
<div id="new-game-modal-backdrop" class="modal-backdrop"></div>
<div id="new-game-modal" class="modal" role="dialog" aria-labelledby="newGameModalTitle" aria-modal="true">
    <div class="modal-header">
        <h2 id="newGameModalTitle">Configurar Laberinto</h2>
        <button id="closeNewGameBtn" class="modal-close-btn" aria-label="Cerrar">×</button>
    </div>
    <div class="modal-content">
        <div class="control-group">
            <h3>Tamaño</h3>
            <label class="label-like">Nivel de Dificultad:</label>
            <div class="choice-group" id="modal-difficultyChoice" style="margin-bottom: 1rem;">
                <label><input type="radio" name="difficulty" value="easy"> <span>Fácil</span></label>
                 <label><input type="radio" name="difficulty" value="medium"> <span>Medio</span></label>
                <label><input type="radio" name="difficulty" value="hard"> <span>Difícil</span></label>
                <label><input type="radio" name="difficulty" value="custom" checked> <span>Personal.</span></label>
            </div>

            <label for="modal-width">Ancho (5-500):</label>
            <input type="number" id="modal-width" value="15" min="5" max="500">
            <label for="modal-height">Alto (5-500):</label>
            <input type="number" id="modal-height" value="15" min="5" max="500">

            <!-- START: Time Limit Input (Hidden by default) -->
            <div class="time-limit-input-group" id="time-limit-input-group" hidden>
                <label for="modal-timeLimit">Límite de Tiempo (segundos, opcional):</label>
                <input type="number" id="modal-timeLimit" min="10" step="5" placeholder="Auto">
            </div>
            <!-- END: Time Limit Input -->

            <p id="best-time-new-game-modal" style="font-size: 0.85rem; color: var(--text-muted); margin: 0.5rem 0;">Record Clásico: --:--</p>
            <button id="newGameModalGenerateBtn" class="modal-button">Empezar Juego</button>
        </div>
    </div>
</div>
<!-- END: New Game Modal -->

<!-- Settings Modal (Appearance only) -->
<div id="settings-modal-backdrop" class="modal-backdrop"></div>
<div id="settings-modal" class="modal" role="dialog" aria-labelledby="settingsModalTitle" aria-modal="true">
    <div class="modal-header">
        <h2 id="settingsModalTitle">Ajustes de Apariencia</h2>
        <button id="closeSettingsBtn" class="modal-close-btn" aria-label="Cerrar Ajustes">×</button>
    </div>
    <div class="modal-content">
        <div class="control-group">
            <h3>Apariencia</h3>
            <div class="switch-container">
                <label for="modal-darkModeToggle" class="label-like" style="margin-bottom: 0;">Modo Oscuro</label>
                <label class="switch"> <input type="checkbox" id="modal-darkModeToggle"> <span class="slider round"></span> </label>
            </div>
            <label for="modal-mazeStyle" class="label-like">Estilo Visual:</label>
            <div class="choice-group" id="modal-mazeStyle">
                 <label><input type="radio" name="modal-style" value="classic" checked> <span>Clásico</span></label>
                 <label><input type="radio" name="modal-style" value="matrix"> <span>Matrix</span></label>
                 <label><input type="radio" name="modal-style" value="blueprint"> <span>Plano</span></label>
                 <label><input type="radio" name="modal-style" value="neon"> <span>Neón</span></label>
                 <label><input type="radio" name="modal-style" value="cyber"> <span>Cyber</span></label>
             </div>
            <label class="label-like">Personaje:</label>
             <div class="choice-group" id="modal-playerChoice">
                 <label title="Rojo"><input type="radio" name="modal-player" value="#e63946" data-light="#e63946" data-dark="#ff8a80" checked> <span class="color-preview" style="background-color: #e63946;"></span></label>
                 <label title="Azul"><input type="radio" name="modal-player" value="#1d3557" data-light="#1d3557" data-dark="#a1c4fd"> <span class="color-preview" style="background-color: #1d3557;"></span></label>
                 <label title="Verde"><input type="radio" name="modal-player" value="#588157" data-light="#588157" data-dark="#a5d6a7"> <span class="color-preview" style="background-color: #588157;"></span></label>
                 <label title="Amarillo"><input type="radio" name="modal-player" value="#ffb703" data-light="#ffb703" data-dark="#fff176"> <span class="color-preview" style="background-color: #ffb703;"></span></label>
                 <label title="Púrpura"><input type="radio" name="modal-player" value="#6a0dad" data-light="#6a0dad" data-dark="#ce93d8"> <span class="color-preview" style="background-color: #6a0dad;"></span></label>
                 <label title="Matrix Player" data-style-specific="matrix" hidden><input type="radio" name="modal-player" value="#ffffff" data-light="#ffffff" data-dark="#ffffff"> <span class="color-preview" style="background-color: #ffffff;"></span></label>
                 <label title="Blueprint Player" data-style-specific="blueprint" hidden><input type="radio" name="modal-player" value="#ffeb3b" data-light="#ffeb3b" data-dark="#fff59d"> <span class="color-preview" style="background-color: #ffeb3b;"></span></label>
                 <label title="Neon Player" data-style-specific="neon" hidden><input type="radio" name="modal-player" value="#00ffff" data-light="#00ffff" data-dark="#7fffd4"> <span class="color-preview" style="background-color: #00ffff;"></span></label>
                 <label title="Cyber Player" data-style-specific="cyber" hidden><input type="radio" name="modal-player" value="#ff69b4" data-light="#ff69b4" data-dark="#ff85c0"> <span class="color-preview" style="background-color: #ff69b4;"></span></label>
             </div>
            <label class="label-like">Indicador Salida:</label>
            <div class="choice-group" id="modal-exitChoice">
                 <label><input type="radio" name="modal-exit" value="🏁" checked> <span>🏁</span></label>
                 <label><input type="radio" name="modal-exit" value="★"> <span>★</span></label>
                 <label><input type="radio" name="modal-exit" value="◎"> <span>◎</span></label>
                 <label><input type="radio" name="modal-exit" value="🎯"> <span>🎯</span></label>
                 <label><input type="radio" name="modal-exit" value="✅"> <span>✅</span></label>
             </div>
            <div class="button-group" style="margin-top: 1rem;">
                <button id="modal-printBtn" class="modal-button" title="Imprimir Laberinto Actual">Imprimir</button>
            </div>
        </div>
    </div>
</div>

<!-- Scores Modal -->
<div id="scores-modal-backdrop" class="modal-backdrop"></div>
<div id="scores-modal" class="modal" role="dialog" aria-labelledby="scoresModalTitle" aria-modal="true">
    <div class="modal-header">
        <h2 id="scoresModalTitle">Mejores Tiempos (Clásico)</h2>
        <button id="closeScoresBtn" class="modal-close-btn" aria-label="Cerrar Mejores Tiempos">×</button>
    </div>
    <div class="modal-content" id="scores-list-container">
        <div class="no-scores-message" style="display: none;">
             Aún no has completado ningún laberinto en modo Clásico.
        </div>
    </div>
    <div class="modal-footer">
         <button id="clearScoresBtn" class="modal-button secondary-button" title="Borrar todos los récords guardados">Borrar Todo</button>
    </div>
</div>


<script>
    // --- Constants & Settings ---
    const MAX_MAZE_DIMENSION = 500; const MOBILE_BREAKPOINT_WIDTH = 768; const MOBILE_MAX_INPUT_DIMENSION = 70; const MIN_MAZE_DIMENSION = 5; const CAMERA_SMOOTHING = 0.08; const PLAYER_SMOOTHING = 0.2; const GENERATION_YIELD_INTERVAL = 5000; const MINIMAP_MAX_SIZE = 120; const MINIMAP_PLAYER_DOT_SIZE = 3; const MINIMAP_CELL_MARKER_SCALE = 0.7; const BASE_CELL_SIZE_PLAYER_VIEW = 45; const SWIPE_THRESHOLD = 25; const EFFECTS_MIN_CELL_SIZE = 12; const EXPLORATION_REVEAL_RADIUS_FACTOR = 3.0; const EXPLORATION_GRADIENT_INNER_FACTOR = 0.4; const TIME_ATTACK_BASE_SECONDS_PER_CELL = 0.8; const TIME_ATTACK_MIN_SECONDS = 10;
    const DIFFICULTY_LEVELS = { easy: { width: 10, height: 10 }, medium: { width: 25, height: 25 }, hard: { width: 50, height: 50 }, custom: null };

    // --- Polyfills ---
    Element.prototype.requestFullscreen ??= Element.prototype.mozRequestFullScreen || Element.prototype.webkitRequestFullscreen || Element.prototype.msRequestFullscreen; document.exitFullscreen ??= document.mozCancelFullScreen || document.webkitExitFullscreen || document.msExitFullscreen; Object.defineProperty(document, 'fullscreenElement', { get: () => document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document._fullscreenElement });

    // --- Helper Functions ---
    const lerp = (a, b, t) => a + (b - a) * t; const clamp = (val, min, max) => Math.min(Math.max(val, min), max); const getCssVariable = (varName) => getComputedStyle(document.body).getPropertyValue(varName).trim();

    // --- Classes ---
    class Cell { constructor(x, y) { this.x = x; this.y = y; this.visited = false; this.walls = { top: true, right: true, bottom: true, left: true }; } }
    class MazeGenerator { constructor() { this.grid = []; this.width = 0; this.height = 0; this.start = { x: 0, y: 0 }; this.end = { x: 0, y: 0 }; this.generationComplete = false; } async generate(width, height, yieldCallback) { const startTime = performance.now(); this.width = clamp(width, MIN_MAZE_DIMENSION, MAX_MAZE_DIMENSION); this.height = clamp(height, MIN_MAZE_DIMENSION, MAX_MAZE_DIMENSION); this.generationComplete = false; console.log(`Starting generation for ${this.width}x${this.height}...`); this.grid = Array.from({ length: this.height }, (_, y) => Array.from({ length: this.width }, (_, x) => new Cell(x, y))); this.start = { x: 0, y: 0 }; this.end = { x: Math.max(0, this.width - 1), y: Math.max(0, this.height - 1) }; const stack = []; let cellsProcessedSinceYield = 0; const totalCells = this.width * this.height; let visitedCells = 0; const startCell = this.grid[this.start.y][this.start.x]; startCell.visited = true; visitedCells++; stack.push(startCell); while (stack.length > 0) { const current = stack[stack.length - 1]; const neighbors = this.getUnvisitedNeighbors(current); if (neighbors.length > 0) { const next = neighbors[Math.floor(Math.random() * neighbors.length)]; this.removeWall(current, next); next.visited = true; visitedCells++; stack.push(next); } else { stack.pop(); } if (yieldCallback && ++cellsProcessedSinceYield >= GENERATION_YIELD_INTERVAL) { yieldCallback(visitedCells / totalCells); await new Promise(resolve => setTimeout(resolve, 0)); cellsProcessedSinceYield = 0; } } yieldCallback?.(1); this.generationComplete = true; console.log(`Generation finished in ${(performance.now() - startTime).toFixed(2)} ms`); return this; } getUnvisitedNeighbors(cell) { const neighbors = []; const { x, y } = cell; const check = (nx, ny) => { if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height && !this.grid[ny]?.[nx]?.visited) { neighbors.push(this.grid[ny][nx]); } }; check(x, y - 1); check(x + 1, y); check(x, y + 1); check(x - 1, y); return neighbors; } removeWall(a, b) { const dx = a.x - b.x; const dy = a.y - b.y; if (dx === 1) { a.walls.left = b.walls.right = false; } else if (dx === -1) { a.walls.right = b.walls.left = false; } if (dy === 1) { a.walls.top = b.walls.bottom = false; } else if (dy === -1) { a.walls.bottom = b.walls.top = false; } } }
    class Player { constructor(x, y, color) { this.x = this.targetX = this.pixelX = x; this.y = this.targetY = this.pixelY = y; this.color = color; this.isMoving = false; } moveTo(newX, newY) { this.targetX = newX; this.targetY = newY; this.isMoving = Math.abs(this.targetX - this.pixelX) > 0.01 || Math.abs(this.targetY - this.pixelY) > 0.01; } update(deltaTime) { if (!this.isMoving) return; this.pixelX = lerp(this.pixelX, this.targetX, PLAYER_SMOOTHING); this.pixelY = lerp(this.pixelY, this.targetY, PLAYER_SMOOTHING); if (Math.abs(this.pixelX - this.targetX) < 0.01 && Math.abs(this.pixelY - this.targetY) < 0.01) { this.pixelX = this.targetX; this.pixelY = this.targetY; this.x = Math.round(this.targetX); this.y = Math.round(this.targetY); this.isMoving = false; } } canMove(dx, dy, maze) { if (this.isMoving) return false; const { x, y } = this; const nextX = x + dx; const nextY = y + dy; if (nextX < 0 || nextX >= maze.width || nextY < 0 || nextY >= maze.height) return false; const currentCell = maze.grid[y]?.[x]; return !currentCell ? false : !(dx === 1 && currentCell.walls.right) && !(dx === -1 && currentCell.walls.left) && !(dy === 1 && currentCell.walls.bottom) && !(dy === -1 && currentCell.walls.top) ? { newX: nextX, newY: nextY } : false; } setColor(color) { this.color = color; } }
    class Minimap { constructor(canvasId, containerId) { this.container = document.getElementById(containerId); this.canvas = document.getElementById(canvasId); this.ctx = this.canvas.getContext('2d', { alpha: false }); this.offscreenCanvas = document.createElement('canvas'); this.offscreenCtx = this.offscreenCanvas.getContext('2d', { alpha: false }); this.maze = null; this.player = null; this.size = MINIMAP_MAX_SIZE; this.cellWidth = 1; this.cellHeight = 1; this.visible = false; this.needsRedraw = true; this.wallColor = this.playerColor = this.bgColor = this.borderColor = this.startColor = this.endColor = ''; } updateSource(maze, player) { if (this.maze !== maze) { this.needsRedraw = true; } this.maze = maze; this.player = player; this.updateColors(); if (this.maze?.generationComplete) this.calculateDimensions(); } updateColors() { const styles = { wallColor: '--wall-color', playerColor: '--minimap-player', bgColor: '--minimap-bg', borderColor: '--minimap-border', startColor: '--minimap-start', endColor: '--minimap-end' }; let changed = false; for (const key in styles) { const newVal = getCssVariable(styles[key]); if (this[key] !== newVal) { this[key] = newVal; changed = true; if(key === 'bgColor') this.container.style.backgroundColor = newVal; if(key === 'borderColor') this.container.style.borderColor = newVal; } } if (changed) this.needsRedraw = true; } calculateDimensions() { if (!this.maze || !this.container) return; const aspect = this.maze.width / this.maze.height; const maxSize = parseInt(getComputedStyle(this.container).maxWidth) || MINIMAP_MAX_SIZE; const mapW = aspect >= 1 ? maxSize : Math.max(1, Math.floor(maxSize * aspect)); const mapH = aspect >= 1 ? Math.max(1, Math.floor(maxSize / aspect)) : maxSize; if (this.canvas.width !== mapW || this.canvas.height !== mapH) { this.canvas.width = this.offscreenCanvas.width = mapW; this.canvas.height = this.offscreenCanvas.height = mapH; this.cellWidth = mapW / this.maze.width; this.cellHeight = mapH / this.maze.height; this.needsRedraw = true; } this.container.style.width = `${mapW}px`; this.container.style.height = `${mapH}px`; } show() { if (window.mazeGame && window.mazeGame.currentGameMode === 'exploration') { this.hide(); return; } if (this.visible) return; this.container.style.display = 'block'; this.visible = true; if (this.maze?.generationComplete) { this.calculateDimensions(); this.needsRedraw = true; this.draw(); } } hide() { if (!this.visible) return; this.container.style.display = 'none'; this.visible = false; } draw() { if (!this.visible || !this.maze || !this.player || !this.maze.generationComplete) return; const newPlayerColor = getCssVariable('--minimap-player'); if (this.playerColor !== newPlayerColor) this.playerColor = newPlayerColor; if (this.needsRedraw) { this.drawMazeToOffscreen(); this.needsRedraw = false; } this.ctx.drawImage(this.offscreenCanvas, 0, 0); this.ctx.fillStyle = this.playerColor; const playerDrawSize = Math.max(1.5, MINIMAP_PLAYER_DOT_SIZE); const centerX = (this.player.pixelX + 0.5) * this.cellWidth; const centerY = (this.player.pixelY + 0.5) * this.cellHeight; this.ctx.beginPath(); this.ctx.arc(centerX, centerY, playerDrawSize / 2, 0, Math.PI * 2); this.ctx.fill(); } drawMazeToOffscreen() { if (!this.maze) return; const ctx = this.offscreenCtx; const width = this.offscreenCanvas.width; const height = this.offscreenCanvas.height; ctx.fillStyle = this.bgColor; ctx.fillRect(0, 0, width, height); const markerSizeW = Math.max(1, this.cellWidth * MINIMAP_CELL_MARKER_SCALE); const markerSizeH = Math.max(1, this.cellHeight * MINIMAP_CELL_MARKER_SCALE); const markerOffsetX = (this.cellWidth - markerSizeW) / 2; const markerOffsetY = (this.cellHeight - markerSizeH) / 2; ctx.fillStyle = this.startColor; ctx.fillRect(this.maze.start.x * this.cellWidth + markerOffsetX, this.maze.start.y * this.cellHeight + markerOffsetY, markerSizeW, markerSizeH); ctx.fillStyle = this.endColor; ctx.fillRect(this.maze.end.x * this.cellWidth + markerOffsetX, this.maze.end.y * this.cellHeight + markerOffsetY, markerSizeW, markerSizeH); ctx.strokeStyle = this.wallColor; ctx.lineWidth = Math.max(1, Math.min(this.cellWidth, this.cellHeight) * 0.1); ctx.beginPath(); for (let y = 0; y < this.maze.height; y++) { for (let x = 0; x < this.maze.width; x++) { const cell = this.maze.grid[y]?.[x]; if (!cell) continue; const cx = x * this.cellWidth, cy = y * this.cellHeight, cew = cx + this.cellWidth, ceh = cy + this.cellHeight; if (cell.walls.right) { ctx.moveTo(cew, cy); ctx.lineTo(cew, ceh); } if (cell.walls.bottom) { ctx.moveTo(cx, ceh); ctx.lineTo(cew, ceh); } } } ctx.moveTo(0, 0); ctx.lineTo(width, 0); ctx.moveTo(0, 0); ctx.lineTo(0, height); ctx.stroke(); } }

    class Renderer {
        constructor(canvasId, containerId) { this.canvas = document.getElementById(canvasId); this.container = document.getElementById(containerId); if (!this.canvas || !this.container) throw new Error("Canvas or container element not found!"); this.ctx = this.canvas.getContext('2d', { alpha: false }); this.wallCanvas = document.createElement('canvas'); this.wallCtx = this.wallCanvas.getContext('2d', { alpha: true }); this.maze = null; this.player = null; this.minimap = null; this.cellSize = 20; this.viewMode = 'overview'; this.isPrinting = false; this.lastDrawTime = 0; this.cameraX = 0; this.cameraY = 0; this.targetCameraX = 0; this.targetCameraY = 0; this.needsWallRedraw = true; this.exitMarker = '🏁'; this.styleProps = { wallColor: '#000', bgColor: '#fff', startColor: '#afa', endColor: '#aaf', wallGlow: 'transparent', wallShadow: 'transparent', playerGlow: 'transparent', playerShadow: 'transparent', wallThicknessFactor: 0.1, playerSizeFactor: 0.6, endMarkerSizeFactor: 0.7, fogColorOpaque: '#000000' }; this.styleMap = [ { key: 'wallColor', cssVar: '--wall-color' }, { key: 'bgColor', cssVar: '--maze-bg' }, { key: 'startColor', cssVar: '--start-color' }, { key: 'endColor', cssVar: '--end-color' }, { key: 'wallGlow', cssVar: '--wall-glow' }, { key: 'wallShadow', cssVar: '--wall-shadow' }, { key: 'playerGlow', cssVar: '--player-glow' }, { key: 'playerShadow', cssVar: '--player-shadow' }, { key: 'wallThicknessFactor', cssVar: '--wall-thickness-factor', parse: parseFloat }, { key: 'playerSizeFactor', cssVar: '--player-size-factor', parse: parseFloat }, { key: 'endMarkerSizeFactor', cssVar: '--end-marker-size-factor', parse: parseFloat }, { key: 'fogColorOpaque', cssVar: '--fog-color-opaque' } ]; this.resizeTimeout = null; window.addEventListener('resize', () => { clearTimeout(this.resizeTimeout); this.resizeTimeout = setTimeout(() => this.handleResize(), 150); }); this.updateStyleSettings(true); }
        setMaze(maze) { this.maze = maze; this.needsWallRedraw = true; this.handleResize(); this.resetCamera(); this.minimap?.updateSource(maze, this.player); console.log(`Renderer: Maze set (${maze.width}x${maze.height})`); }
        setPlayer(player) { this.player = player; this.resetCamera(); this.minimap?.updateSource(this.maze, player); console.log("Renderer: Player set"); }
        setMinimap(minimap) { this.minimap = minimap; }
        updateStyleSettings(forceUpdate = false) { let changed = forceUpdate; this.styleMap.forEach(item => { let newVal = getCssVariable(item.cssVar); if (item.parse) newVal = item.parse(newVal); if (this.styleProps[item.key] !== newVal) { this.styleProps[item.key] = newVal; changed = true; } }); if (changed) { console.log("Renderer: Styles updated."); this.needsWallRedraw = true; this.minimap?.updateColors(); } return changed; }
        setExitMarker(marker) { if (this.exitMarker !== marker) { this.exitMarker = marker; this.needsWallRedraw = true; console.log(`Renderer: Exit marker set to ${marker}`); } }
        setViewMode(mode) { if (window.mazeGame && window.mazeGame.currentGameMode === 'exploration' && mode === 'overview') { console.log("Renderer: Overview mode disabled in Exploration mode."); const viewBtn = document.getElementById('viewModeBtn'); if (viewBtn) { viewBtn.classList.add('active'); setTimeout(() => viewBtn.classList.remove('active'), 150); } return; } if (this.viewMode === mode) return; console.log(`Renderer: Switching view mode to: ${mode}`); this.viewMode = mode; this.handleResize(); const viewBtn = document.getElementById('viewModeBtn'); if (viewBtn) { viewBtn.title = `Cambiar Vista (Actual: ${mode === 'overview' ? 'General' : 'Jugador'})`; viewBtn.dataset.mode = mode; viewBtn.classList.toggle('active', mode === 'playerCamera'); } if (mode === 'playerCamera' && window.mazeGame && window.mazeGame.currentGameMode !== 'exploration') { this.minimap?.show(); } else { this.minimap?.hide(); } this.needsWallRedraw = true; this.drawFrame(); }
        resetCamera() { if (!this.maze || !this.player) return; const currentCellSize = this.viewMode === 'playerCamera' ? BASE_CELL_SIZE_PLAYER_VIEW : this.cellSize; this.targetCameraX = this.cameraX = (this.player.x + 0.5) * currentCellSize; this.targetCameraY = this.cameraY = (this.player.y + 0.5) * currentCellSize; console.log(`Renderer: Camera reset/snapped to world coords (${this.cameraX.toFixed(1)}, ${this.cameraY.toFixed(1)})`); }
        handleResize() { if (!this.container) return; const containerWidth = this.container.clientWidth, containerHeight = this.container.clientHeight; if (containerWidth <= 0 || containerHeight <= 0) return; console.log(`Renderer: HandleResize called. Mode: ${this.viewMode}, Container: ${containerWidth}x${containerHeight}`); let canvasW = containerWidth, canvasH = containerHeight, styleLeft = '0px', styleTop = '0px'; if (this.viewMode === 'overview') { if (!this.maze) return; this.cellSize = Math.max(1, Math.floor(Math.min(containerWidth / this.maze.width, containerHeight / this.maze.height))); canvasW = this.maze.width * this.cellSize; canvasH = this.maze.height * this.cellSize; styleLeft = `${Math.round((containerWidth - canvasW) / 2)}px`; styleTop = `${Math.round((containerHeight - canvasH) / 2)}px`; this.needsWallRedraw = true; } else { this.cellSize = BASE_CELL_SIZE_PLAYER_VIEW; this.resetCamera(); } this.canvas.width = canvasW; this.canvas.height = canvasH; this.canvas.style.cssText = `width: ${canvasW}px; height: ${canvasH}px; left: ${styleLeft}; top: ${styleTop}; position: absolute;`; if(this.minimap) { this.minimap.calculateDimensions(); this.minimap.needsRedraw = true; } this.drawFrame(); }
        updateCamera(deltaTime) { if (this.viewMode !== 'playerCamera' || !this.player || !this.maze) return; this.targetCameraX = (this.player.pixelX + 0.5) * this.cellSize; this.targetCameraY = (this.player.pixelY + 0.5) * this.cellSize; const smoothingFactor = clamp(CAMERA_SMOOTHING * (deltaTime / (1000/60)), 0.01, 0.9); this.cameraX = lerp(this.cameraX, this.targetCameraX, smoothingFactor); this.cameraY = lerp(this.cameraY, this.targetCameraY, smoothingFactor); }
        _applyEffects(ctx, type, size, effectColor, blurFactor, offsetXFactor = 0, offsetYFactor = 0) { if (effectColor && effectColor !== 'transparent' && effectColor !== 'none') { ctx.shadowColor = effectColor; ctx.shadowBlur = Math.max(type === 'glow' ? 5 : 3, size * blurFactor); ctx.shadowOffsetX = Math.max(type === 'shadow' ? 1 : 0, size * offsetXFactor); ctx.shadowOffsetY = Math.max(type === 'shadow' ? 1 : 0, size * offsetYFactor); return true; } return false; }
        _resetEffects(ctx) { ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; }

        drawFrame(timestamp = 0) {
            if (!this.maze || !this.player || !this.maze.generationComplete || this.isPrinting || !window.mazeGame) return;
            const game = window.mazeGame; const currentMode = game.currentGameMode; const stylesPossiblyChanged = this.updateStyleSettings(); const deltaTime = timestamp > 0 && this.lastDrawTime > 0 ? timestamp - this.lastDrawTime : 16.67;
            if (game.currentGameState === 'playing') { if (this.player.isMoving) this.player.update(deltaTime); if (this.viewMode === 'playerCamera') this.updateCamera(deltaTime); }
            this.lastDrawTime = timestamp; const ctx = this.ctx; const canvasW = this.canvas.width; const canvasH = this.canvas.height;

            ctx.fillStyle = this.styleProps.bgColor; ctx.fillRect(0, 0, canvasW, canvasH);

            if (this.viewMode === 'overview') {
                 if (currentMode === 'exploration') return; // Should not happen
                if (this.needsWallRedraw || stylesPossiblyChanged) { this.drawMazeStaticToOffscreen(); this.needsWallRedraw = false; }
                if (this.wallCanvas.width > 0) ctx.drawImage(this.wallCanvas, 0, 0);
                if (this.cellSize >= 1) this.drawPlayer(ctx, this.player.pixelX * this.cellSize, this.player.pixelY * this.cellSize, 0, 0);
            } else { // Player Camera View
                const camX = this.cameraX, camY = this.cameraY; const halfW = canvasW / 2, halfH = canvasH / 2; const currentCellSize = this.cellSize; const offsetX = -camX + halfW; const offsetY = -camY + halfH;
                const minVisibleX = Math.max(0, Math.floor((camX - halfW) / currentCellSize) - 1); const maxVisibleX = Math.min(this.maze.width, Math.ceil((camX + halfW) / currentCellSize) + 1); const minVisibleY = Math.max(0, Math.floor((camY - halfH) / currentCellSize) - 1); const maxVisibleY = Math.min(this.maze.height, Math.ceil((camY + halfH) / currentCellSize) + 1);

                // --- Draw Maze Elements (Walls, Start, End, Marker) ---
                 ctx.fillStyle = this.styleProps.startColor; const startDrawX = this.maze.start.x * currentCellSize + offsetX, startDrawY = this.maze.start.y * currentCellSize + offsetY; if (this.maze.start.x >= minVisibleX && this.maze.start.x < maxVisibleX && this.maze.start.y >= minVisibleY && this.maze.start.y < maxVisibleY) ctx.fillRect(startDrawX, startDrawY, currentCellSize, currentCellSize);
                 ctx.fillStyle = this.styleProps.endColor; const endDrawX = this.maze.end.x * currentCellSize + offsetX, endDrawY = this.maze.end.y * currentCellSize + offsetY; if (this.maze.end.x >= minVisibleX && this.maze.end.x < maxVisibleX && this.maze.end.y >= minVisibleY && this.maze.end.y < maxVisibleY) ctx.fillRect(endDrawX, endDrawY, currentCellSize, currentCellSize);
                 ctx.strokeStyle = this.styleProps.wallColor; ctx.lineWidth = Math.max(1, currentCellSize * this.styleProps.wallThicknessFactor); ctx.lineCap = 'round'; ctx.lineJoin = 'round'; let shadowApplied = false; const canShowEffects = currentCellSize > EFFECTS_MIN_CELL_SIZE; if (canShowEffects) shadowApplied = this._applyEffects(ctx, 'glow', currentCellSize, this.styleProps.wallGlow, 0.15) || this._applyEffects(ctx, 'shadow', currentCellSize, this.styleProps.wallShadow, 0.05, 0.02, 0.02);
                 ctx.beginPath(); for (let y = minVisibleY; y < maxVisibleY; y++) { for (let x = minVisibleX; x < maxVisibleX; x++) { const cell = this.maze.grid[y]?.[x]; if (!cell) continue; const drawX = Math.round(x * currentCellSize + offsetX), drawY = Math.round(y * currentCellSize + offsetY); if (drawX + currentCellSize < -ctx.lineWidth || drawX > canvasW + ctx.lineWidth || drawY + currentCellSize < -ctx.lineWidth || drawY > canvasH + ctx.lineWidth) continue; const drawX_right = Math.round(drawX + currentCellSize), drawY_bottom = Math.round(drawY + currentCellSize); if (cell.walls.top) { ctx.moveTo(drawX, drawY); ctx.lineTo(drawX_right, drawY); } if (cell.walls.right) { ctx.moveTo(drawX_right, drawY); ctx.lineTo(drawX_right, drawY_bottom); } if (cell.walls.bottom) { ctx.moveTo(drawX_right, drawY_bottom); ctx.lineTo(drawX, drawY_bottom); } if (cell.walls.left) { ctx.moveTo(drawX, drawY_bottom); ctx.lineTo(drawX, drawY); } } } ctx.stroke(); if (shadowApplied) this._resetEffects(ctx);
                 if (this.exitMarker && currentCellSize > 10 && this.maze.end.x >= minVisibleX && this.maze.end.x < maxVisibleX && this.maze.end.y >= minVisibleY && this.maze.end.y < maxVisibleY) { const markerSize = currentCellSize * this.styleProps.endMarkerSizeFactor; const markerX = endDrawX + currentCellSize / 2; const markerY = endDrawY + currentCellSize / 2 + markerSize * 0.1; ctx.font = `${markerSize * 0.8}px ${getCssVariable('--font-family')}`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = this.styleProps.wallColor; ctx.fillText(this.exitMarker, markerX, markerY); }
                 // --- End Drawing Maze Elements ---

                // Draw Player (Drawn before fog)
                this.drawPlayer(ctx, this.player.pixelX * currentCellSize, this.player.pixelY * currentCellSize, offsetX, offsetY);

                // --- START: Exploration Mode Gradient Fog ---
                if (currentMode === 'exploration') {
                    ctx.save();
                    const playerScreenX = halfW; const playerScreenY = halfH;
                    const outerRadius = currentCellSize * EXPLORATION_REVEAL_RADIUS_FACTOR;
                    const innerRadius = outerRadius * EXPLORATION_GRADIENT_INNER_FACTOR;
                    const gradient = ctx.createRadialGradient( playerScreenX, playerScreenY, innerRadius, playerScreenX, playerScreenY, outerRadius );
                    gradient.addColorStop(0, 'rgba(0, 0, 0, 0)'); // Transparent center
                    gradient.addColorStop(1, this.styleProps.fogColorOpaque); // Opaque edge at outer radius
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvasW, canvasH); // Cover the canvas
                    ctx.restore();
                }
                // --- END: Exploration Mode Gradient Fog ---

                this.minimap?.draw(); // Drawn outside fog/clip area
            }
        }
        drawPlayer(ctx, worldX, worldY, offsetX, offsetY) { if (!this.player?.color) return; const currentCellSize = this.cellSize; const centerX = worldX + offsetX + currentCellSize / 2; const centerY = worldY + offsetY + currentCellSize / 2; const playerRadius = Math.max(1, (currentCellSize * this.styleProps.playerSizeFactor) / 2); ctx.fillStyle = this.player.color; const canShowEffects = currentCellSize > EFFECTS_MIN_CELL_SIZE; let shadowApplied = false; if (canShowEffects && this._applyEffects(ctx, 'glow', currentCellSize, this.styleProps.playerGlow, 0.25)) { ctx.beginPath(); ctx.arc(centerX, centerY, playerRadius, 0, Math.PI * 2); ctx.fill(); this._resetEffects(ctx); } ctx.beginPath(); ctx.arc(centerX, centerY, playerRadius, 0, Math.PI * 2); ctx.fill(); if (canShowEffects && this._applyEffects(ctx, 'shadow', currentCellSize, this.styleProps.playerShadow, 0.1, 0.03, 0.03)) { ctx.fill(); shadowApplied = true; } if (shadowApplied) this._resetEffects(ctx); }
        drawMazeStaticToOffscreen() { if ((this.viewMode === 'playerCamera' && !this.isPrinting) || !this.maze?.width || !this.maze.height) { console.warn("drawMazeStaticToOffscreen skipped: invalid state."); if (this.wallCanvas.width > 0) this.wallCtx.clearRect(0, 0, this.wallCanvas.width, this.wallCanvas.height); return; } const currentCellSize = this.cellSize; if (currentCellSize <= 0) { console.warn(`drawMazeStaticToOffscreen skipped: invalid cellSize ${currentCellSize}`); return; } const canvasW = Math.ceil(this.maze.width * currentCellSize); const canvasH = Math.ceil(this.maze.height * currentCellSize); if (canvasW <= 0 || canvasH <= 0) { console.warn(`drawMazeStaticToOffscreen skipped: invalid calculated canvas size ${canvasW}x${canvasH}`); return; } if (this.wallCanvas.width !== canvasW || this.wallCanvas.height !== canvasH) { this.wallCanvas.width = canvasW; this.wallCanvas.height = canvasH; console.log(`Renderer: Resized offscreen wallCanvas to ${canvasW}x${canvasH}`); } const ctx = this.wallCtx; ctx.clearRect(0, 0, canvasW, canvasH); ctx.fillStyle = this.styleProps.startColor; ctx.fillRect(this.maze.start.x * currentCellSize, this.maze.start.y * currentCellSize, currentCellSize, currentCellSize); ctx.fillStyle = this.styleProps.endColor; ctx.fillRect(this.maze.end.x * currentCellSize, this.maze.end.y * currentCellSize, currentCellSize, currentCellSize); ctx.strokeStyle = this.styleProps.wallColor; ctx.lineWidth = Math.max(1, currentCellSize * this.styleProps.wallThicknessFactor); ctx.lineCap = 'round'; ctx.lineJoin = 'round'; let shadowApplied = false; const canShowEffects = currentCellSize > EFFECTS_MIN_CELL_SIZE; if (canShowEffects) shadowApplied = this._applyEffects(ctx, 'glow', currentCellSize, this.styleProps.wallGlow, 0.15) || this._applyEffects(ctx, 'shadow', currentCellSize, this.styleProps.wallShadow, 0.05, 0.02, 0.02); ctx.beginPath(); for (let y = 0; y < this.maze.height; y++) for (let x = 0; x < this.maze.width; x++) { const cell = this.maze.grid[y]?.[x]; if (!cell) continue; const cx = x * currentCellSize, cy = y * currentCellSize, cew = cx + currentCellSize, ceh = cy + currentCellSize; if (cell.walls.top) { ctx.moveTo(cx, cy); ctx.lineTo(cew, cy); } if (cell.walls.right) { ctx.moveTo(cew, cy); ctx.lineTo(cew, ceh); } if (cell.walls.bottom) { ctx.moveTo(cew, ceh); ctx.lineTo(cx, ceh); } if (cell.walls.left) { ctx.moveTo(cx, ceh); ctx.lineTo(cx, cy); } } ctx.stroke(); if (shadowApplied) this._resetEffects(ctx); if (this.exitMarker && currentCellSize > 10) { const markerSize = currentCellSize * this.styleProps.endMarkerSizeFactor; const markerX = this.maze.end.x * currentCellSize + currentCellSize / 2; const markerY = this.maze.end.y * currentCellSize + currentCellSize / 2 + markerSize * 0.1; ctx.font = `${markerSize * 0.8}px ${getCssVariable('--font-family')}`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = this.styleProps.wallColor; ctx.fillText(this.exitMarker, markerX, markerY); } }
        prepareForPrint() { if (!this.maze || !this.player || !this.maze.generationComplete) return null; console.log("Renderer: Preparing for print..."); this.isPrinting = true; const savedState = { currentViewMode: this.viewMode, currentDarkMode: document.body.classList.contains('dark-mode'), oldCanvasWidth: this.canvas.width, oldCanvasHeight: this.canvas.height, oldElementWidth: this.canvas.style.width, oldElementHeight: this.canvas.style.height, oldElementLeft: this.canvas.style.left, oldElementTop: this.canvas.style.top, oldCellSize: this.cellSize, originalStyles: { ...this.styleProps }, originalPlayerColor: this.player.color, originalExitMarker: this.exitMarker }; if (savedState.currentDarkMode) document.body.classList.remove('dark-mode'); this.viewMode = 'overview'; const PRINT_RESOLUTION_BASE = 2400; const aspect = this.maze.width / this.maze.height; const printCellSize = Math.max(1, Math.floor(PRINT_RESOLUTION_BASE / (aspect >= 1 ? this.maze.width : this.maze.height))); this.cellSize = printCellSize; Object.assign(this.styleProps, { wallColor: '#000000', bgColor: '#ffffff', startColor: '#e0e0e0', endColor: '#cccccc', wallGlow: 'transparent', wallShadow: 'transparent', playerGlow: 'transparent', playerShadow: 'transparent', wallThicknessFactor: 0.1, playerSizeFactor: 0.6, endMarkerSizeFactor: 0.7 }); const printPlayerColor = '#aaaaaa'; const printCanvasWidth = this.maze.width * printCellSize; const printCanvasHeight = this.maze.height * printCellSize; this.canvas.style.cssText = `width: ${printCanvasWidth}px; height: ${printCanvasHeight}px; left: 0px; top: 0px;`; this.canvas.width = printCanvasWidth; this.canvas.height = printCanvasHeight; this.needsWallRedraw = true; this.drawMazeStaticToOffscreen(); const ctx = this.ctx; ctx.fillStyle = this.styleProps.bgColor; ctx.fillRect(0, 0, printCanvasWidth, printCanvasHeight); ctx.drawImage(this.wallCanvas, 0, 0); if (this.cellSize >= 1) { const originalDrawColor = this.player.color; this.player.color = printPlayerColor; this.drawPlayer(ctx, this.player.x * this.cellSize, this.player.y * this.cellSize, 0, 0); this.player.color = originalDrawColor; } console.log(`Renderer: Prepared print canvas ${printCanvasWidth}x${printCanvasHeight}, cellSize=${printCellSize}`); return savedState; }
        restoreAfterPrint(savedState) { if (!savedState) return; console.log("Renderer: Restoring after print..."); this.styleProps = savedState.originalStyles; if (this.player) this.player.color = savedState.originalPlayerColor; this.exitMarker = savedState.originalExitMarker; this.canvas.width = savedState.oldCanvasWidth; this.canvas.height = savedState.oldCanvasHeight; this.canvas.style.cssText = `width: ${savedState.oldElementWidth}; height: ${savedState.oldElementHeight}; left: ${savedState.oldElementLeft}; top: ${savedState.oldElementTop}; position: absolute;`; this.cellSize = savedState.oldCellSize; if (savedState.currentDarkMode) document.body.classList.add('dark-mode'); this.minimap?.updateColors(); this.isPrinting = false; this.setViewMode(savedState.currentViewMode); this.needsWallRedraw = true; requestAnimationFrame(() => this.drawFrame()); console.log("Renderer: Restored state after printing."); }
    }


    // --- Game Class ---
    class Game {
        constructor() {
             this.currentGameState = 'menu'; this.currentGameMode = null;
             this.mazeGenerator = new MazeGenerator(); this.renderer = new Renderer('mazeCanvas', 'maze-container'); this.minimap = new Minimap('minimapCanvas', 'minimapContainer'); this.renderer.setMinimap(this.minimap);
             this.player = null; this.gameActive = false; this.lastTimestamp = 0; this.animationFrameId = null; this.isLoading = false;
             this.gameStartTime = 0; this.gameTimer = null; this.currentTime = 0; this.timeLimit = null; this.remainingTime = null; this.timerStarted = false; this.moveCounter = 0; // Added move counter
             this.bestTimes = JSON.parse(localStorage.getItem('mazeClassicBestTimes') || '{}');
             this.touchStartX = this.touchStartY = this.touchEndX = this.touchEndY = 0;
             this.ui = { gameModeMenu: document.getElementById('game-mode-menu'), gameWrapper: document.getElementById('game-wrapper'), gameModeDisplay: document.getElementById('game-mode-display'), newGameModal: document.getElementById('new-game-modal'), newGameModalBackdrop: document.getElementById('new-game-modal-backdrop'), newGameModalGenerateBtn: document.getElementById('newGameModalGenerateBtn'), widthInput: document.getElementById('modal-width'), heightInput: document.getElementById('modal-height'), difficultyChoiceGroup: document.getElementById('modal-difficultyChoice'), bestTimeNewGameModalDisplay: document.getElementById('best-time-new-game-modal'), timeLimitInputGroup: document.getElementById('time-limit-input-group'), timeLimitInput: document.getElementById('modal-timeLimit'), settingsModal: document.getElementById('settings-modal'), settingsBackdrop: document.getElementById('settings-modal-backdrop'), darkModeToggle: document.getElementById('modal-darkModeToggle'), mazeStyleGroup: document.getElementById('modal-mazeStyle'), playerChoiceGroup: document.getElementById('modal-playerChoice'), exitChoiceGroup: document.getElementById('modal-exitChoice'), scoresModal: document.getElementById('scores-modal'), scoresBackdrop: document.getElementById('scores-modal-backdrop'), scoresListContainer: document.getElementById('scores-list-container'), clearScoresBtn: document.getElementById('clearScoresBtn'), noScoresMessage: document.querySelector('#scores-modal .no-scores-message'), viewModeBtn: document.getElementById('viewModeBtn'), newGameBtn: document.getElementById('newGameBtn'), scoresBtn: document.getElementById('scoresBtn'), settingsBtn: document.getElementById('settingsBtn'), backToMenuBtn: document.getElementById('backToMenuBtn'), loadingIndicator: document.getElementById('loading-indicator'), messageOverlay: document.getElementById('message-overlay'), mazeContainer: document.getElementById('maze-container'), currentTimeDisplay: document.getElementById('current-time'), };
             this.ui.bottomNavButtons = [this.ui.newGameBtn, this.ui.viewModeBtn, this.ui.scoresBtn, this.ui.settingsBtn, this.ui.backToMenuBtn];
             this.bindUI();
             this.applyInitialSettings();
             console.log("Game Initialized. Waiting for mode selection.");
        }

        bindUI() {
            document.getElementById('selectModeClassic').addEventListener('click', () => this.selectGameMode('classic'));
            document.getElementById('selectModeTimeAttack').addEventListener('click', () => this.selectGameMode('timeAttack'));
            document.getElementById('selectModeExploration').addEventListener('click', () => this.selectGameMode('exploration'));
            this.ui.newGameBtn.addEventListener('click', () => this.openNewGameModal());
            this.ui.viewModeBtn.addEventListener('click', () => this.toggleViewMode());
            this.ui.scoresBtn.addEventListener('click', () => this.openScoresModal());
            this.ui.settingsBtn.addEventListener('click', () => this.openSettingsModal());
            this.ui.backToMenuBtn.addEventListener('click', () => this.confirmReturnToMenu());
            this.ui.newGameModalGenerateBtn.addEventListener('click', () => this.startNewGameFromModal());
            document.getElementById('closeNewGameBtn').addEventListener('click', () => this.closeNewGameModal());
            this.ui.newGameModalBackdrop.addEventListener('click', () => this.closeNewGameModal());
            this.ui.widthInput.addEventListener('input', () => this.validateDimensionsAndUpdateBestTime());
            this.ui.heightInput.addEventListener('input', () => this.validateDimensionsAndUpdateBestTime());
            this.ui.difficultyChoiceGroup.addEventListener('change', (e) => { if (e.target.checked) this.handleDifficultyChange(e.target.value); });
            document.getElementById('closeSettingsBtn').addEventListener('click', () => this.closeSettingsModal());
            this.ui.settingsBackdrop.addEventListener('click', () => this.closeSettingsModal());
            this.ui.darkModeToggle.addEventListener('change', (e) => this.setDarkMode(e.target.checked));
            this.ui.mazeStyleGroup.addEventListener('change', (e) => { if (e.target.checked) this.setMazeStyle(e.target.value); });
            this.ui.playerChoiceGroup.addEventListener('change', (e) => { if (e.target.checked) this.updatePlayerColor(e.target); });
            this.ui.exitChoiceGroup.addEventListener('change', (e) => { if (e.target.checked) { this.renderer.setExitMarker(e.target.value); this.requestRedraw(); } });
            document.getElementById('modal-printBtn').addEventListener('click', () => this.handlePrint());
            document.getElementById('closeScoresBtn').addEventListener('click', () => this.closeScoresModal());
            this.ui.scoresBackdrop.addEventListener('click', () => this.closeScoresModal());
            this.ui.clearScoresBtn.addEventListener('click', () => this.confirmClearScores());
            document.getElementById('playAgainBtn').addEventListener('click', () => { this.hideMessage(); this.currentGameState = 'configuring'; this.openNewGameModal(); });
            document.addEventListener('keydown', (e) => this.handleKeyDown(e));
            this.ui.mazeContainer.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
            this.ui.mazeContainer.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
            this.ui.mazeContainer.addEventListener('touchend', (e) => this.handleTouchEnd(e));
            this.ui.mazeContainer.addEventListener('touchcancel', (e) => this.handleTouchEnd(e));
        }
        selectGameMode(mode) {
            console.log(`Game mode selected: ${mode}`);
            this.currentGameMode = mode; this.currentGameState = 'configuring';
            document.body.classList.add('game-active-view');
            let modeText = "Clásico", showTimeInput = false, suggestedTime = "";
            if (mode === 'timeAttack') { modeText = "Contrarreloj"; showTimeInput = true; const w = parseInt(this.ui.widthInput.value) || 15, h = parseInt(this.ui.heightInput.value) || 15; suggestedTime = this.calculateSuggestedTimeLimit(w, h); }
            else if (mode === 'exploration') { modeText = "Exploración"; }
            this.ui.gameModeDisplay.textContent = `Modo: ${modeText}`;
            this.ui.timeLimitInputGroup.hidden = !showTimeInput;
            if (showTimeInput) { this.ui.timeLimitInput.value = ''; this.ui.timeLimitInput.placeholder = `Auto (~${suggestedTime}s)`; }

            // GA4 Event: Mode Selection
            if (typeof gtag === 'function') {
                gtag('event', 'select_content', {
                    content_type: 'game_mode',
                    item_id: mode
                });
            }

            this.openNewGameModal();
        }
        toggleViewMode() {
            if (!this.ui.viewModeBtn.disabled) {
                const newMode = this.renderer.viewMode === 'overview' ? 'playerCamera' : 'overview';
                this.renderer.setViewMode(newMode);
                // GA4 Event: UI Interaction
                if (typeof gtag === 'function') {
                    gtag('event', 'ui_interaction', {
                        interaction_type: 'toggle_view',
                        element_id: 'viewModeBtn',
                        value: newMode // Record the new view mode
                    });
                }
            }
        }
        openModal(modal, backdrop, activatingBtn) {
            this.closeAllModals(); backdrop.classList.add('visible'); modal.classList.add('visible'); activatingBtn?.classList.add('active');
            let modalId = modal.id.replace('-modal', ''); // e.g., 'settings', 'scores', 'new-game'
            if (modal === this.ui.settingsModal) { this.syncModalControls(); modalId = 'settings'; }
            if (modal === this.ui.newGameModal) { this.syncNewGameModalControls(); modalId = 'new_game'; }
            if (modal === this.ui.scoresModal) { this.populateScoresModalContent(); modalId = 'scores'; }
            // GA4 Event: UI Interaction
            if (typeof gtag === 'function') {
                gtag('event', 'ui_interaction', { interaction_type: 'open_modal', element_id: modalId });
            }
        }
        closeModal(modal, backdrop, activatingBtn) {
             // GA4 Event: UI Interaction (Send *before* hiding)
             if (modal.classList.contains('visible') && typeof gtag === 'function') {
                 let modalId = modal.id.replace('-modal', '');
                 if (modalId === 'new-game') modalId = 'new_game'; // Consistent naming
                 gtag('event', 'ui_interaction', { interaction_type: 'close_modal', element_id: modalId });
             }
            backdrop.classList.remove('visible'); modal.classList.remove('visible'); activatingBtn?.classList.remove('active');
        }
        closeAllModals() { this.closeSettingsModal(); this.closeScoresModal(); this.closeNewGameModal(); }
        openNewGameModal() { if (this.currentGameState !== 'menu') { this.currentGameState = 'configuring'; this.openModal(this.ui.newGameModal, this.ui.newGameModalBackdrop, this.ui.newGameBtn); } else { console.warn("Cannot open New Game modal before selecting a game mode."); } }
        closeNewGameModal() { this.closeModal(this.ui.newGameModal, this.ui.newGameModalBackdrop, this.ui.newGameBtn); }
        openSettingsModal() { this.openModal(this.ui.settingsModal, this.ui.settingsBackdrop, this.ui.settingsBtn); }
        closeSettingsModal() { this.closeModal(this.ui.settingsModal, this.ui.settingsBackdrop, this.ui.settingsBtn); }
        openScoresModal() { this.openModal(this.ui.scoresModal, this.ui.scoresBackdrop, this.ui.scoresBtn); }
        closeScoresModal() { this.closeModal(this.ui.scoresModal, this.ui.scoresBackdrop, this.ui.scoresBtn); }

        confirmReturnToMenu() {
            let shouldReturn = true;
            if (this.currentGameState === 'playing' || this.currentGameState === 'paused') {
                shouldReturn = confirm("¿Seguro que quieres volver al menú? Perderás el progreso actual.");
            }
            if (shouldReturn) {
                // GA4 Event: UI Interaction
                if (typeof gtag === 'function') {
                    gtag('event', 'ui_interaction', { interaction_type: 'button_click', element_id: 'back_to_menu' });
                }
                // GA4 Event: Level End (Quit) if game was active
                if (this.mazeGenerator.generationComplete && this.player && (this.currentGameState === 'playing' || this.currentGameState === 'paused')) {
                     if (typeof gtag === 'function') {
                        gtag('event', 'level_end', {
                            level_name: `${this.mazeGenerator.width}x${this.mazeGenerator.height}_${this.currentGameMode}`,
                            success: false,
                            reason: 'quit',
                            time_seconds: this.currentGameMode === 'timeAttack' ? (this.timeLimit - (this.remainingTime ?? this.timeLimit)) : this.currentTime,
                            moves: this.moveCounter
                        });
                    }
                }
                this.returnToMenu();
            }
        }
        returnToMenu() { console.log("Returning to main menu..."); this.stopGameLoop(); this.resetTimer(); this.hideMessage(); this.closeAllModals(); this.currentGameState = 'menu'; this.currentGameMode = null; this.gameActive = false; this.player = null; this.mazeGenerator.generationComplete = false; this.mazeGenerator.grid = []; document.body.classList.remove('game-active-view'); this.ui.gameModeDisplay.textContent = "Modo: -"; this.ui.viewModeBtn.disabled = false; this.renderer.setViewMode('overview'); this.minimap.hide(); if (this.renderer.canvas) { this.renderer.ctx.clearRect(0, 0, this.renderer.canvas.width, this.renderer.canvas.height); } }

        sortMazeSizes(sizeA, sizeB) { const [wA, hA] = sizeA.split('x').map(Number); const [wB, hB] = sizeB.split('x').map(Number); const areaA = wA * hA, areaB = wB * hB; return areaA !== areaB ? areaA - areaB : wA !== wB ? wA - wB : hA - hB; }
        populateScoresModalContent() { this.ui.scoresListContainer.innerHTML = ''; const scoreKeys = Object.keys(this.bestTimes).sort(this.sortMazeSizes); if (scoreKeys.length === 0) { this.ui.noScoresMessage.style.display = 'block'; this.ui.scoresListContainer.appendChild(this.ui.noScoresMessage); this.ui.clearScoresBtn.disabled = true; } else { this.ui.noScoresMessage.style.display = 'none'; this.ui.clearScoresBtn.disabled = false; scoreKeys.forEach(size => { const time = this.bestTimes[size]; if (time === undefined || time === null) return; this.ui.scoresListContainer.innerHTML += `<div class="score-entry"><span class="score-size" title="${size}">${size}</span><span class="score-time">${this.formatTime(time)}</span></div>`; }); } }
        confirmClearScores() { if (confirm('¿Estás seguro de que quieres borrar todos tus récords (Modo Clásico)? Esta acción no se puede deshacer.')) this.clearAllScores(); }
        clearAllScores() {
            // GA4 Event: UI Interaction
             if (typeof gtag === 'function') {
                 gtag('event', 'ui_interaction', { interaction_type: 'button_click', element_id: 'clear_scores' });
             }
            this.bestTimes = {}; localStorage.removeItem('mazeClassicBestTimes'); console.log("All classic best times cleared."); this.populateScoresModalContent(); this.updateBestTimeDisplay(`${this.ui.widthInput?.value ?? 0}x${this.ui.heightInput?.value ?? 0}`);
        }

        calculateSuggestedTimeLimit(width, height) { return Math.max(TIME_ATTACK_MIN_SECONDS, Math.floor(width * height * TIME_ATTACK_BASE_SECONDS_PER_CELL)); }
        handleDifficultyChange(difficultyValue) { const level = DIFFICULTY_LEVELS[difficultyValue]; const isCustom = difficultyValue === 'custom' || !level; this.ui.widthInput.disabled = !isCustom; this.ui.heightInput.disabled = !isCustom; let newWidth = parseInt(this.ui.widthInput.value); let newHeight = parseInt(this.ui.heightInput.value); if (!isCustom) { const maxDim = parseInt(this.ui.widthInput.max); newWidth = clamp(level.width, MIN_MAZE_DIMENSION, maxDim); newHeight = clamp(level.height, MIN_MAZE_DIMENSION, maxDim); this.ui.widthInput.value = newWidth; this.ui.heightInput.value = newHeight; } if (this.currentGameMode === 'timeAttack' && !this.ui.timeLimitInputGroup.hidden) { const suggestedTime = this.calculateSuggestedTimeLimit(newWidth, newHeight); this.ui.timeLimitInput.placeholder = `Auto (~${suggestedTime}s)`; } this.validateDimensionsAndUpdateBestTime(); }
        syncNewGameModalControls() { const currentW = this.mazeGenerator?.width > 0 ? this.mazeGenerator.width : parseInt(this.ui.widthInput.value); const currentH = this.mazeGenerator?.height > 0 ? this.mazeGenerator.height : parseInt(this.ui.heightInput.value); let matchedDifficulty = 'custom'; for (const [key, value] of Object.entries(DIFFICULTY_LEVELS)) { if (key !== 'custom' && value && value.width === currentW && value.height === currentH) { matchedDifficulty = key; break; } } const difficultyRadio = this.ui.difficultyChoiceGroup.querySelector(`input[value="${matchedDifficulty}"]`); if (difficultyRadio) { difficultyRadio.checked = true; } else { this.ui.difficultyChoiceGroup.querySelector('input[value="custom"]').checked = true; matchedDifficulty = 'custom'; } const maxInputDim = parseInt(this.ui.widthInput.max); this.ui.widthInput.value = clamp(currentW, MIN_MAZE_DIMENSION, maxInputDim); this.ui.heightInput.value = clamp(currentH, MIN_MAZE_DIMENSION, maxInputDim); const isCustom = matchedDifficulty === 'custom'; this.ui.widthInput.disabled = !isCustom; this.ui.heightInput.disabled = !isCustom; const showTimeInput = this.currentGameMode === 'timeAttack'; this.ui.timeLimitInputGroup.hidden = !showTimeInput; if (showTimeInput) { const suggestedTime = this.calculateSuggestedTimeLimit(parseInt(this.ui.widthInput.value), parseInt(this.ui.heightInput.value)); this.ui.timeLimitInput.value = ''; this.ui.timeLimitInput.placeholder = `Auto (~${suggestedTime}s)`; } this.updateBestTimeDisplay(`${this.ui.widthInput.value}x${this.ui.heightInput.value}`); }
        syncModalControls() { this.ui.darkModeToggle.checked = document.body.classList.contains('dark-mode'); const currentStyle = document.body.dataset.mazeStyle || 'classic'; (document.querySelector(`#modal-mazeStyle input[value="${currentStyle}"]`) ?? document.querySelector('#modal-mazeStyle input[value="classic"]')).checked = true; this.filterPlayerChoicesByStyle(currentStyle); const currentPlayerBaseColor = this.getCurrentPlayerColor(true); const playerRadio = document.querySelector(`#modal-playerChoice input[value="${currentPlayerBaseColor}"]`); if (playerRadio && !playerRadio.parentElement.hidden) playerRadio.checked = true; else (document.querySelector('#modal-playerChoice input[name="modal-player"]:not([data-style-specific]):not([hidden])') ?? document.querySelector('#modal-playerChoice input[name="modal-player"]')).checked = true; this.updatePlayerColorVisuals(this.ui.darkModeToggle.checked); const currentExit = this.renderer.exitMarker || '🏁'; (document.querySelector(`#modal-exitChoice input[value="${currentExit}"]`) ?? document.querySelector('#modal-exitChoice input[value="🏁"]')).checked = true; }
        applyInitialSettings() { const isLikelyMobile = window.innerWidth < MOBILE_BREAKPOINT_WIDTH; const maxInputDim = isLikelyMobile ? MOBILE_MAX_INPUT_DIMENSION : MAX_MAZE_DIMENSION; [this.ui.widthInput, this.ui.heightInput].forEach(input => { input.max = maxInputDim; input.value = clamp(parseInt(input.value || 15), MIN_MAZE_DIMENSION, maxInputDim); const label = input.previousElementSibling; if(label?.tagName === 'LABEL') label.textContent = `${label.textContent.split('(')[0].trim()} (${MIN_MAZE_DIMENSION}-${maxInputDim}):`; }); const prefersDark = window.matchMedia?.('(prefers-color-scheme: dark)').matches ?? false; this.setDarkMode(prefersDark); this.ui.darkModeToggle.checked = prefersDark; const initialStyle = document.querySelector('#modal-mazeStyle input:checked')?.value || 'classic'; this.setMazeStyle(initialStyle); if (!document.querySelector('#modal-playerChoice input:checked') || document.querySelector('#modal-playerChoice input:checked').parentElement.hidden) { (document.querySelector(`#modal-playerChoice label:not([hidden]) input`) ?? document.querySelector('#modal-playerChoice input[name="modal-player"]')).checked = true; } this.updatePlayerColor(document.querySelector('#modal-playerChoice input:checked')); this.renderer.setExitMarker(document.querySelector('#modal-exitChoice input:checked')?.value || '🏁'); this.ui.viewModeBtn.title = `Cambiar Vista (Actual: ${this.renderer.viewMode === 'overview' ? 'General' : 'Jugador'})`; const customRadio = this.ui.difficultyChoiceGroup.querySelector('input[value="custom"]'); if(customRadio) customRadio.checked = true; this.handleDifficultyChange('custom'); this.ui.timeLimitInputGroup.hidden = true; }
        validateDimensions() { const maxDim = parseInt(this.ui.widthInput.max); this.ui.widthInput.value = clamp(parseInt(this.ui.widthInput.value || MIN_MAZE_DIMENSION, 10), MIN_MAZE_DIMENSION, maxDim); this.ui.heightInput.value = clamp(parseInt(this.ui.heightInput.value || MIN_MAZE_DIMENSION, 10), MIN_MAZE_DIMENSION, maxDim); }
        validateDimensionsAndUpdateBestTime() { this.validateDimensions(); this.updateBestTimeDisplay(`${this.ui.widthInput.value}x${this.ui.heightInput.value}`); }

        startTimer() { if (this.timerStarted || this.currentGameState !== 'playing') return; this.gameStartTime = Date.now(); this.timerStarted = true; clearInterval(this.gameTimer); if (this.currentGameMode === 'timeAttack') { this.remainingTime = this.timeLimit; this.updateTimerDisplay(); this.gameTimer = setInterval(() => { if (this.currentGameState !== 'playing') { this.stopTimer(); return; } const elapsed = Math.floor((Date.now() - this.gameStartTime) / 1000); this.remainingTime = Math.max(0, this.timeLimit - elapsed); this.updateTimerDisplay(); if (this.remainingTime <= 0) { this.handleTimeUp(); } }, 1000); console.log(`Timer started (Time Attack: ${this.timeLimit}s)`); } else { this.currentTime = 0; this.updateTimerDisplay(); this.gameTimer = setInterval(() => { if (this.currentGameState !== 'playing') { this.stopTimer(); return; } this.currentTime = Math.floor((Date.now() - this.gameStartTime) / 1000); this.updateTimerDisplay(); }, 1000); console.log(`Timer started (${this.currentGameMode})`); } }
        resetTimer() { clearInterval(this.gameTimer); this.gameTimer = null; this.timerStarted = false; this.currentTime = 0; this.remainingTime = null; this.updateTimerDisplay(); console.log("Timer reset"); }
        stopTimer() { clearInterval(this.gameTimer); this.timerStarted = false; const mazeSize = `${this.mazeGenerator?.width ?? 0}x${this.mazeGenerator?.height ?? 0}`; let finalTime = this.currentTime; let isNewBest = false; let success = true; if (this.currentGameMode === 'timeAttack') { finalTime = this.timeLimit - (this.remainingTime ?? 0); success = (this.remainingTime ?? -1) > 0; console.log(`Timer stopped (Time Attack). Time Taken: ${finalTime}s. Success: ${success}`); } else { console.log(`Timer stopped (${this.currentGameMode}). Final time: ${finalTime}s`); if (this.currentGameMode === 'classic' && mazeSize !== '0x0') { if (!this.bestTimes[mazeSize] || finalTime < this.bestTimes[mazeSize]) { this.bestTimes[mazeSize] = finalTime; localStorage.setItem('mazeClassicBestTimes', JSON.stringify(this.bestTimes)); isNewBest = true; console.log(`New best time for ${mazeSize}: ${finalTime}s`); this.updateBestTimeDisplay(mazeSize); } } } return { time: finalTime, isNewBest, success }; }
        handleTimeUp() { if (this.currentGameState !== 'playing') return; console.log("Time's Up!"); this.currentGameState = 'gameOver'; this.gameActive = false; this.stopTimer(); this.stopGameLoop(); this.showMessage("¡Tiempo Agotado! ⌛", "Se acabó el tiempo.", "", `Límite: ${this.formatTime(this.timeLimit)}`);
            // GA4 Event: Level End (Time Up)
            if (typeof gtag === 'function') {
                gtag('event', 'level_end', {
                    level_name: `${this.mazeGenerator.width}x${this.mazeGenerator.height}_${this.currentGameMode}`,
                    success: false,
                    reason: 'time_up',
                    time_seconds: this.timeLimit, // Time taken is the full limit
                    moves: this.moveCounter
                });
            }
        }
        formatTime(totalSeconds) { if (totalSeconds === undefined || totalSeconds === null || totalSeconds < 0) return '--:--'; const hours = Math.floor(totalSeconds / 3600); const minutes = Math.floor((totalSeconds % 3600) / 60); const seconds = totalSeconds % 60; const pad = (n) => n.toString().padStart(2, '0'); return hours > 0 ? `${hours}:${pad(minutes)}:${pad(seconds)}` : `${pad(minutes)}:${pad(seconds)}`; }
        updateTimerDisplay() { let timeToShow = 0; if (this.currentGameMode === 'timeAttack') { timeToShow = this.remainingTime ?? this.timeLimit ?? 0; } else { timeToShow = this.currentTime; } const timerElement = this.ui.currentTimeDisplay.parentElement; if (!timerElement) return; this.ui.currentTimeDisplay.textContent = this.formatTime(timeToShow); const isLowTime = this.currentGameMode === 'timeAttack' && this.remainingTime !== null && this.remainingTime <= 10 && this.remainingTime > 0; timerElement.style.color = isLowTime ? 'red' : ''; timerElement.classList.toggle('pulsing', isLowTime); if (!timerElement.style.animation && isLowTime) { timerElement.style.animation = 'pulse 1s infinite'; } else if (timerElement.style.animation && !isLowTime) { timerElement.style.animation = ''; } }
        updateBestTimeDisplay(mazeSize) { const bestTime = this.bestTimes[mazeSize]; const timeStr = bestTime !== undefined && bestTime !== null ? this.formatTime(bestTime) : '--:--'; const label = `Record Clásico (${mazeSize === '0x0' || !mazeSize ? 'N/A' : mazeSize}): ${timeStr}`; if (this.ui.bestTimeNewGameModalDisplay) { this.ui.bestTimeNewGameModalDisplay.textContent = label; } else { console.error("UI element 'bestTimeNewGameModalDisplay' not found."); } }

        async startNewGameFromModal() { if (this.isLoading || this.currentGameState === 'menu') return; this.validateDimensions(); const widthToGenerate = parseInt(this.ui.widthInput.value); const heightToGenerate = parseInt(this.ui.heightInput.value); this.closeNewGameModal(); await new Promise(resolve => setTimeout(resolve, 50)); await this._initiateNewGameGeneration(widthToGenerate, heightToGenerate, this.currentGameMode); }
        async _initiateNewGameGeneration(width, height, mode) {
            if (this.isLoading) { console.warn("Attempted to start new game while already loading."); return; }
            console.log(`Initiating new game generation: ${width}x${height}, Mode: ${mode}`);
            this.isLoading = true; this.gameActive = false; this.currentGameState = 'configuring'; this.stopGameLoop(); this.showLoading(true, 'Generando...'); this.hideMessage(); this.resetTimer(); this.setButtonsDisabled(true); this.currentGameMode = mode; this.moveCounter = 0; // Reset move counter
            this.timeLimit = null; this.remainingTime = null; this.ui.viewModeBtn.disabled = false;
            let difficultySetting = this.ui.difficultyChoiceGroup.querySelector('input[name="difficulty"]:checked')?.value ?? 'custom';

            if (mode === 'timeAttack') {
                const customTimeInput = this.ui.timeLimitInput; const customTimeValue = parseInt(customTimeInput.value);
                if (!isNaN(customTimeValue) && customTimeValue >= TIME_ATTACK_MIN_SECONDS) { this.timeLimit = customTimeValue; console.log(`Using custom time limit: ${this.timeLimit}s`); }
                else { this.timeLimit = this.calculateSuggestedTimeLimit(width, height); console.log(`Using calculated time limit: ${this.timeLimit}s`); }
                this.remainingTime = this.timeLimit;
            } else if (mode === 'exploration') {
                this.ui.viewModeBtn.disabled = true; console.log("View mode button disabled for Exploration.");
            }
            this.updateTimerDisplay();

            try {
                this.setDarkMode(this.ui.darkModeToggle.checked); this.setMazeStyle(document.querySelector('#modal-mazeStyle input:checked')?.value || 'classic', true); this.renderer.setExitMarker(document.querySelector('#modal-exitChoice input:checked')?.value || '🏁'); const initialPlayerColor = this.getCurrentPlayerColor();
                const maze = await this.mazeGenerator.generate(width, height, (progress) => { this.showLoading(true, `Generando... ${Math.round(progress * 100)}%`); });
                if (!maze?.grid) throw new Error("Maze generation failed unexpectedly.");
                this.player = new Player(maze.start.x, maze.start.y, initialPlayerColor); this.renderer.setMaze(maze); this.renderer.setPlayer(this.player);
                let initialView = mode === 'exploration' ? 'playerCamera' : 'overview'; this.renderer.setViewMode(initialView);
                this.updateBestTimeDisplay(`${maze.width}x${maze.height}`);
                this.gameActive = true; this.currentGameState = 'playing'; this.lastTimestamp = performance.now();

                // GA4 Event: Level Start
                if (typeof gtag === 'function') {
                    gtag('event', 'level_start', {
                        level_name: `${width}x${height}_${mode}`,
                        difficulty: difficultySetting, // easy, medium, hard, custom
                        mode: mode, // classic, timeAttack, exploration
                        time_limit: this.timeLimit // Will be null if not timeAttack
                    });
                }

                this.startGameLoop(); console.log("New game started successfully.");
            } catch (error) {
                console.error("Error starting new game:", error); this.showMessage("Error", `No se pudo generar el laberinto.\n(${error.message})`);
                this.currentGameState = 'gameOver'; this.gameActive = false;
                 // GA4 Event: Exception (optional, GA might catch unhandled ones)
                if (typeof gtag === 'function') {
                    gtag('event', 'exception', { description: `Error starting game: ${error.message}`, fatal: true });
                }
            }
            finally { this.isLoading = false; this.showLoading(false); this.setButtonsDisabled(false); this.updateTimerDisplay(); }
         }
        setButtonsDisabled(disabled) { this.ui.bottomNavButtons.forEach(btn => { if (btn === this.ui.viewModeBtn && this.currentGameMode === 'exploration') { btn.disabled = true; } else { btn.disabled = disabled; } }); }
        startGameLoop() { if (this.animationFrameId) return; let lastLoopTime = performance.now(); const loop = (timestamp) => { if (this.currentGameState !== 'playing') { this.animationFrameId = null; return; } const deltaTime = timestamp - lastLoopTime; lastLoopTime = timestamp; if (this.player?.isMoving) this.player.update(deltaTime); if (this.renderer.viewMode === 'playerCamera') this.renderer.updateCamera(deltaTime); this.renderer.drawFrame(timestamp); this.animationFrameId = requestAnimationFrame(loop); }; this.animationFrameId = requestAnimationFrame(loop); }
        stopGameLoop() { if (this.animationFrameId) { cancelAnimationFrame(this.animationFrameId); this.animationFrameId = null; } }
        requestRedraw() { if (this.currentGameState !== 'menu' && this.renderer?.maze) this.renderer.drawFrame(); }

        handleMoveAttempt(dx, dy) {
            if (this.currentGameState !== 'playing' || !this.player || this.isLoading || this.player.isMoving) return;
            const moveResult = this.player.canMove(dx, dy, this.mazeGenerator);
            if (moveResult) { // Successful move
                this.moveCounter++; // Increment move counter
                if (!this.timerStarted) this.startTimer();
                this.player.moveTo(moveResult.newX, moveResult.newY);
                if (!this.animationFrameId && this.currentGameState === 'playing') { this.startGameLoop(); }
                if (moveResult.newX === this.mazeGenerator.end.x && moveResult.newY === this.mazeGenerator.end.y) {
                    this.gameActive = false; this.currentGameState = 'gameOver'; const finalTimeResult = this.stopTimer();
                    // GA4 Event: Level End (Win)
                     if (typeof gtag === 'function') {
                        gtag('event', 'level_end', {
                            level_name: `${this.mazeGenerator.width}x${this.mazeGenerator.height}_${this.currentGameMode}`,
                            success: true,
                            reason: 'completed',
                            time_seconds: finalTimeResult.time,
                            moves: this.moveCounter,
                            score: this.currentGameMode === 'timeAttack' ? this.remainingTime : finalTimeResult.time // Score could be remaining time or elapsed time
                        });
                    }
                    setTimeout(() => { /* ... (Show message logic remains same) ... */
                        if (this.player && Math.round(this.player.pixelX) === this.mazeGenerator.end.x && Math.round(this.player.pixelY) === this.mazeGenerator.end.y) { const finalTimeStr = this.formatTime(finalTimeResult.time); const mazeSize = `${this.mazeGenerator.width}x${this.mazeGenerator.height}`; let title = "¡Completado! 🎉"; let message = "Has encontrado la salida."; let timeMsg = ""; let bestMsg = ""; if (this.currentGameMode === 'classic') { timeMsg = `Tu Tiempo: ${finalTimeStr}`; const bestTime = this.bestTimes[mazeSize]; const bestTimeStr = bestTime !== undefined ? this.formatTime(bestTime) : '--:--'; bestMsg = `Mejor tiempo (${mazeSize}): ${bestTimeStr}`; if (finalTimeResult.isNewBest) { title = "¡Nuevo Récord! 🏆"; message = "¡Nuevo récord establecido!"; bestMsg = `Récord (${mazeSize}): ${finalTimeStr}`; } } else if (this.currentGameMode === 'timeAttack') { title = "¡Victoria Contrarreloj! ⏱️"; message = "¡Lo lograste a tiempo!"; timeMsg = `Tiempo Usado: ${finalTimeStr}`; bestMsg = `Tiempo Restante: ${this.formatTime(this.remainingTime ?? 0)}`; } else if (this.currentGameMode === 'exploration') { title = "¡Exploración Completada! 🔦"; message = "Encontraste la salida en la oscuridad."; timeMsg = `Tiempo: ${finalTimeStr}`; } this.showMessage(title, message, timeMsg, bestMsg); } else { this.showMessage("¡Completado! 🎉", "Has encontrado la salida."); }
                     }, PLAYER_SMOOTHING * 800);
                }
            } else { // Attempted move failed (hit wall)
                // GA4 Event: Player Interaction (Hit Wall)
                 if (typeof gtag === 'function') {
                     gtag('event', 'player_interaction', {
                         interaction_type: 'hit_wall',
                         // Optional: add player coordinates or attempted direction
                         // direction: dx === 1 ? 'right' : dx === -1 ? 'left' : dy === 1 ? 'down' : 'up'
                     });
                 }
            }
        }
        handleKeyDown(e) { if (this.currentGameState !== 'playing' || this.isLoading) return; let dx = 0, dy = 0; switch (e.key.toLowerCase()) { case 'arrowup': case 'w': dy = -1; break; case 'arrowdown': case 's': dy = 1; break; case 'arrowleft': case 'a': dx = -1; break; case 'arrowright': case 'd': dx = 1; break; default: return; } e.preventDefault(); this.handleMoveAttempt(dx, dy); }
        handleTouchStart(e) { if (this.currentGameState !== 'playing' || this.isLoading || e.touches.length !== 1) return; this.touchStartX = e.touches[0].clientX; this.touchStartY = e.touches[0].clientY; this.touchEndX = this.touchStartX; this.touchEndY = this.touchStartY; }
        handleTouchMove(e) { if (this.currentGameState !== 'playing' || this.isLoading || e.touches.length !== 1) return; this.touchEndX = e.touches[0].clientX; this.touchEndY = e.touches[0].clientY; e.preventDefault(); }
        handleTouchEnd(e) { if (this.currentGameState !== 'playing' || this.isLoading || (this.touchStartX === 0 && this.touchStartY === 0)) return; const deltaX = this.touchEndX - this.touchStartX, deltaY = this.touchEndY - this.touchStartY; const absDeltaX = Math.abs(deltaX), absDeltaY = Math.abs(deltaY); let dx = 0, dy = 0; if (Math.max(absDeltaX, absDeltaY) > SWIPE_THRESHOLD) { if (absDeltaX > absDeltaY) dx = deltaX > 0 ? 1 : -1; else dy = deltaY > 0 ? 1 : -1; this.handleMoveAttempt(dx, dy); } this.touchStartX = this.touchStartY = this.touchEndX = this.touchEndY = 0; }

        setDarkMode(isDark) { document.body.classList.toggle('dark-mode', isDark); this.updatePlayerColorVisuals(isDark); this.updatePlayerColor(document.querySelector('#modal-playerChoice input:checked')); if (this.renderer) { this.renderer.updateStyleSettings(true); this.requestRedraw(); } console.log(`Dark mode ${isDark ? 'enabled' : 'disabled'}`);
            // GA4 Event: Change Setting
            if (typeof gtag === 'function') { gtag('event', 'change_setting', { setting_type: 'dark_mode', setting_value: isDark ? 'on' : 'off' }); }
        }
        setMazeStyle(styleName, forceUpdate = false) { const currentStyle = document.body.dataset.mazeStyle; if (!forceUpdate && currentStyle === styleName) return; document.body.dataset.mazeStyle = styleName; console.log(`Maze style set to: ${styleName}`); this.filterPlayerChoicesByStyle(styleName); const currentSelectedPlayerRadio = document.querySelector('#modal-playerChoice input:checked'); if (!currentSelectedPlayerRadio || currentSelectedPlayerRadio.parentElement.hidden) { (document.querySelector(`#modal-playerChoice label:not([hidden]) input`) ?? document.querySelector('#modal-playerChoice input[name="modal-player"]')).checked = true; } this.updatePlayerColor(document.querySelector('#modal-playerChoice input:checked')); if (this.renderer) { this.renderer.updateStyleSettings(true); this.renderer.setExitMarker(document.querySelector('#modal-exitChoice input:checked')?.value || '🏁'); this.requestRedraw(); }
            // GA4 Event: Change Setting
             if (typeof gtag === 'function' && !forceUpdate) { gtag('event', 'change_setting', { setting_type: 'visual_style', setting_value: styleName }); }
        }
        filterPlayerChoicesByStyle(styleName) { document.querySelectorAll('#modal-playerChoice label').forEach(label => { const input = label.querySelector('input'); label.hidden = input.dataset.styleSpecific && input.dataset.styleSpecific !== styleName; }); this.updatePlayerColorVisuals(document.body.classList.contains('dark-mode')); }
        updatePlayerColor(radioElement) { if (!radioElement?.checked) radioElement = document.querySelector('#modal-playerChoice input:checked'); if (!radioElement) return; const newColor = this.calculatePlayerColor(radioElement); if (this.player) { this.player.setColor(newColor); this.requestRedraw(); } this.minimap?.updateColors();
             // GA4 Event: Change Setting (Send base color value)
             if (typeof gtag === 'function' && radioElement.value) { gtag('event', 'change_setting', { setting_type: 'player_color', setting_value: radioElement.getAttribute('title') || radioElement.value }); }
        }
        updatePlayerColorVisuals(isDark) { document.querySelectorAll('#modal-playerChoice input[type="radio"]').forEach(radio => { const colorToShow = this.calculatePlayerColor(radio, isDark); const previewSpan = radio.nextElementSibling; if (previewSpan?.classList.contains('color-preview')) previewSpan.style.backgroundColor = colorToShow; }); }
        calculatePlayerColor(radioElement, isDark = document.body.classList.contains('dark-mode')) { if (!radioElement) return getCssVariable('--player-color'); return isDark ? (radioElement.dataset.dark || radioElement.value) : (radioElement.dataset.light || radioElement.value); }
        getCurrentPlayerColor(getBaseValue = false) { const selectedRadio = document.querySelector('#modal-playerChoice input:checked'); if (!selectedRadio) return getCssVariable('--player-color'); return getBaseValue ? selectedRadio.value : this.calculatePlayerColor(selectedRadio); }

        showMessage(title, text, finalTimeStr = '', bestTimeMsg = '') { const overlay = this.ui.messageOverlay; overlay.querySelector('h2').textContent = title; (overlay.querySelector('p:not([id])') ?? {}).innerHTML = text.replace(/\n/g, '<br>'); const finalTimeEl = document.getElementById('final-time-msg'); const bestTimeEl = document.getElementById('final-best-time-msg'); finalTimeEl.textContent = finalTimeStr; bestTimeEl.textContent = bestTimeMsg; finalTimeEl.style.display = finalTimeStr ? 'block' : 'none'; bestTimeEl.style.display = bestTimeMsg ? 'block' : 'none'; overlay.classList.add('visible'); this.currentGameState = 'gameOver'; this.gameActive = false; this.stopGameLoop(); console.log(`Message shown: ${title}`); }
        hideMessage() { this.ui.messageOverlay.classList.remove('visible'); }
        showLoading(show, text = 'Generando...') { const indicator = this.ui.loadingIndicator; indicator.textContent = text; indicator.classList.toggle('visible', show); if (!show && this.isLoading) return; this.setButtonsDisabled(show); }
        handlePrint() {
             // GA4 Event: Share (Example, might not be the best fit for print)
             if (typeof gtag === 'function') { gtag('event', 'share', { method: 'Print', content_type: 'maze', item_id: `${this.mazeGenerator?.width}x${this.mazeGenerator?.height}` }); }
             if (this.currentGameState === 'menu' || !this.mazeGenerator?.generationComplete || !this.renderer || !this.player) return alert('Selecciona un modo y genera un laberinto antes de imprimir.'); if (this.isLoading || this.renderer.isPrinting) return alert('Espera a que termine la acción actual antes de imprimir.'); console.log("Initiating print..."); const savedState = this.renderer.prepareForPrint(); if (!savedState) { console.error("Failed to prepare renderer for printing."); alert("Error al preparar la impresión."); this.renderer.isPrinting = false; return; } setTimeout(() => { try { window.print(); console.log("Print dialog should be open."); setTimeout(() => this.renderer.restoreAfterPrint(savedState), 200); } catch (e) { console.error("Error during window.print():", e); alert("Ocurrió un error al intentar imprimir."); this.renderer.restoreAfterPrint(savedState); } }, 100);
         }
    }

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        requestAnimationFrame(() => {
            try { window.mazeGame = new Game(); console.log("Maze Game System Initialized."); }
            catch (error) {
                console.error("Failed to initialize Maze Game:", error);
                document.body.innerHTML = `<div style="padding: 20px; text-align: center; color: red;">Error crítico al iniciar la aplicación: ${error.message}. Por favor, recarga la página.</div>`;
                // GA4 Event: Exception on critical init error
                if (typeof gtag === 'function') {
                    gtag('event', 'exception', { description: `Critical Init Error: ${error.message}`, fatal: true });
                }
            }
        });
    });
</script>
</body>
</html>
